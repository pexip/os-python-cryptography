diff --git a/src/_cffi_src/build_openssl.py b/src/_cffi_src/build_openssl.py
index a8e560960..81e8cc1e1 100644
--- a/src/_cffi_src/build_openssl.py
+++ b/src/_cffi_src/build_openssl.py
@@ -77,6 +77,7 @@ ffi = build_ffi_for_binding(
         "cryptography",
         # Provider comes early as well so we define OSSL_LIB_CTX
         "provider",
+        "params",
         "asn1",
         "bignum",
         "bio",
@@ -86,6 +87,8 @@ ffi = build_ffi_for_binding(
         "dsa",
         "ec",
         "ecdsa",
+        "rsa",
+        "encdec",
         "engine",
         "err",
         "evp",
@@ -98,7 +101,6 @@ ffi = build_ffi_for_binding(
         "pem",
         "pkcs12",
         "rand",
-        "rsa",
         "ssl",
         "x509",
         "x509name",
diff --git a/src/_cffi_src/openssl/bignum.py b/src/_cffi_src/openssl/bignum.py
index 052c7ed94..08a70ac8b 100644
--- a/src/_cffi_src/openssl/bignum.py
+++ b/src/_cffi_src/openssl/bignum.py
@@ -93,4 +93,9 @@ int (*BN_prime_checks_for_size)(int) = NULL;
 #else
 static const long Cryptography_HAS_BN_FLAGS = 1;
 #endif
+
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+int (*BN_is_prime_ex)(const BIGNUM *, int, BN_CTX *, BN_GENCB *) = NULL;
+const int (*BN_prime_checks_for_size)(int) = NULL;
+#endif
 """
diff --git a/src/_cffi_src/openssl/cmac.py b/src/_cffi_src/openssl/cmac.py
index a25426305..eb22e15a4 100644
--- a/src/_cffi_src/openssl/cmac.py
+++ b/src/_cffi_src/openssl/cmac.py
@@ -23,4 +23,13 @@ void CMAC_CTX_free(CMAC_CTX *);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+typedef void CMAC_CTX;
+CMAC_CTX *(*CMAC_CTX_new)(void) = NULL;
+int (*CMAC_Init)(CMAC_CTX *, const void *, size_t, const EVP_CIPHER *, ENGINE *) = NULL;
+int (*CMAC_Update)(CMAC_CTX *, const void *, size_t) = NULL;
+int (*CMAC_Final)(CMAC_CTX *, unsigned char *, size_t *) = NULL;
+int (*CMAC_CTX_copy)(CMAC_CTX *, const CMAC_CTX *) = NULL;
+void (*CMAC_CTX_free)(CMAC_CTX *) = NULL;
+#endif
 """
diff --git a/src/_cffi_src/openssl/dh.py b/src/_cffi_src/openssl/dh.py
index 44b3d817a..61224c19c 100644
--- a/src/_cffi_src/openssl/dh.py
+++ b/src/_cffi_src/openssl/dh.py
@@ -32,11 +32,37 @@ DH *d2i_DHparams_bio(BIO *, DH **);
 int i2d_DHparams_bio(BIO *, DH *);
 DH *d2i_DHxparams_bio(BIO *, DH **);
 int i2d_DHxparams_bio(BIO *, DH *);
+
+int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX *ctx, int pbits);
+int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX *ctx, int gen);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+const long DH_NOT_SUITABLE_GENERATOR = 0;
+
+DH *(*DH_new)(void) = NULL;
+void (*DH_free)(DH *) = NULL;
+int (*DH_size)(const DH *) = NULL;
+int (*DH_generate_key)(DH *) = NULL;
+DH *(*DHparams_dup)(DH *) = NULL;
+
+void (*DH_get0_pqg)(const DH *, const BIGNUM **, const BIGNUM **,
+                 const BIGNUM **) = NULL;
+int (*DH_set0_pqg)(DH *, BIGNUM *, BIGNUM *, BIGNUM *) = NULL;
+void (*DH_get0_key)(const DH *, const BIGNUM **, const BIGNUM **) = NULL;
+int (*DH_set0_key)(DH *, BIGNUM *, BIGNUM *) = NULL;
+
+int (*DH_check)(const DH *, int *) = NULL;
+int (*DH_generate_parameters_ex)(DH *, int, int, BN_GENCB *) = NULL;
+DH *(*d2i_DHparams_bio)(BIO *, DH **) = NULL;
+int (*i2d_DHparams_bio)(BIO *, DH *) = NULL;
+DH *(*d2i_DHxparams_bio)(BIO *, DH **) = NULL;
+int (*i2d_DHxparams_bio)(BIO *, DH *) = NULL;
+#else
 #if !(defined(EVP_PKEY_DHX) && EVP_PKEY_DHX != -1)
 DH *(*d2i_DHxparams_bio)(BIO *bp, DH **x) = NULL;
 int (*i2d_DHxparams_bio)(BIO *bp, DH *x) = NULL;
 #endif
+#endif
 """
diff --git a/src/_cffi_src/openssl/dsa.py b/src/_cffi_src/openssl/dsa.py
index cf34913b5..38bcca952 100644
--- a/src/_cffi_src/openssl/dsa.py
+++ b/src/_cffi_src/openssl/dsa.py
@@ -29,7 +29,30 @@ void DSA_get0_key(const DSA *, const BIGNUM **, const BIGNUM **);
 int DSA_set0_key(DSA *, BIGNUM *, BIGNUM *);
 int DSA_generate_parameters_ex(DSA *, int, unsigned char *, int,
                                int *, unsigned long *, BN_GENCB *);
+
+int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx, int nbits);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+typedef void DSA;
+
+int (*DSA_generate_key)(DSA *) = NULL;
+DSA *(*DSA_new)(void) = NULL;
+void (*DSA_free)(DSA *) = NULL;
+DSA *(*DSAparams_dup)(DSA *) = NULL;
+int (*DSA_size)(const DSA *) = NULL;
+int (*DSA_sign)(int, const unsigned char *, int, unsigned char *, unsigned int *,
+             DSA *) = NULL;
+int (*DSA_verify)(int, const unsigned char *, int, const unsigned char *, int,
+               DSA *) = NULL;
+
+void (*DSA_get0_pqg)(const DSA *, const BIGNUM **, const BIGNUM **,
+                  const BIGNUM **) = NULL;
+int (*DSA_set0_pqg)(DSA *, BIGNUM *, BIGNUM *, BIGNUM *) = NULL;
+void (*DSA_get0_key)(const DSA *, const BIGNUM **, const BIGNUM **) = NULL;
+int (*DSA_set0_key)(DSA *, BIGNUM *, BIGNUM *) = NULL;
+int (*DSA_generate_parameters_ex)(DSA *, int, unsigned char *, int,
+                               int *, unsigned long *, BN_GENCB *) = NULL;
+#endif
 """
diff --git a/src/_cffi_src/openssl/ec.py b/src/_cffi_src/openssl/ec.py
index d9c3074cc..f80d5f51b 100644
--- a/src/_cffi_src/openssl/ec.py
+++ b/src/_cffi_src/openssl/ec.py
@@ -59,9 +59,15 @@ void EC_POINT_free(EC_POINT *);
 void EC_POINT_clear_free(EC_POINT *);
 EC_POINT *EC_POINT_dup(const EC_POINT *, const EC_GROUP *);
 
+int EC_POINT_set_affine_coordinates(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, BN_CTX *);
+
 int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *, EC_POINT *,
     const BIGNUM *, const BIGNUM *, BN_CTX *);
 
+int EC_POINT_get_affine_coordinates(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *);
+
 int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *,
     const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *);
 
@@ -97,6 +103,41 @@ int EC_GROUP_get_asn1_flag(const EC_GROUP *);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+static const int Cryptography_HAS_EC2M = 1;
+
+#ifdef OPENSSL_NO_DEPRECATED_3_0
+typedef void EC_KEY;
+typedef void EC_METHOD;
+
+const EC_METHOD *(*EC_GROUP_method_of)(const EC_GROUP *) = NULL;
+
+EC_KEY *(*EC_KEY_new)(void) = NULL;
+void (*EC_KEY_free)(EC_KEY *) = NULL;
+
+EC_KEY *(*EC_KEY_new_by_curve_name)(int) = NULL;
+const EC_GROUP *(*EC_KEY_get0_group)(const EC_KEY *) = NULL;
+int (*EC_KEY_set_group)(EC_KEY *, const EC_GROUP *) = NULL;
+const BIGNUM *(*EC_KEY_get0_private_key)(const EC_KEY *) = NULL;
+int (*EC_KEY_set_private_key)(EC_KEY *, const BIGNUM *) = NULL;
+const EC_POINT *(*EC_KEY_get0_public_key)(const EC_KEY *) = NULL;
+int (*EC_KEY_set_public_key)(EC_KEY *, const EC_POINT *) = NULL;
+void (*EC_KEY_set_asn1_flag)(EC_KEY *, int) = NULL;
+int (*EC_KEY_generate_key)(EC_KEY *) = NULL;
+int (*EC_KEY_set_public_key_affine_coordinates)(EC_KEY *, BIGNUM *, BIGNUM *) = NULL;
+
+int (*EC_POINT_set_affine_coordinates_GFp)(const EC_GROUP *, EC_POINT *,
+    const BIGNUM *, const BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_get_affine_coordinates_GFp)(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_POINT_get_affine_coordinates_GF2m)(const EC_GROUP *,
+    const EC_POINT *, BIGNUM *, BIGNUM *, BN_CTX *) = NULL;
+
+int (*EC_METHOD_get_field_type)(const EC_METHOD *) = NULL;
+#endif
+#else
 #if defined(OPENSSL_NO_EC2M)
 static const long Cryptography_HAS_EC2M = 0;
 
@@ -106,4 +147,5 @@ int (*EC_POINT_get_affine_coordinates_GF2m)(const EC_GROUP *,
 #else
 static const long Cryptography_HAS_EC2M = 1;
 #endif
+#endif
 """
diff --git a/src/_cffi_src/openssl/ecdsa.py b/src/_cffi_src/openssl/ecdsa.py
index 53294afc6..a2fa63be3 100644
--- a/src/_cffi_src/openssl/ecdsa.py
+++ b/src/_cffi_src/openssl/ecdsa.py
@@ -20,4 +20,11 @@ int ECDSA_size(const EC_KEY *);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+int (*ECDSA_sign)(int, const unsigned char *, int, unsigned char *,
+               unsigned int *, EC_KEY *) = NULL;
+int (*ECDSA_verify)(int, const unsigned char *, int, const unsigned char *, int,
+                 EC_KEY *) = NULL;
+int (*ECDSA_size)(const EC_KEY *) = NULL;
+#endif
 """
diff --git a/src/_cffi_src/openssl/encdec.py b/src/_cffi_src/openssl/encdec.py
new file mode 100644
index 000000000..86a031160
--- /dev/null
+++ b/src/_cffi_src/openssl/encdec.py
@@ -0,0 +1,55 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+
+INCLUDES = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+#include <openssl/encoder.h>
+#include <openssl/decoder.h>
+#endif
+"""
+
+TYPES = """
+typedef ... OSSL_DECODER_CTX;
+typedef ... OSSL_ENCODER_CTX;
+"""
+
+FUNCTIONS = """
+OSSL_DECODER_CTX *OSSL_DECODER_CTX_new_for_pkey(EVP_PKEY **,
+                                                const char *, const char *,
+                                                const char *, int,
+                                                OSSL_LIB_CTX *, const char *);
+void OSSL_DECODER_CTX_free(OSSL_DECODER_CTX *);
+int OSSL_DECODER_from_bio(OSSL_DECODER_CTX *, BIO *);
+
+OSSL_ENCODER_CTX *OSSL_ENCODER_CTX_new_for_pkey(const EVP_PKEY *, int,
+                                                const char *, const char *,
+                                                const char *);
+void OSSL_ENCODER_CTX_free(OSSL_ENCODER_CTX *);
+int OSSL_ENCODER_to_bio(OSSL_ENCODER_CTX *, BIO *);
+int OSSL_ENCODER_CTX_set_cipher(OSSL_ENCODER_CTX *, const char *, const char *);
+int OSSL_ENCODER_CTX_set_passphrase(OSSL_ENCODER_CTX *, const unsigned char *, size_t);
+"""
+
+CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+#else
+typedef void OSSL_DECODER_CTX;
+typedef void OSSL_ENCODER_CTX;
+OSSL_DECODER_CTX *(*OSSL_DECODER_CTX_new_for_pkey)(EVP_PKEY **,
+                                                const char *, const char *,
+                                                const char *, int,
+                                                OSSL_LIB_CTX *, const char *) = NULL;
+void (*OSSL_DECODER_CTX_free)(OSSL_DECODER_CTX *) = NULL;
+int (*OSSL_DECODER_from_bio)(OSSL_DECODER_CTX *, BIO *) = NULL;
+
+OSSL_ENCODER_CTX *(*OSSL_ENCODER_CTX_new_for_pkey)(const EVP_PKEY *, int,
+                                                const char *, const char *,
+                                                const char *) = NULL;
+void (*OSSL_ENCODER_CTX_free)(OSSL_ENCODER_CTX *) = NULL;
+int (*OSSL_ENCODER_to_bio)(OSSL_ENCODER_CTX *, BIO *) = NULL;
+int (*OSSL_ENCODER_CTX_set_cipher)(OSSL_ENCODER_CTX *, const char *, const char *) = NULL;
+int (*OSSL_ENCODER_CTX_set_passphrase)(OSSL_ENCODER_CTX *, const unsigned char *, size_t) = NULL;
+#endif
+"""
diff --git a/src/_cffi_src/openssl/err.py b/src/_cffi_src/openssl/err.py
index dc27abba3..6e707c16a 100644
--- a/src/_cffi_src/openssl/err.py
+++ b/src/_cffi_src/openssl/err.py
@@ -10,6 +10,8 @@ INCLUDES = """
 TYPES = """
 static const int CIPHER_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH;
 
+static const int DH_R_NOT_SUITABLE_GENERATOR;
+
 static const int EVP_F_EVP_ENCRYPTFINAL_EX;
 static const int EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH;
 static const int EVP_R_BAD_DECRYPT;
@@ -18,6 +20,7 @@ static const int PKCS12_R_PKCS12_CIPHERFINAL_ERROR;
 static const int PEM_R_UNSUPPORTED_ENCRYPTION;
 static const int EVP_R_XTS_DUPLICATED_KEYS;
 
+static const int ERR_LIB_DH;
 static const int ERR_LIB_EVP;
 static const int ERR_LIB_PEM;
 static const int ERR_LIB_PROV;
@@ -80,4 +83,16 @@ static const int CIPHER_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH = 0;
 #define Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING 0
 #define SSL_R_UNEXPECTED_EOF_WHILE_READING 0
 #endif
+
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+static const int EVP_F_EVP_ENCRYPTFINAL_EX = 0;
+
+const char *(*ERR_func_error_string)(unsigned long) = NULL;
+void ERR_put_error(int lib, int func, int reason, const char *file, int line)
+{
+    ERR_new();
+    ERR_set_debug(file, line, OPENSSL_FUNC);
+    ERR_set_error(lib, reason, NULL);
+}
+#endif
 """
diff --git a/src/_cffi_src/openssl/evp.py b/src/_cffi_src/openssl/evp.py
index 44e8a6e29..992daf455 100644
--- a/src/_cffi_src/openssl/evp.py
+++ b/src/_cffi_src/openssl/evp.py
@@ -8,13 +8,21 @@ INCLUDES = """
 """
 
 TYPES = """
+typedef ... ASN1_PCTX;
+
 typedef ... EVP_CIPHER;
 typedef ... EVP_CIPHER_CTX;
 typedef ... EVP_MD;
 typedef ... EVP_MD_CTX;
 
+typedef ... EVP_MAC;
+typedef ... EVP_MAC_CTX;
+
+typedef ... EVP_KEYMGMT;
+
 typedef ... EVP_PKEY;
 typedef ... EVP_PKEY_CTX;
+static const int EVP_PKEY_NONE;
 static const int EVP_PKEY_RSA;
 static const int EVP_PKEY_RSA_PSS;
 static const int EVP_PKEY_DSA;
@@ -30,6 +38,15 @@ static const int EVP_MAX_MD_SIZE;
 static const int EVP_CTRL_AEAD_SET_IVLEN;
 static const int EVP_CTRL_AEAD_GET_TAG;
 static const int EVP_CTRL_AEAD_SET_TAG;
+static const int EVP_PKEY_KEY_PARAMETERS;
+static const int EVP_PKEY_PUBLIC_KEY;
+static const int EVP_PKEY_KEYPAIR;
+
+/* These come from core_dispatch.h, but that's included transitively */
+static const int OSSL_KEYMGMT_SELECT_PRIVATE_KEY;
+static const int OSSL_KEYMGMT_SELECT_PUBLIC_KEY;
+static const int OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS;
+static const int OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS;
 
 static const int Cryptography_HAS_EVP_PKEY_set_alias_type;
 static const int Cryptography_HAS_SCRYPT;
@@ -46,6 +63,7 @@ FUNCTIONS = """
 const EVP_CIPHER *EVP_get_cipherbyname(const char *);
 EVP_CIPHER *EVP_CIPHER_fetch(OSSL_LIB_CTX *, const char *, const char *);
 void EVP_CIPHER_free(EVP_CIPHER *);
+const char *EVP_CIPHER_name(const EVP_CIPHER *);
 
 int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *, int);
 int EVP_CipherInit_ex(EVP_CIPHER_CTX *, const EVP_CIPHER *, ENGINE *,
@@ -64,6 +82,21 @@ int EVP_DigestUpdate(EVP_MD_CTX *, const void *, size_t);
 int EVP_DigestFinal_ex(EVP_MD_CTX *, unsigned char *, unsigned int *);
 int EVP_DigestFinalXOF(EVP_MD_CTX *, unsigned char *, size_t);
 const EVP_MD *EVP_get_digestbyname(const char *);
+const char *EVP_MD_name(const EVP_MD *);
+
+EVP_MAC *EVP_MAC_fetch(OSSL_LIB_CTX *, const char *, const char *);
+void EVP_MAC_free(EVP_MAC *);
+
+EVP_MAC_CTX *EVP_MAC_CTX_new(EVP_MAC *);
+void EVP_MAC_CTX_free(EVP_MAC_CTX *);
+EVP_MAC_CTX *EVP_MAC_CTX_dup(const EVP_MAC_CTX *);
+
+int EVP_MAC_init(EVP_MAC_CTX *, const unsigned char *, size_t, const OSSL_PARAM[]);
+int EVP_MAC_update(EVP_MAC_CTX *, const unsigned char *, size_t);
+int EVP_MAC_final(EVP_MAC_CTX *, unsigned char *, size_t *, size_t);
+
+EVP_KEYMGMT *EVP_KEYMGMT_fetch(OSSL_LIB_CTX *, const char *, const char *);
+void EVP_KEYMGMT_free(EVP_KEYMGMT *);
 
 EVP_PKEY *EVP_PKEY_new(void);
 void EVP_PKEY_free(EVP_PKEY *);
@@ -116,7 +149,14 @@ int EVP_PKEY_set1_DSA(EVP_PKEY *, DSA *);
 int EVP_PKEY_set1_DH(EVP_PKEY *, DH *);
 
 int EVP_PKEY_cmp(const EVP_PKEY *, const EVP_PKEY *);
+int EVP_PKEY_eq(const EVP_PKEY *, const EVP_PKEY *);
+
+int EVP_PKEY_check(EVP_PKEY_CTX *);
+int EVP_PKEY_param_check(EVP_PKEY_CTX *);
+int EVP_PKEY_public_check(EVP_PKEY_CTX *);
 
+int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *);
+int EVP_PKEY_paramgen(EVP_PKEY_CTX *, EVP_PKEY **);
 int EVP_PKEY_keygen_init(EVP_PKEY_CTX *);
 int EVP_PKEY_keygen(EVP_PKEY_CTX *, EVP_PKEY **);
 int EVP_PKEY_derive_init(EVP_PKEY_CTX *);
@@ -124,8 +164,18 @@ int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *, EVP_PKEY *);
 int EVP_PKEY_derive(EVP_PKEY_CTX *, unsigned char *, size_t *);
 int EVP_PKEY_set_alias_type(EVP_PKEY *, int);
 int EVP_PKEY_set_type(EVP_PKEY *, int);
+int EVP_PKEY_set_type_by_keymgmt(EVP_PKEY *, EVP_KEYMGMT *);
+
+EVP_PKEY *EVP_PKEY_Q_keygen(OSSL_LIB_CTX *, const char *, const char *, ...);
+
+int EVP_PKEY_copy_parameters(EVP_PKEY *, const EVP_PKEY *);
 
 int EVP_PKEY_id(const EVP_PKEY *);
+int EVP_PKEY_is_a(const EVP_PKEY *, const char *);
+
+int EVP_PKEY_print_params(BIO *, const EVP_PKEY *, int, ASN1_PCTX *);
+int EVP_PKEY_print_public(BIO *, const EVP_PKEY *, int, ASN1_PCTX *);
+int EVP_PKEY_print_private(BIO *, const EVP_PKEY *, int, ASN1_PCTX *);
 
 EVP_MD_CTX *EVP_MD_CTX_new(void);
 void EVP_MD_CTX_free(EVP_MD_CTX *);
@@ -137,6 +187,9 @@ int EVP_DigestVerify(EVP_MD_CTX *, const unsigned char *, size_t,
 size_t EVP_PKEY_get1_tls_encodedpoint(EVP_PKEY *, unsigned char **);
 int EVP_PKEY_set1_tls_encodedpoint(EVP_PKEY *, const unsigned char *,
                                    size_t);
+size_t EVP_PKEY_get1_encoded_public_key(EVP_PKEY *, unsigned char **);
+int EVP_PKEY_set1_encoded_public_key(EVP_PKEY *, const unsigned char *,
+                                   size_t);
 
 int EVP_PKEY_bits(const EVP_PKEY *);
 
@@ -163,6 +216,22 @@ EVP_PKEY *EVP_PKEY_new_raw_public_key(int, ENGINE *, const unsigned char *,
 int EVP_PKEY_get_raw_private_key(const EVP_PKEY *, unsigned char *, size_t *);
 int EVP_PKEY_get_raw_public_key(const EVP_PKEY *, unsigned char *, size_t *);
 
+int EVP_PKEY_get_group_name(const EVP_PKEY *, char *, size_t, size_t *);
+
+int EVP_PKEY_get_bn_param(const EVP_PKEY *, const char *, BIGNUM **);
+int EVP_PKEY_get_int_param(const EVP_PKEY *, const char *, int *);
+int EVP_PKEY_get_octet_string_param(const EVP_PKEY *, const char *,
+                                    unsigned char *, size_t, size_t *);
+
+int EVP_PKEY_set_bn_param(EVP_PKEY *, const char *, const BIGNUM *);
+int EVP_PKEY_set_octet_string_param(EVP_PKEY *, const char *,
+                                    const unsigned char *, size_t);
+int EVP_PKEY_set_utf8_string_param(EVP_PKEY *, const char *, const char *);
+
+int EVP_PKEY_todata(const EVP_PKEY *, int, OSSL_PARAM **);
+int EVP_PKEY_fromdata_init(EVP_PKEY_CTX *);
+int EVP_PKEY_fromdata(EVP_PKEY_CTX *, EVP_PKEY **, int, OSSL_PARAM[]);
+
 int EVP_default_properties_is_fips_enabled(OSSL_LIB_CTX *);
 int EVP_default_properties_enable_fips(OSSL_LIB_CTX *, int);
 """
@@ -265,7 +334,34 @@ static const long Cryptography_HAS_EVP_DIGESTFINAL_XOF = 1;
 #if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
 static const long Cryptography_HAS_300_FIPS = 1;
 static const long Cryptography_HAS_300_EVP_CIPHER = 1;
+
+#ifdef OPENSSL_NO_DEPRECATED_3_0
+int (*EVP_PKEY_assign_RSA)(EVP_PKEY *, RSA *) = NULL;
+RSA *(*EVP_PKEY_get1_RSA)(EVP_PKEY *) = NULL;
+DSA *(*EVP_PKEY_get1_DSA)(EVP_PKEY *) = NULL;
+DH *(*EVP_PKEY_get1_DH)(EVP_PKEY *) = NULL;
+EC_KEY *(*EVP_PKEY_get1_EC_KEY)(EVP_PKEY *) = NULL;
+int (*EVP_PKEY_set1_RSA)(EVP_PKEY *, RSA *) = NULL;
+int (*EVP_PKEY_set1_DSA)(EVP_PKEY *, DSA *) = NULL;
+int (*EVP_PKEY_set1_DH)(EVP_PKEY *, DH *) = NULL;
+int (*EVP_PKEY_set1_EC_KEY)(EVP_PKEY *, EC_KEY *) = NULL;
+size_t (*EVP_PKEY_get1_tls_encodedpoint)(EVP_PKEY *, unsigned char **) = NULL;
+int (*EVP_PKEY_set1_tls_encodedpoint)(EVP_PKEY *, const unsigned char *,
+                                   size_t) = NULL;
+int (*EVP_PKEY_cmp)(const EVP_PKEY *, const EVP_PKEY *) = NULL;
+#endif
+
 #else
+typedef void EVP_KEYMGMT;
+typedef void EVP_MAC;
+typedef void EVP_MAC_CTX;
+static const int EVP_PKEY_KEY_PARAMETERS = 0;
+static const int EVP_PKEY_PUBLIC_KEY = 0;
+static const int EVP_PKEY_KEYPAIR = 0;
+static const int OSSL_KEYMGMT_SELECT_PRIVATE_KEY = 0;
+static const int OSSL_KEYMGMT_SELECT_PUBLIC_KEY = 0;
+static const int OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS = 0;
+static const int OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS = 0;
 static const long Cryptography_HAS_300_FIPS = 0;
 static const long Cryptography_HAS_300_EVP_CIPHER = 0;
 int (*EVP_default_properties_is_fips_enabled)(OSSL_LIB_CTX *) = NULL;
@@ -273,6 +369,36 @@ int (*EVP_default_properties_enable_fips)(OSSL_LIB_CTX *, int) = NULL;
 EVP_CIPHER * (*EVP_CIPHER_fetch)(OSSL_LIB_CTX *, const char *,
                                  const char *) = NULL;
 void (*EVP_CIPHER_free)(EVP_CIPHER *) = NULL;
+EVP_MAC *(*EVP_MAC_fetch)(OSSL_LIB_CTX *, const char *, const char *) = NULL;
+void (*EVP_MAC_free)(EVP_MAC *) = NULL;
+EVP_MAC_CTX *(*EVP_MAC_CTX_new)(EVP_MAC *) = NULL;
+void (*EVP_MAC_CTX_free)(EVP_MAC_CTX *) = NULL;
+EVP_MAC_CTX *(*EVP_MAC_CTX_dup)(const EVP_MAC_CTX *) = NULL;
+int (*EVP_MAC_init)(EVP_MAC_CTX *, const unsigned char *, size_t, const OSSL_PARAM[]) = NULL;
+int (*EVP_MAC_update)(EVP_MAC_CTX *, const unsigned char *, size_t) = NULL;
+int (*EVP_MAC_final)(EVP_MAC_CTX *, unsigned char *, size_t *, size_t) = NULL;
+
+EVP_KEYMGMT *(*EVP_KEYMGMT_fetch)(OSSL_LIB_CTX *, const char *, const char *) = NULL;
+void (*EVP_KEYMGMT_free)(EVP_KEYMGMT *) = NULL;
+int (*EVP_PKEY_is_a)(const EVP_PKEY *, const char *) = NULL;
+int (*EVP_PKEY_get_group_name)(const EVP_PKEY *, char *, size_t, size_t *) = NULL;
+int (*EVP_PKEY_set_type_by_keymgmt)(EVP_PKEY *, EVP_KEYMGMT *) = NULL;
+EVP_PKEY *(*EVP_PKEY_Q_keygen)(OSSL_LIB_CTX *, const char *, const char *, ...) = NULL;
+int (*EVP_PKEY_get_bn_param)(const EVP_PKEY *, const char *, BIGNUM **) = NULL;
+int (*EVP_PKEY_get_int_param)(const EVP_PKEY *, const char *, int *) = NULL;
+int (*EVP_PKEY_get_octet_string_param)(const EVP_PKEY *, const char *,
+                                    unsigned char *, size_t, size_t *) = NULL;
+int (*EVP_PKEY_set_bn_param)(EVP_PKEY *, const char *, const BIGNUM *) = NULL;
+int (*EVP_PKEY_set_octet_string_param)(EVP_PKEY *, const char *,
+                                    const unsigned char *, size_t) = NULL;
+int (*EVP_PKEY_set_utf8_string_param)(EVP_PKEY *, const char *, const char *) = NULL;
+int (*EVP_PKEY_todata)(const EVP_PKEY *, int, OSSL_PARAM **) = NULL;
+int (*EVP_PKEY_fromdata_init)(EVP_PKEY_CTX *) = NULL;
+int (*EVP_PKEY_fromdata)(EVP_PKEY_CTX *, EVP_PKEY **, int, OSSL_PARAM[]) = NULL;
+size_t (*EVP_PKEY_get1_encoded_public_key)(EVP_PKEY *, unsigned char **) = EVP_PKEY_get1_tls_encodedpoint;
+int (*EVP_PKEY_set1_encoded_public_key)(EVP_PKEY *, const unsigned char *,
+                                   size_t) = EVP_PKEY_set1_tls_encodedpoint;
+int (*EVP_PKEY_eq)(const EVP_PKEY *, const EVP_PKEY *) = EVP_PKEY_cmp;
 #endif
 
 #if CRYPTOGRAPHY_IS_BORINGSSL
diff --git a/src/_cffi_src/openssl/hmac.py b/src/_cffi_src/openssl/hmac.py
index 8b1915361..8abe03e1a 100644
--- a/src/_cffi_src/openssl/hmac.py
+++ b/src/_cffi_src/openssl/hmac.py
@@ -22,4 +22,13 @@ void HMAC_CTX_free(HMAC_CTX *ctx);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+int (*HMAC_Init_ex)(HMAC_CTX *, const void *, int, const EVP_MD *, ENGINE *) = NULL;
+int (*HMAC_Update)(HMAC_CTX *, const unsigned char *, size_t) = NULL;
+int (*HMAC_Final)(HMAC_CTX *, unsigned char *, unsigned int *) = NULL;
+int (*HMAC_CTX_copy)(HMAC_CTX *, HMAC_CTX *) = NULL;
+
+HMAC_CTX *(*HMAC_CTX_new)(void) = NULL;
+void (*HMAC_CTX_free)(HMAC_CTX *ctx) = NULL;
+#endif
 """
diff --git a/src/_cffi_src/openssl/params.py b/src/_cffi_src/openssl/params.py
new file mode 100644
index 000000000..b1eff16c7
--- /dev/null
+++ b/src/_cffi_src/openssl/params.py
@@ -0,0 +1,48 @@
+# This file is dual licensed under the terms of the Apache License, Version
+# 2.0, and the BSD License. See the LICENSE file in the root of this repository
+# for complete details.
+
+
+INCLUDES = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+#include <openssl/core.h>
+#include <openssl/params.h>
+#include <openssl/param_build.h>
+#endif
+"""
+
+TYPES = """
+typedef ... OSSL_PARAM;
+typedef ... OSSL_PARAM_BLD;
+"""
+
+FUNCTIONS = """
+OSSL_PARAM_BLD *OSSL_PARAM_BLD_new(void);
+void OSSL_PARAM_BLD_free(OSSL_PARAM_BLD *);
+
+int OSSL_PARAM_BLD_push_BN(OSSL_PARAM_BLD *, const char *, const BIGNUM *);
+int OSSL_PARAM_BLD_push_utf8_string(OSSL_PARAM_BLD *, const char *, const char *, size_t);
+int OSSL_PARAM_BLD_push_octet_string(OSSL_PARAM_BLD *, const char *, const void *, size_t);
+
+OSSL_PARAM *OSSL_PARAM_BLD_to_param(OSSL_PARAM_BLD *);
+
+void OSSL_PARAM_free(OSSL_PARAM *);
+"""
+
+CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+#else
+typedef void OSSL_PARAM;
+typedef void OSSL_PARAM_BLD;
+OSSL_PARAM_BLD *(*OSSL_PARAM_BLD_new)(void) = NULL;
+void (*OSSL_PARAM_BLD_free)(OSSL_PARAM_BLD *) = NULL;
+
+int (*OSSL_PARAM_BLD_push_BN)(OSSL_PARAM_BLD *, const char *, const BIGNUM *) = NULL;
+int (*OSSL_PARAM_BLD_push_utf8_string)(OSSL_PARAM_BLD *, const char *, const char *, size_t) = NULL;
+int (*OSSL_PARAM_BLD_push_octet_string)(OSSL_PARAM_BLD *, const char *, const void *, size_t) = NULL;
+
+OSSL_PARAM *(*OSSL_PARAM_BLD_to_param)(OSSL_PARAM_BLD *) = NULL;
+
+void (*OSSL_PARAM_free)(OSSL_PARAM *) = NULL;
+#endif
+"""
diff --git a/src/_cffi_src/openssl/pem.py b/src/_cffi_src/openssl/pem.py
index 2ebcdf6b0..276af4df5 100644
--- a/src/_cffi_src/openssl/pem.py
+++ b/src/_cffi_src/openssl/pem.py
@@ -58,6 +58,8 @@ RSA *PEM_read_bio_RSAPublicKey(BIO *, RSA **, pem_password_cb *, void *);
 
 int PEM_write_bio_RSAPublicKey(BIO *, const RSA *);
 
+EVP_PKEY *PEM_read_bio_Parameters(BIO *, EVP_PKEY **);
+
 EVP_PKEY *PEM_read_bio_PUBKEY(BIO *, EVP_PKEY **, pem_password_cb *, void *);
 int PEM_write_bio_PUBKEY(BIO *, EVP_PKEY *);
 int PEM_write_bio_ECPrivateKey(BIO *, EC_KEY *, const EVP_CIPHER *,
@@ -68,7 +70,29 @@ int PEM_write_bio_DHxparams(BIO *, DH *);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+DH *(*PEM_read_bio_DHparams)(BIO *, DH **, pem_password_cb *, void *) = NULL;
+
+int (*PEM_write_bio_DSAPrivateKey)(BIO *, DSA *, const EVP_CIPHER *,
+                                unsigned char *, int,
+                                pem_password_cb *, void *) = NULL;
+
+int (*PEM_write_bio_RSAPrivateKey)(BIO *, RSA *, const EVP_CIPHER *,
+                                unsigned char *, int,
+                                pem_password_cb *, void *) = NULL;
+
+RSA *(*PEM_read_bio_RSAPublicKey)(BIO *, RSA **, pem_password_cb *, void *) = NULL;
+
+int (*PEM_write_bio_RSAPublicKey)(BIO *, const RSA *) = NULL;
+
+int (*PEM_write_bio_ECPrivateKey)(BIO *, EC_KEY *, const EVP_CIPHER *,
+                               unsigned char *, int, pem_password_cb *,
+                               void *) = NULL;
+int (*PEM_write_bio_DHparams)(BIO *, DH *) = NULL;
+int (*PEM_write_bio_DHxparams)(BIO *, DH *) = NULL;
+#else
 #if !defined(EVP_PKEY_DHX) || EVP_PKEY_DHX == -1
 int (*PEM_write_bio_DHxparams)(BIO *, DH *) = NULL;
 #endif
+#endif
 """
diff --git a/src/_cffi_src/openssl/rand.py b/src/_cffi_src/openssl/rand.py
index 9e95fe792..07f882b30 100644
--- a/src/_cffi_src/openssl/rand.py
+++ b/src/_cffi_src/openssl/rand.py
@@ -19,4 +19,7 @@ int RAND_bytes(unsigned char *, int);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+int (*RAND_set_rand_method)(const RAND_METHOD *) = NULL;
+#endif
 """
diff --git a/src/_cffi_src/openssl/rsa.py b/src/_cffi_src/openssl/rsa.py
index 3492d4588..efd18bfa1 100644
--- a/src/_cffi_src/openssl/rsa.py
+++ b/src/_cffi_src/openssl/rsa.py
@@ -43,9 +43,33 @@ int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *, EVP_MD *);
 int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *, unsigned char *, int);
 
 int EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX *, EVP_MD *);
+
+int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int bits);
+int EVP_PKEY_CTX_set1_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx, BIGNUM *pubexp);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+typedef void RSA;
+
+RSA *(*RSA_new)(void) = NULL;
+void (*RSA_free)(RSA *) = NULL;
+int (*RSA_generate_key_ex)(RSA *, int, BIGNUM *, BN_GENCB *) = NULL;
+int (*RSA_check_key)(const RSA *) = NULL;
+RSA *(*RSAPublicKey_dup)(RSA *) = NULL;
+int (*RSA_blinding_on)(RSA *, BN_CTX *) = NULL;
+int (*RSA_print)(BIO *, const RSA *, int) = NULL;
+
+int (*RSA_set0_key)(RSA *, BIGNUM *, BIGNUM *, BIGNUM *) = NULL;
+int (*RSA_set0_factors)(RSA *, BIGNUM *, BIGNUM *) = NULL;
+int (*RSA_set0_crt_params)(RSA *, BIGNUM *, BIGNUM *, BIGNUM *) = NULL;
+void (*RSA_get0_key)(const RSA *, const BIGNUM **, const BIGNUM **,
+                  const BIGNUM **) = NULL;
+void (*RSA_get0_factors)(const RSA *, const BIGNUM **, const BIGNUM **) = NULL;
+void (*RSA_get0_crt_params)(const RSA *, const BIGNUM **, const BIGNUM **,
+                         const BIGNUM **) = NULL;
+#endif
+
 // BoringSSL doesn't define this constant, but the value is used for
 // automatic salt length computation as in OpenSSL and LibreSSL
 #if !defined(RSA_PSS_SALTLEN_AUTO)
diff --git a/src/_cffi_src/openssl/ssl.py b/src/_cffi_src/openssl/ssl.py
index a9be15341..86a556af1 100644
--- a/src/_cffi_src/openssl/ssl.py
+++ b/src/_cffi_src/openssl/ssl.py
@@ -183,6 +183,7 @@ int SSL_read(SSL *, void *, int);
 int SSL_peek(SSL *, void *, int);
 X509 *SSL_get_certificate(const SSL *);
 X509 *SSL_get_peer_certificate(const SSL *);
+X509 *SSL_get1_peer_certificate(const SSL *);
 int SSL_get_ex_data_X509_STORE_CTX_idx(void);
 void SSL_set_verify(SSL *, int, int (*)(int, X509_STORE_CTX *));
 int SSL_get_verify_mode(const SSL *);
@@ -367,6 +368,11 @@ long SSL_CTX_get_max_proto_version(SSL_CTX *);
 long SSL_get_min_proto_version(SSL *);
 long SSL_get_max_proto_version(SSL *);
 
+int SSL_CTX_get_security_level(const SSL_CTX *);
+void SSL_CTX_set_security_level(SSL_CTX *, int);
+int SSL_get_security_level(const SSL *);
+void SSL_set_security_level(SSL *, int);
+
 /* Defined as unsigned long because SSL_OP_ALL is greater than signed 32-bit
    and Windows defines long as 32-bit. */
 unsigned long SSL_CTX_set_options(SSL_CTX *, unsigned long);
@@ -380,6 +386,8 @@ unsigned long SSL_CTX_get_session_cache_mode(SSL_CTX *);
 unsigned long SSL_CTX_set_tmp_dh(SSL_CTX *, DH *);
 unsigned long SSL_CTX_set_tmp_ecdh(SSL_CTX *, EC_KEY *);
 unsigned long SSL_CTX_add_extra_chain_cert(SSL_CTX *, X509 *);
+int SSL_CTX_set0_tmp_dh_pkey(SSL_CTX *, EVP_PKEY *);
+int SSL_CTX_set1_curves(SSL_CTX *, int *, int);
 
 const SSL_METHOD *DTLS_method(void);
 const SSL_METHOD *DTLS_server_method(void);
@@ -779,4 +787,15 @@ SSL_SESSION *Cryptography_SSL_SESSION_new(void) {
     return SSL_SESSION_new();
 }
 #endif
+
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+#ifdef OPENSSL_NO_DEPRECATED_3_0
+unsigned long (*SSL_CTX_set_tmp_dh)(SSL_CTX *, DH *) = NULL;
+unsigned long (*SSL_CTX_set_tmp_ecdh)(SSL_CTX *, EC_KEY *) = NULL;
+X509 *(*SSL_get_peer_certificate)(const SSL *) = NULL;
+#endif
+#else
+int (*SSL_CTX_set0_tmp_dh_pkey)(SSL_CTX *, EVP_PKEY *) = NULL;
+X509 *SSL_get1_peer_certificate(const SSL *) = SSL_get_peer_certificate;
+#endif
 """
diff --git a/src/_cffi_src/openssl/x509.py b/src/_cffi_src/openssl/x509.py
index 5b06ad772..65bb92397 100644
--- a/src/_cffi_src/openssl/x509.py
+++ b/src/_cffi_src/openssl/x509.py
@@ -220,4 +220,14 @@ const ASN1_TIME *X509_REVOKED_get0_revocationDate(const X509_REVOKED *);
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER && defined(OPENSSL_NO_DEPRECATED_3_0)
+int (*i2d_RSAPrivateKey_bio)(BIO *, RSA *) = NULL;
+RSA *(*d2i_RSAPublicKey_bio)(BIO *, RSA **) = NULL;
+int (*i2d_RSAPublicKey_bio)(BIO *, RSA *) = NULL;
+int (*i2d_DSAPrivateKey_bio)(BIO *, DSA *) = NULL;
+EC_KEY *(*d2i_EC_PUBKEY_bio)(BIO *, EC_KEY **) = NULL;
+int (*i2d_EC_PUBKEY_bio)(BIO *, EC_KEY *) = NULL;
+EC_KEY *(*d2i_ECPrivateKey_bio)(BIO *, EC_KEY **) = NULL;
+int (*i2d_ECPrivateKey_bio)(BIO *, EC_KEY *) = NULL;
+#endif
 """
diff --git a/src/_cffi_src/openssl/x509name.py b/src/_cffi_src/openssl/x509name.py
index 6fdc2a3c1..7b4656a16 100644
--- a/src/_cffi_src/openssl/x509name.py
+++ b/src/_cffi_src/openssl/x509name.py
@@ -25,6 +25,8 @@ X509_NAME *X509_NAME_new(void);
 void X509_NAME_free(X509_NAME *);
 
 unsigned long X509_NAME_hash(X509_NAME *);
+unsigned long X509_NAME_hash_ex(X509_NAME *, OSSL_LIB_CTX *, const char *,
+                                int *);
 
 int i2d_X509_NAME(X509_NAME *, unsigned char **);
 X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *, int);
@@ -58,4 +60,15 @@ int sk_X509_NAME_ENTRY_push(Cryptography_STACK_OF_X509_NAME_ENTRY *,
 """
 
 CUSTOMIZATIONS = """
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+#ifdef OPENSSL_NO_DEPRECATED_3_0
+unsigned long (*X509_NAME_hash)(X509_NAME *) = NULL;
+#endif
+#else
+unsigned long X509_NAME_hash_ex(X509_NAME *x, OSSL_LIB_CTX *libctx,
+                                const char *propq, int *ok)
+{
+    return X509_NAME_hash(x);
+}
+#endif
 """
diff --git a/src/cryptography/hazmat/backends/openssl/backend.py b/src/cryptography/hazmat/backends/openssl/backend.py
index 48f4265b0..5ccd82785 100644
--- a/src/cryptography/hazmat/backends/openssl/backend.py
+++ b/src/cryptography/hazmat/backends/openssl/backend.py
@@ -525,22 +525,33 @@ class Backend:
     ) -> rsa.RSAPrivateKey:
         rsa._verify_rsa_parameters(public_exponent, key_size)
 
-        rsa_cdata = self._lib.RSA_new()
-        self.openssl_assert(rsa_cdata != self._ffi.NULL)
-        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
-
         bn = self._int_to_bn(public_exponent)
         bn = self._ffi.gc(bn, self._lib.BN_free)
 
-        res = self._lib.RSA_generate_key_ex(
-            rsa_cdata, key_size, bn, self._ffi.NULL
+        evp_pkey_ctx = self._lib.EVP_PKEY_CTX_new_id(
+            self._lib.EVP_PKEY_RSA, self._ffi.NULL
+        )
+        self.openssl_assert(evp_pkey_ctx != self._ffi.NULL)
+        evp_pkey_ctx = self._ffi.gc(evp_pkey_ctx, self._lib.EVP_PKEY_CTX_free)
+        res = self._lib.EVP_PKEY_keygen_init(evp_pkey_ctx)
+        self.openssl_assert(res == 1)
+        res = self._lib.EVP_PKEY_CTX_set_rsa_keygen_bits(
+            evp_pkey_ctx, key_size
+        )
+        self.openssl_assert(res == 1)
+        res = self._lib.EVP_PKEY_CTX_set1_rsa_keygen_pubexp(
+            evp_pkey_ctx, bn
         )
         self.openssl_assert(res == 1)
-        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+        evp_ppkey = self._ffi.new("EVP_PKEY **")
+        res = self._lib.EVP_PKEY_keygen(evp_pkey_ctx, evp_ppkey)
+        self.openssl_assert(res == 1)
+        self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
 
         # We can skip RSA key validation here since we just generated the key
         return _RSAPrivateKey(
-            self, rsa_cdata, evp_pkey, unsafe_skip_rsa_key_validation=True
+            self, evp_pkey, unsafe_skip_rsa_key_validation=True
         )
 
     def generate_rsa_parameters_supported(
@@ -567,9 +578,6 @@ class Backend:
             numbers.public_numbers.e,
             numbers.public_numbers.n,
         )
-        rsa_cdata = self._lib.RSA_new()
-        self.openssl_assert(rsa_cdata != self._ffi.NULL)
-        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
         p = self._int_to_bn(numbers.p)
         q = self._int_to_bn(numbers.q)
         d = self._int_to_bn(numbers.d)
@@ -578,17 +586,68 @@ class Backend:
         iqmp = self._int_to_bn(numbers.iqmp)
         e = self._int_to_bn(numbers.public_numbers.e)
         n = self._int_to_bn(numbers.public_numbers.n)
-        res = self._lib.RSA_set0_factors(rsa_cdata, p, q)
-        self.openssl_assert(res == 1)
-        res = self._lib.RSA_set0_key(rsa_cdata, n, e, d)
-        self.openssl_assert(res == 1)
-        res = self._lib.RSA_set0_crt_params(rsa_cdata, dmp1, dmq1, iqmp)
-        self.openssl_assert(res == 1)
-        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            q = self._ffi.gc(q, self._lib.BN_free)
+            d = self._ffi.gc(d, self._lib.BN_free)
+            dmp1 = self._ffi.gc(dmp1, self._lib.BN_free)
+            dmq1 = self._ffi.gc(dmq1, self._lib.BN_free)
+            iqmp = self._ffi.gc(iqmp, self._lib.BN_free)
+            e = self._ffi.gc(e, self._lib.BN_free)
+            n = self._ffi.gc(n, self._lib.BN_free)
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"n", n),
+                (b"e", e),
+                (b"d", d),
+                (b"rsa-factor1", p),
+                (b"rsa-factor2", q),
+                (b"rsa-exponent1", dmp1),
+                (b"rsa-exponent2", dmq1),
+                (b"rsa-coefficient1", iqmp),
+            ]:
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
+
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_RSA, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEYPAIR, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            rsa_cdata = self._lib.RSA_new()
+            self.openssl_assert(rsa_cdata != self._ffi.NULL)
+            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+            res = self._lib.RSA_set0_factors(rsa_cdata, p, q)
+            self.openssl_assert(res == 1)
+            res = self._lib.RSA_set0_key(rsa_cdata, n, e, d)
+            self.openssl_assert(res == 1)
+            res = self._lib.RSA_set0_crt_params(rsa_cdata, dmp1, dmq1, iqmp)
+            self.openssl_assert(res == 1)
+            evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
 
         return _RSAPrivateKey(
             self,
-            rsa_cdata,
             evp_pkey,
             unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,
         )
@@ -597,16 +656,54 @@ class Backend:
         self, numbers: rsa.RSAPublicNumbers
     ) -> rsa.RSAPublicKey:
         rsa._check_public_key_components(numbers.e, numbers.n)
-        rsa_cdata = self._lib.RSA_new()
-        self.openssl_assert(rsa_cdata != self._ffi.NULL)
-        rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+
         e = self._int_to_bn(numbers.e)
         n = self._int_to_bn(numbers.n)
-        res = self._lib.RSA_set0_key(rsa_cdata, n, e, self._ffi.NULL)
-        self.openssl_assert(res == 1)
-        evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
 
-        return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            e = self._ffi.gc(e, self._lib.BN_free)
+            n = self._ffi.gc(n, self._lib.BN_free)
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"n", n),
+                (b"e", e),
+            ]:
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
+
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_RSA, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_PUBLIC_KEY, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            rsa_cdata = self._lib.RSA_new()
+            self.openssl_assert(rsa_cdata != self._ffi.NULL)
+            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+            res = self._lib.RSA_set0_key(rsa_cdata, n, e, self._ffi.NULL)
+            self.openssl_assert(res == 1)
+            evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+
+        return _RSAPublicKey(self, evp_pkey)
 
     def _create_evp_pkey_gc(self):
         evp_pkey = self._lib.EVP_PKEY_new()
@@ -615,6 +712,7 @@ class Backend:
         return evp_pkey
 
     def _rsa_cdata_to_evp_pkey(self, rsa_cdata):
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
         evp_pkey = self._create_evp_pkey_gc()
         res = self._lib.EVP_PKEY_set1_RSA(evp_pkey, rsa_cdata)
         self.openssl_assert(res == 1)
@@ -655,6 +753,35 @@ class Backend:
         bio_data = self._ffi.buffer(buf[0], buf_len)[:]
         return bio_data
 
+    def _key_type_from_pkey(self, evp_pkey):
+        """Extract the key type from an EVP_PKEY"""
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            if self._lib.EVP_PKEY_is_a(evp_pkey, b"RSA-PSS"):
+                key_type = self._lib.EVP_PKEY_RSA_PSS
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"RSA"):
+                key_type = self._lib.EVP_PKEY_RSA
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"DSA"):
+                key_type = self._lib.EVP_PKEY_DSA
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"EC"):
+                key_type = self._lib.EVP_PKEY_EC
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"ED25519"):
+                key_type = self._lib.EVP_PKEY_ED25519
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"ED448"):
+                key_type = self._lib.EVP_PKEY_ED448
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"X448"):
+                key_type = self._lib.EVP_PKEY_X448
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"X25519"):
+                key_type = self._lib.EVP_PKEY_X25519
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"DH"):
+                key_type = self._lib.EVP_PKEY_DH
+            elif self._lib.EVP_PKEY_is_a(evp_pkey, b"DHX"):
+                key_type = self._lib.EVP_PKEY_DHX
+            else:
+                key_type = self._lib.EVP_PKEY_NONE
+        else:
+            key_type = self._lib.EVP_PKEY_id(evp_pkey)
+        return key_type
+
     def _evp_pkey_to_private_key(
         self, evp_pkey, unsafe_skip_rsa_key_validation: bool
     ) -> PRIVATE_KEY_TYPES:
@@ -663,15 +790,11 @@ class Backend:
         pointer.
         """
 
-        key_type = self._lib.EVP_PKEY_id(evp_pkey)
+        key_type = self._key_type_from_pkey(evp_pkey)
 
         if key_type == self._lib.EVP_PKEY_RSA:
-            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
-            self.openssl_assert(rsa_cdata != self._ffi.NULL)
-            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
             return _RSAPrivateKey(
                 self,
-                rsa_cdata,
                 evp_pkey,
                 unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,
             )
@@ -685,32 +808,37 @@ class Backend:
             # PSS constraints from them and treat them as normal RSA keys
             # Unfortunately the RSA * itself tracks this data so we need to
             # extract, serialize, and reload it without the constraints.
-            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
-            self.openssl_assert(rsa_cdata != self._ffi.NULL)
-            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
             bio = self._create_mem_bio_gc()
-            res = self._lib.i2d_RSAPrivateKey_bio(bio, rsa_cdata)
-            self.openssl_assert(res == 1)
+            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                ctx = self._lib.OSSL_ENCODER_CTX_new_for_pkey(
+                    evp_pkey,
+                    self._lib.EVP_PKEY_KEYPAIR,
+                    b"DER",
+                    b"pkcs1",
+                    self._ffi.NULL
+                )
+                self.openssl_assert(ctx != self._ffi.NULL)
+                ctx = self._ffi.gc(ctx, self._lib.OSSL_ENCODER_CTX_free)
+                res = self._lib.OSSL_ENCODER_to_bio(ctx, bio)
+                self.openssl_assert(res == 1)
+            else:
+                rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
+                self.openssl_assert(rsa_cdata != self._ffi.NULL)
+                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+                res = self._lib.i2d_RSAPrivateKey_bio(bio, rsa_cdata)
+                self.openssl_assert(res == 1)
+
             return self.load_der_private_key(
                 self._read_mem_bio(bio),
                 password=None,
                 unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,
             )
         elif key_type == self._lib.EVP_PKEY_DSA:
-            dsa_cdata = self._lib.EVP_PKEY_get1_DSA(evp_pkey)
-            self.openssl_assert(dsa_cdata != self._ffi.NULL)
-            dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
-            return _DSAPrivateKey(self, dsa_cdata, evp_pkey)
+            return _DSAPrivateKey(self, evp_pkey)
         elif key_type == self._lib.EVP_PKEY_EC:
-            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)
-            self.openssl_assert(ec_cdata != self._ffi.NULL)
-            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
-            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)
+            return _EllipticCurvePrivateKey(self, evp_pkey)
         elif key_type in self._dh_types:
-            dh_cdata = self._lib.EVP_PKEY_get1_DH(evp_pkey)
-            self.openssl_assert(dh_cdata != self._ffi.NULL)
-            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-            return _DHPrivateKey(self, dh_cdata, evp_pkey)
+            return _DHPrivateKey(self, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_ED25519", None):
             # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _Ed25519PrivateKey(self, evp_pkey)
@@ -731,43 +859,42 @@ class Backend:
         pointer.
         """
 
-        key_type = self._lib.EVP_PKEY_id(evp_pkey)
+        key_type = self._key_type_from_pkey(evp_pkey)
 
         if key_type == self._lib.EVP_PKEY_RSA:
-            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
-            self.openssl_assert(rsa_cdata != self._ffi.NULL)
-            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
-            return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+            return _RSAPublicKey(self, evp_pkey)
         elif (
             key_type == self._lib.EVP_PKEY_RSA_PSS
             and not self._lib.CRYPTOGRAPHY_IS_LIBRESSL
             and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL
             and not self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111E
         ):
-            rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
-            self.openssl_assert(rsa_cdata != self._ffi.NULL)
-            rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
             bio = self._create_mem_bio_gc()
-            res = self._lib.i2d_RSAPublicKey_bio(bio, rsa_cdata)
-            self.openssl_assert(res == 1)
+            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                ctx = self._lib.OSSL_ENCODER_CTX_new_for_pkey(
+                    evp_pkey,
+                    self._lib.EVP_PKEY_PUBLIC_KEY,
+                    b"DER",
+                    b"pkcs1",
+                    self._ffi.NULL
+                )
+                self.openssl_assert(ctx != self._ffi.NULL)
+                ctx = self._ffi.gc(ctx, self._lib.OSSL_ENCODER_CTX_free)
+                res = self._lib.OSSL_ENCODER_to_bio(ctx, bio)
+                self.openssl_assert(res == 1)
+            else:
+                rsa_cdata = self._lib.EVP_PKEY_get1_RSA(evp_pkey)
+                self.openssl_assert(rsa_cdata != self._ffi.NULL)
+                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+                res = self._lib.i2d_RSAPublicKey_bio(bio, rsa_cdata)
+                self.openssl_assert(res == 1)
             return self.load_der_public_key(self._read_mem_bio(bio))
         elif key_type == self._lib.EVP_PKEY_DSA:
-            dsa_cdata = self._lib.EVP_PKEY_get1_DSA(evp_pkey)
-            self.openssl_assert(dsa_cdata != self._ffi.NULL)
-            dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
-            return _DSAPublicKey(self, dsa_cdata, evp_pkey)
+            return _DSAPublicKey(self, evp_pkey)
         elif key_type == self._lib.EVP_PKEY_EC:
-            ec_cdata = self._lib.EVP_PKEY_get1_EC_KEY(evp_pkey)
-            if ec_cdata == self._ffi.NULL:
-                errors = self._consume_errors_with_text()
-                raise ValueError("Unable to load EC key", errors)
-            ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
-            return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)
+            return _EllipticCurvePublicKey(self, evp_pkey)
         elif key_type in self._dh_types:
-            dh_cdata = self._lib.EVP_PKEY_get1_DH(evp_pkey)
-            self.openssl_assert(dh_cdata != self._ffi.NULL)
-            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-            return _DHPublicKey(self, dh_cdata, evp_pkey)
+            return _DHPublicKey(self, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_ED25519", None):
             # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _Ed25519PublicKey(self, evp_pkey)
@@ -819,36 +946,42 @@ class Backend:
                 "Key size must be 1024, 2048, 3072, or 4096 bits."
             )
 
-        ctx = self._lib.DSA_new()
-        self.openssl_assert(ctx != self._ffi.NULL)
-        ctx = self._ffi.gc(ctx, self._lib.DSA_free)
-
-        res = self._lib.DSA_generate_parameters_ex(
-            ctx,
-            key_size,
-            self._ffi.NULL,
-            0,
-            self._ffi.NULL,
-            self._ffi.NULL,
-            self._ffi.NULL,
+        evp_pkey_ctx = self._lib.EVP_PKEY_CTX_new_id(
+            self._lib.EVP_PKEY_DSA, self._ffi.NULL
         )
-
+        self.openssl_assert(evp_pkey_ctx != self._ffi.NULL)
+        evp_pkey_ctx = self._ffi.gc(evp_pkey_ctx, self._lib.EVP_PKEY_CTX_free)
+        res = self._lib.EVP_PKEY_paramgen_init(evp_pkey_ctx)
         self.openssl_assert(res == 1)
+        res = self._lib.EVP_PKEY_CTX_set_dsa_paramgen_bits(
+            evp_pkey_ctx, key_size
+        )
+        self.openssl_assert(res == 1)
+        evp_ppkey = self._ffi.new("EVP_PKEY **")
+        res = self._lib.EVP_PKEY_paramgen(evp_pkey_ctx, evp_ppkey)
+        self.openssl_assert(res == 1)
+        self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
 
-        return _DSAParameters(self, ctx)
+        return _DSAParameters(self, evp_pkey)
 
     def generate_dsa_private_key(
         self, parameters: dsa.DSAParameters
     ) -> dsa.DSAPrivateKey:
-        ctx = self._lib.DSAparams_dup(
-            parameters._dsa_cdata  # type: ignore[attr-defined]
+        evp_pkey_ctx = self._lib.EVP_PKEY_CTX_new(
+            parameters._evp_pkey, self._ffi.NULL
         )
-        self.openssl_assert(ctx != self._ffi.NULL)
-        ctx = self._ffi.gc(ctx, self._lib.DSA_free)
-        self._lib.DSA_generate_key(ctx)
-        evp_pkey = self._dsa_cdata_to_evp_pkey(ctx)
+        self.openssl_assert(evp_pkey_ctx != self._ffi.NULL)
+        evp_pkey_ctx = self._ffi.gc(evp_pkey_ctx, self._lib.EVP_PKEY_CTX_free)
+        res = self._lib.EVP_PKEY_keygen_init(evp_pkey_ctx)
+        self.openssl_assert(res == 1)
+        evp_ppkey = self._ffi.new("EVP_PKEY **")
+        res = self._lib.EVP_PKEY_keygen(evp_pkey_ctx, evp_ppkey)
+        self.openssl_assert(res == 1)
+        self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
 
-        return _DSAPrivateKey(self, ctx, evp_pkey)
+        return _DSAPrivateKey(self, evp_pkey)
 
     def generate_dsa_private_key_and_parameters(
         self, key_size: int
@@ -857,6 +990,7 @@ class Backend:
         return self.generate_dsa_private_key(parameters)
 
     def _dsa_cdata_set_values(self, dsa_cdata, p, q, g, pub_key, priv_key):
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
         res = self._lib.DSA_set0_pqg(dsa_cdata, p, q, g)
         self.openssl_assert(res == 1)
         res = self._lib.DSA_set0_key(dsa_cdata, pub_key, priv_key)
@@ -868,57 +1002,179 @@ class Backend:
         dsa._check_dsa_private_numbers(numbers)
         parameter_numbers = numbers.public_numbers.parameter_numbers
 
-        dsa_cdata = self._lib.DSA_new()
-        self.openssl_assert(dsa_cdata != self._ffi.NULL)
-        dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
-
         p = self._int_to_bn(parameter_numbers.p)
         q = self._int_to_bn(parameter_numbers.q)
         g = self._int_to_bn(parameter_numbers.g)
         pub_key = self._int_to_bn(numbers.public_numbers.y)
         priv_key = self._int_to_bn(numbers.x)
-        self._dsa_cdata_set_values(dsa_cdata, p, q, g, pub_key, priv_key)
 
-        evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            q = self._ffi.gc(q, self._lib.BN_free)
+            g = self._ffi.gc(g, self._lib.BN_free)
+            pub_key = self._ffi.gc(pub_key, self._lib.BN_free)
+            priv_key = self._ffi.gc(priv_key, self._lib.BN_free)
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"p", p),
+                (b"q", q),
+                (b"g", g),
+                (b"pub", pub_key),
+                (b"priv", priv_key),
+            ]:
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
 
-        return _DSAPrivateKey(self, dsa_cdata, evp_pkey)
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_DSA, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEYPAIR, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            dsa_cdata = self._lib.DSA_new()
+            self.openssl_assert(dsa_cdata != self._ffi.NULL)
+            dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+            self._dsa_cdata_set_values(dsa_cdata, p, q, g, pub_key, priv_key)
+            evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)
+
+        return _DSAPrivateKey(self, evp_pkey)
 
     def load_dsa_public_numbers(
         self, numbers: dsa.DSAPublicNumbers
     ) -> dsa.DSAPublicKey:
         dsa._check_dsa_parameters(numbers.parameter_numbers)
-        dsa_cdata = self._lib.DSA_new()
-        self.openssl_assert(dsa_cdata != self._ffi.NULL)
-        dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
 
         p = self._int_to_bn(numbers.parameter_numbers.p)
         q = self._int_to_bn(numbers.parameter_numbers.q)
         g = self._int_to_bn(numbers.parameter_numbers.g)
         pub_key = self._int_to_bn(numbers.y)
-        priv_key = self._ffi.NULL
-        self._dsa_cdata_set_values(dsa_cdata, p, q, g, pub_key, priv_key)
 
-        evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            q = self._ffi.gc(q, self._lib.BN_free)
+            g = self._ffi.gc(g, self._lib.BN_free)
+            pub_key = self._ffi.gc(pub_key, self._lib.BN_free)
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"p", p),
+                (b"q", q),
+                (b"g", g),
+                (b"pub", pub_key),
+            ]:
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
+
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_DSA, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_PUBLIC_KEY, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            dsa_cdata = self._lib.DSA_new()
+            self.openssl_assert(dsa_cdata != self._ffi.NULL)
+            dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+            priv_key = self._ffi.NULL
+            self._dsa_cdata_set_values(dsa_cdata, p, q, g, pub_key, priv_key)
+            evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)
 
-        return _DSAPublicKey(self, dsa_cdata, evp_pkey)
+        return _DSAPublicKey(self, evp_pkey)
 
     def load_dsa_parameter_numbers(
         self, numbers: dsa.DSAParameterNumbers
     ) -> dsa.DSAParameters:
         dsa._check_dsa_parameters(numbers)
-        dsa_cdata = self._lib.DSA_new()
-        self.openssl_assert(dsa_cdata != self._ffi.NULL)
-        dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
 
         p = self._int_to_bn(numbers.p)
         q = self._int_to_bn(numbers.q)
         g = self._int_to_bn(numbers.g)
-        res = self._lib.DSA_set0_pqg(dsa_cdata, p, q, g)
-        self.openssl_assert(res == 1)
 
-        return _DSAParameters(self, dsa_cdata)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            q = self._ffi.gc(q, self._lib.BN_free)
+            g = self._ffi.gc(g, self._lib.BN_free)
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"p", p),
+                (b"q", q),
+                (b"g", g),
+            ]:
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
+
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_DSA, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEY_PARAMETERS, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            dsa_cdata = self._lib.DSA_new()
+            self.openssl_assert(dsa_cdata != self._ffi.NULL)
+            dsa_cdata = self._ffi.gc(dsa_cdata, self._lib.DSA_free)
+            res = self._lib.DSA_set0_pqg(dsa_cdata, p, q, g)
+            self.openssl_assert(res == 1)
+            evp_pkey = self._dsa_cdata_to_evp_pkey(dsa_cdata)
+
+        return _DSAParameters(self, evp_pkey)
 
     def _dsa_cdata_to_evp_pkey(self, dsa_cdata):
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
         evp_pkey = self._create_evp_pkey_gc()
         res = self._lib.EVP_PKEY_set1_DSA(evp_pkey, dsa_cdata)
         self.openssl_assert(res == 1)
@@ -980,32 +1236,76 @@ class Backend:
             self._consume_errors()
             res = self._lib.BIO_reset(mem_bio.bio)
             self.openssl_assert(res == 1)
-            rsa_cdata = self._lib.PEM_read_bio_RSAPublicKey(
-                mem_bio.bio,
-                self._ffi.NULL,
-                self._ffi.addressof(
-                    self._lib._original_lib, "Cryptography_pem_password_cb"
-                ),
-                userdata,
-            )
-            if rsa_cdata != self._ffi.NULL:
-                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
-                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
-                return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+
+            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                ppkey = self._ffi.new("EVP_PKEY **")
+                ctx = self._lib.OSSL_DECODER_CTX_new_for_pkey(
+                    ppkey, b"PEM", b"pkcs1", b"RSA",
+                    self._lib.EVP_PKEY_PUBLIC_KEY, self._ffi.NULL,
+                    self._ffi.NULL
+                )
+                self.openssl_assert(ctx != self._ffi.NULL)
+                res = self._lib.OSSL_DECODER_from_bio(ctx, mem_bio.bio)
+                if res == 1:
+                    evp_pkey = self._ffi.gc(ppkey[0], self._lib.EVP_PKEY_free)
+                    return _RSAPublicKey(self, evp_pkey)
+                else:
+                    self._handle_key_loading_error()
             else:
-                self._handle_key_loading_error()
+                rsa_cdata = self._lib.PEM_read_bio_RSAPublicKey(
+                    mem_bio.bio,
+                    self._ffi.NULL,
+                    self._ffi.addressof(
+                        self._lib._original_lib, "Cryptography_pem_password_cb"
+                    ),
+                    userdata,
+                )
+                if rsa_cdata != self._ffi.NULL:
+                    rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+                    evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+                    return _RSAPublicKey(self, evp_pkey)
+                else:
+                    self._handle_key_loading_error()
 
     def load_pem_parameters(self, data: bytes) -> dh.DHParameters:
         mem_bio = self._bytes_to_bio(data)
-        # only DH is supported currently
-        dh_cdata = self._lib.PEM_read_bio_DHparams(
-            mem_bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
-        )
-        if dh_cdata != self._ffi.NULL:
-            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-            return _DHParameters(self, dh_cdata)
+
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            key_types = [b"DH"]
+            if self._lib.Cryptography_HAS_EVP_PKEY_DHX:
+                key_types.append(b"DHX")
+
+            for key_type in key_types:
+                self._consume_errors()
+                ppkey = self._ffi.new("EVP_PKEY **")
+                ctx = self._lib.OSSL_DECODER_CTX_new_for_pkey(
+                    ppkey,
+                    b"PEM",
+                    self._ffi.NULL,
+                    key_type,
+                    self._lib.OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,
+                    self._ffi.NULL,
+                    self._ffi.NULL
+                )
+                self.openssl_assert(ctx != self._ffi.NULL)
+                ctx = self._ffi.gc(ctx, self._lib.OSSL_DECODER_CTX_free)
+                res = self._lib.OSSL_DECODER_from_bio(ctx, mem_bio.bio)
+                if res == 1:
+                    evp_pkey = self._ffi.gc(ppkey[0], self._lib.EVP_PKEY_free)
+                    return _DHParameters(self, evp_pkey)
+                res = self._lib.BIO_reset(mem_bio.bio)
+                self.openssl_assert(res == 1)
         else:
-            self._handle_key_loading_error()
+            # only DH is supported currently
+            dh_cdata = self._lib.PEM_read_bio_DHparams(
+                mem_bio.bio, self._ffi.NULL, self._ffi.NULL, self._ffi.NULL
+            )
+            if dh_cdata != self._ffi.NULL:
+                dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
+                evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
+                return _DHParameters(self, evp_pkey)
+
+        self._handle_key_loading_error()
 
     def load_der_private_key(
         self,
@@ -1060,31 +1360,77 @@ class Backend:
             self._consume_errors()
             res = self._lib.BIO_reset(mem_bio.bio)
             self.openssl_assert(res == 1)
-            rsa_cdata = self._lib.d2i_RSAPublicKey_bio(
-                mem_bio.bio, self._ffi.NULL
-            )
-            if rsa_cdata != self._ffi.NULL:
-                rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
-                evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
-                return _RSAPublicKey(self, rsa_cdata, evp_pkey)
+
+            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                ppkey = self._ffi.new("EVP_PKEY **")
+                ctx = self._lib.OSSL_DECODER_CTX_new_for_pkey(
+                    ppkey, b"DER", b"pkcs1", b"RSA",
+                    self._lib.EVP_PKEY_PUBLIC_KEY, self._ffi.NULL,
+                    self._ffi.NULL
+                )
+                self.openssl_assert(ctx != self._ffi.NULL)
+                res = self._lib.OSSL_DECODER_from_bio(ctx, mem_bio.bio)
+                if res == 1:
+                    evp_pkey = self._ffi.gc(ppkey[0], self._lib.EVP_PKEY_free)
+                    return _RSAPublicKey(self, evp_pkey)
+                else:
+                    self._handle_key_loading_error()
             else:
-                self._handle_key_loading_error()
+                rsa_cdata = self._lib.d2i_RSAPublicKey_bio(
+                    mem_bio.bio, self._ffi.NULL
+                )
+                if rsa_cdata != self._ffi.NULL:
+                    rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
+                    evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
+                    return _RSAPublicKey(self, evp_pkey)
+                else:
+                    self._handle_key_loading_error()
 
     def load_der_parameters(self, data: bytes) -> dh.DHParameters:
         mem_bio = self._bytes_to_bio(data)
-        dh_cdata = self._lib.d2i_DHparams_bio(mem_bio.bio, self._ffi.NULL)
-        if dh_cdata != self._ffi.NULL:
-            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-            return _DHParameters(self, dh_cdata)
-        elif self._lib.Cryptography_HAS_EVP_PKEY_DHX:
-            # We check to see if the is dhx.
-            self._consume_errors()
-            res = self._lib.BIO_reset(mem_bio.bio)
-            self.openssl_assert(res == 1)
-            dh_cdata = self._lib.d2i_DHxparams_bio(mem_bio.bio, self._ffi.NULL)
+
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            key_types = [b"DH"]
+            if self._lib.Cryptography_HAS_EVP_PKEY_DHX:
+                key_types.append(b"DHX")
+
+            for key_type in key_types:
+                self._consume_errors()
+                ppkey = self._ffi.new("EVP_PKEY **")
+                ctx = self._lib.OSSL_DECODER_CTX_new_for_pkey(
+                    ppkey,
+                    b"DER",
+                    self._ffi.NULL,
+                    key_type,
+                    self._lib.OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,
+                    self._ffi.NULL,
+                    self._ffi.NULL
+                )
+                self.openssl_assert(ctx != self._ffi.NULL)
+                res = self._lib.OSSL_DECODER_from_bio(ctx, mem_bio.bio)
+                if res == 1:
+                    evp_pkey = self._ffi.gc(ppkey[0], self._lib.EVP_PKEY_free)
+                    return _DHParameters(self, evp_pkey)
+                res = self._lib.BIO_reset(mem_bio.bio)
+                self.openssl_assert(res == 1)
+        else:
+            dh_cdata = self._lib.d2i_DHparams_bio(mem_bio.bio, self._ffi.NULL)
             if dh_cdata != self._ffi.NULL:
                 dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-                return _DHParameters(self, dh_cdata)
+                evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
+                return _DHParameters(self, evp_pkey)
+            elif self._lib.Cryptography_HAS_EVP_PKEY_DHX:
+                # We check to see if the is dhx.
+                self._consume_errors()
+                res = self._lib.BIO_reset(mem_bio.bio)
+                self.openssl_assert(res == 1)
+                dh_cdata = self._lib.d2i_DHxparams_bio(
+                    mem_bio.bio, self._ffi.NULL
+                )
+                if dh_cdata != self._ffi.NULL:
+                    dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
+                    evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
+                    return _DHParameters(self, evp_pkey)
 
         self._handle_key_loading_error()
 
@@ -1160,7 +1506,7 @@ class Backend:
         return True
 
     def _check_keys_correspond(self, key1, key2):
-        if self._lib.EVP_PKEY_cmp(key1._evp_pkey, key2._evp_pkey) != 1:
+        if self._lib.EVP_PKEY_eq(key1._evp_pkey, key2._evp_pkey) != 1:
             raise ValueError("Keys do not correspond")
 
     def _load_key(
@@ -1297,14 +1643,21 @@ class Backend:
         """
 
         if self.elliptic_curve_supported(curve):
-            ec_cdata = self._ec_key_new_by_curve(curve)
-
-            res = self._lib.EC_KEY_generate_key(ec_cdata)
-            self.openssl_assert(res == 1)
-
-            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                curve_nid = self._elliptic_curve_to_nid(curve)
+                sn = self._lib.OBJ_nid2sn(curve_nid)
+                evp_pkey = self._lib.EVP_PKEY_Q_keygen(
+                    self._ffi.NULL, self._ffi.NULL, b"EC", sn
+                )
+                self.openssl_assert(evp_pkey != self._ffi.NULL)
+                evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
+            else:
+                ec_cdata = self._ec_key_new_by_curve(curve)
+                res = self._lib.EC_KEY_generate_key(ec_cdata)
+                self.openssl_assert(res == 1)
+                evp_pkey = self._ec_cdata_to_evp_pkey(ec_data)
 
-            return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)
+            return _EllipticCurvePrivateKey(self, evp_pkey)
         else:
             raise UnsupportedAlgorithm(
                 "Backend object does not support {}.".format(curve.name),
@@ -1316,67 +1669,219 @@ class Backend:
     ) -> ec.EllipticCurvePrivateKey:
         public = numbers.public_numbers
 
-        ec_cdata = self._ec_key_new_by_curve(public.curve)
-
         private_value = self._ffi.gc(
             self._int_to_bn(numbers.private_value), self._lib.BN_clear_free
         )
-        res = self._lib.EC_KEY_set_private_key(ec_cdata, private_value)
-        if res != 1:
-            self._consume_errors()
-            raise ValueError("Invalid EC key.")
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
 
-        self._ec_key_set_public_key_affine_coordinates(
-            ec_cdata, public.x, public.y
-        )
+            curve_nid = self._elliptic_curve_to_nid(public.curve)
+            sn = self._lib.OBJ_nid2sn(curve_nid)
+
+            res = self._lib.OSSL_PARAM_BLD_push_utf8_string(
+                bld, b"group", sn, 0
+            )
+            self.openssl_assert(res == 1)
+
+            point = self._ec_key_affine_coordinates_to_encoded_point(
+                public.curve, public.x, public.y
+            )
+            res = self._lib.OSSL_PARAM_BLD_push_octet_string(
+                bld, b"pub", point, len(point)
+            )
+            self.openssl_assert(res == 1)
+
+            res = self._lib.OSSL_PARAM_BLD_push_BN(bld, b"priv", private_value)
+            self.openssl_assert(res == 1)
 
-        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
 
-        return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_EC, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEYPAIR, params
+            )
+            if res != 1:
+                self._consume_errors()
+                raise ValueError("Invalid EC key.")
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+
+            check_ctx = self._lib.EVP_PKEY_CTX_new(evp_pkey, self._ffi.NULL)
+            self.openssl_assert(check_ctx != self._ffi.NULL)
+            check_ctx = self._ffi.gc(check_ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_check(check_ctx)
+            if res != 1:
+                self._consume_errors()
+                raise ValueError("Invalid EC key.")
+        else:
+            ec_cdata = self._ec_key_new_by_curve(public.curve)
+            res = self._lib.EC_KEY_set_private_key(ec_cdata, private_value)
+            if res != 1:
+                self._consume_errors()
+                raise ValueError("Invalid EC key.")
+            self._ec_key_set_public_key_affine_coordinates(
+                ec_cdata, public.x, public.y
+            )
+            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+
+        return _EllipticCurvePrivateKey(self, evp_pkey)
 
     def load_elliptic_curve_public_numbers(
         self, numbers: ec.EllipticCurvePublicNumbers
     ) -> ec.EllipticCurvePublicKey:
-        ec_cdata = self._ec_key_new_by_curve(numbers.curve)
-        self._ec_key_set_public_key_affine_coordinates(
-            ec_cdata, numbers.x, numbers.y
-        )
-        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            curve_nid = self._elliptic_curve_to_nid(numbers.curve)
+            sn = self._lib.OBJ_nid2sn(curve_nid)
+
+            res = self._lib.OSSL_PARAM_BLD_push_utf8_string(
+                bld, b"group", sn, 0
+            )
+            self.openssl_assert(res == 1)
+
+            point = self._ec_key_affine_coordinates_to_encoded_point(
+                numbers.curve, numbers.x, numbers.y
+            )
+            res = self._lib.OSSL_PARAM_BLD_push_octet_string(
+                bld, b"pub", point, len(point)
+            )
+            self.openssl_assert(res == 1)
+
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_EC, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_PUBLIC_KEY, params
+            )
+            if res != 1:
+                self._consume_errors()
+                raise ValueError("Invalid EC key.")
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+
+            check_ctx = self._lib.EVP_PKEY_CTX_new(evp_pkey, self._ffi.NULL)
+            self.openssl_assert(check_ctx != self._ffi.NULL)
+            check_ctx = self._ffi.gc(check_ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_public_check(check_ctx)
+            if res != 1:
+                self._consume_errors()
+                raise ValueError("Invalid EC key.")
+        else:
+            ec_cdata = self._ec_key_new_by_curve(numbers.curve)
+            self._ec_key_set_public_key_affine_coordinates(
+                ec_cdata, numbers.x, numbers.y
+            )
+            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
 
-        return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)
+        return _EllipticCurvePublicKey(self, evp_pkey)
 
     def load_elliptic_curve_public_bytes(
         self, curve: ec.EllipticCurve, point_bytes: bytes
     ) -> ec.EllipticCurvePublicKey:
-        ec_cdata = self._ec_key_new_by_curve(curve)
-        group = self._lib.EC_KEY_get0_group(ec_cdata)
-        self.openssl_assert(group != self._ffi.NULL)
-        point = self._lib.EC_POINT_new(group)
-        self.openssl_assert(point != self._ffi.NULL)
-        point = self._ffi.gc(point, self._lib.EC_POINT_free)
-        with self._tmp_bn_ctx() as bn_ctx:
-            res = self._lib.EC_POINT_oct2point(
-                group, point, point_bytes, len(point_bytes), bn_ctx
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            curve_nid = self._elliptic_curve_to_nid(curve)
+            sn = self._lib.OBJ_nid2sn(curve_nid)
+
+            res = self._lib.OSSL_PARAM_BLD_push_utf8_string(
+                bld, b"group", sn, 0
+            )
+            self.openssl_assert(res == 1)
+
+            res = self._lib.OSSL_PARAM_BLD_push_octet_string(
+                bld, b"pub", point_bytes, len(point_bytes)
+            )
+            self.openssl_assert(res == 1)
+
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_EC, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_PUBLIC_KEY, params
             )
             if res != 1:
                 self._consume_errors()
-                raise ValueError("Invalid public bytes for the given curve")
+                raise ValueError("Invalid EC key.")
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
 
-        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)
-        self.openssl_assert(res == 1)
-        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
-        return _EllipticCurvePublicKey(self, ec_cdata, evp_pkey)
+            check_ctx = self._lib.EVP_PKEY_CTX_new(evp_pkey, self._ffi.NULL)
+            self.openssl_assert(check_ctx != self._ffi.NULL)
+            check_ctx = self._ffi.gc(check_ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_public_check(check_ctx)
+            if res != 1:
+                self._consume_errors()
+                raise ValueError("Invalid EC key.")
+        else:
+            ec_cdata = self._ec_key_new_by_curve(curve)
+            group = self._lib.EC_KEY_get0_group(ec_cdata)
+            self.openssl_assert(group != self._ffi.NULL)
+            point = self._lib.EC_POINT_new(group)
+            self.openssl_assert(point != self._ffi.NULL)
+            point = self._ffi.gc(point, self._lib.EC_POINT_free)
+            with self._tmp_bn_ctx() as bn_ctx:
+                res = self._lib.EC_POINT_oct2point(
+                    group, point, point_bytes, len(point_bytes), bn_ctx
+                )
+                if res != 1:
+                    self._consume_errors()
+                    raise ValueError("Invalid public bytes for the given curve")
+            res = self._lib.EC_KEY_set_public_key(ec_cdata, point)
+            self.openssl_assert(res == 1)
+            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+
+        return _EllipticCurvePublicKey(self, evp_pkey)
 
     def derive_elliptic_curve_private_key(
         self, private_value: int, curve: ec.EllipticCurve
     ) -> ec.EllipticCurvePrivateKey:
-        ec_cdata = self._ec_key_new_by_curve(curve)
-
-        get_func, group = self._ec_key_determine_group_get_func(ec_cdata)
+        group, point = self._ec_key_point_for_curve(curve)
 
-        point = self._lib.EC_POINT_new(group)
-        self.openssl_assert(point != self._ffi.NULL)
-        point = self._ffi.gc(point, self._lib.EC_POINT_free)
+        get_func = self._ec_key_get_func_for_group(group)
 
         value = self._int_to_bn(private_value)
         value = self._ffi.gc(value, self._lib.BN_clear_free)
@@ -1395,25 +1900,71 @@ class Backend:
                 self._consume_errors()
                 raise ValueError("Unable to derive key from private_value")
 
-        res = self._lib.EC_KEY_set_public_key(ec_cdata, point)
-        self.openssl_assert(res == 1)
-        private = self._int_to_bn(private_value)
-        private = self._ffi.gc(private, self._lib.BN_clear_free)
-        res = self._lib.EC_KEY_set_private_key(ec_cdata, private)
-        self.openssl_assert(res == 1)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            curve_nid = self._elliptic_curve_to_nid(curve)
+            sn = self._lib.OBJ_nid2sn(curve_nid)
+
+            res = self._lib.OSSL_PARAM_BLD_push_utf8_string(
+                bld, b"group", sn, 0
+            )
+            self.openssl_assert(res == 1)
+
+            encoded_point = self._ec_key_encode_point(group, point)
+            res = self._lib.OSSL_PARAM_BLD_push_octet_string(
+                bld, b"pub", encoded_point, len(encoded_point)
+            )
+            self.openssl_assert(res == 1)
+
+            res = self._lib.OSSL_PARAM_BLD_push_BN(bld, b"priv", value)
+            self.openssl_assert(res == 1)
+
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
 
-        evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+            ctx = self._lib.EVP_PKEY_CTX_new_id(
+                self._lib.EVP_PKEY_EC, self._ffi.NULL
+            )
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
 
-        return _EllipticCurvePrivateKey(self, ec_cdata, evp_pkey)
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEYPAIR, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            ec_cdata = self._ec_key_new_by_curve(curve)
+            res = self._lib.EC_KEY_set_public_key(ec_cdata, point)
+            self.openssl_assert(res == 1)
+            private = self._int_to_bn(private_value)
+            private = self._ffi.gc(private, self._lib.BN_clear_free)
+            res = self._lib.EC_KEY_set_private_key(ec_cdata, private)
+            self.openssl_assert(res == 1)
+            evp_pkey = self._ec_cdata_to_evp_pkey(ec_cdata)
+
+        return _EllipticCurvePrivateKey(self, evp_pkey)
 
     def _ec_key_new_by_curve(self, curve: ec.EllipticCurve):
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
         curve_nid = self._elliptic_curve_to_nid(curve)
         return self._ec_key_new_by_curve_nid(curve_nid)
 
     def _ec_key_new_by_curve_nid(self, curve_nid: int):
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
         ec_cdata = self._lib.EC_KEY_new_by_curve_name(curve_nid)
         self.openssl_assert(ec_cdata != self._ffi.NULL)
-        return self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
+        ec_cdata = self._ffi.gc(ec_cdata, self._lib.EC_KEY_free)
+        return ec_data
 
     def elliptic_curve_exchange_algorithm_supported(
         self, algorithm: ec.ECDH, curve: ec.EllipticCurve
@@ -1428,6 +1979,7 @@ class Backend:
         )
 
     def _ec_cdata_to_evp_pkey(self, ec_cdata):
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
         evp_pkey = self._create_evp_pkey_gc()
         res = self._lib.EVP_PKEY_set1_EC_KEY(evp_pkey, ec_cdata)
         self.openssl_assert(res == 1)
@@ -1461,39 +2013,75 @@ class Backend:
         finally:
             self._lib.BN_CTX_end(bn_ctx)
 
-    def _ec_key_determine_group_get_func(self, ctx):
+    def _ec_key_determine_group_get_func(self, evp_pkey):
         """
-        Given an EC_KEY determine the group and what function is required to
+        Given an EVP_PKEY determine the group and what function is required to
         get point coordinates.
         """
-        self.openssl_assert(ctx != self._ffi.NULL)
+        self.openssl_assert(evp_pkey != self._ffi.NULL)
+
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            buflen = self._ffi.new("size_t *")
+            res = self._lib.EVP_PKEY_get_group_name(
+                evp_pkey, self._ffi.NULL, 0, buflen
+            )
+            self.openssl_assert(res == 1)
+            buf = self._ffi.new("unsigned char[]", buflen[0] + 1)
+            res = self._lib.EVP_PKEY_get_group_name(
+                evp_pkey, buf, buflen[0] + 1, buflen
+            )
+            self.openssl_assert(res == 1)
 
-        nid_two_field = self._lib.OBJ_sn2nid(b"characteristic-two-field")
-        self.openssl_assert(nid_two_field != self._lib.NID_undef)
+            curve_nid = self._lib.OBJ_sn2nid(buf)
 
-        group = self._lib.EC_KEY_get0_group(ctx)
-        self.openssl_assert(group != self._ffi.NULL)
+            group = self._lib.EC_GROUP_new_by_curve_name(curve_nid)
+            self.openssl_assert(group != self._ffi.NULL)
+            group = self._ffi.gc(group, self._lib.EC_GROUP_free)
+        else:
+            ec_cdata = self._lib.EVP_PKEY_get0_EC_KEY(evp_pkey)
 
-        method = self._lib.EC_GROUP_method_of(group)
-        self.openssl_assert(method != self._ffi.NULL)
+            group = self._lib.EC_KEY_get0_group(ec_cdata)
+            self.openssl_assert(group != self._ffi.NULL)
 
-        nid = self._lib.EC_METHOD_get_field_type(method)
-        self.openssl_assert(nid != self._lib.NID_undef)
+        get_func = self._ec_key_get_func_for_group(group)
+
+        return get_func, group
+
+    def _ec_key_get_func_for_group(self, group):
+        """
+        Given an EC_GROUP determine the function used to get point coordinates.
+        """
+        self.openssl_assert(group != self._ffi.NULL)
 
-        if nid == nid_two_field and self._lib.Cryptography_HAS_EC2M:
-            get_func = self._lib.EC_POINT_get_affine_coordinates_GF2m
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            get_func = self._lib.EC_POINT_get_affine_coordinates
         else:
-            get_func = self._lib.EC_POINT_get_affine_coordinates_GFp
+            nid_two_field = self._lib.OBJ_sn2nid(b"characteristic-two-field")
+            self.openssl_assert(nid_two_field != self._lib.NID_undef)
+
+            method = self._lib.EC_GROUP_method_of(group)
+            self.openssl_assert(method != self._ffi.NULL)
+
+            nid = self._lib.EC_METHOD_get_field_type(method)
+            self.openssl_assert(nid != self._lib.NID_undef)
+
+            if nid == nid_two_field and self._lib.Cryptography_HAS_EC2M:
+                get_func = self._lib.EC_POINT_get_affine_coordinates_GF2m
+            else:
+                get_func = self._lib.EC_POINT_get_affine_coordinates_GFp
 
         assert get_func
 
-        return get_func, group
+        return get_func
 
-    def _ec_key_set_public_key_affine_coordinates(self, ctx, x: int, y: int):
+    def _ec_key_set_public_key_affine_coordinates(
+        self, ec_cdata, x: int, y: int
+    ):
         """
-        Sets the public key point in the EC_KEY context to the affine x and y
+        Sets the public key point in the EC_KEY to the affine x and y
         values.
         """
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
 
         if x < 0 or y < 0:
             raise ValueError(
@@ -1502,11 +2090,77 @@ class Backend:
 
         x = self._ffi.gc(self._int_to_bn(x), self._lib.BN_free)
         y = self._ffi.gc(self._int_to_bn(y), self._lib.BN_free)
-        res = self._lib.EC_KEY_set_public_key_affine_coordinates(ctx, x, y)
+
+        res = self._lib.EC_KEY_set_public_key_affine_coordinates(ec_cdata, x, y)
         if res != 1:
             self._consume_errors()
             raise ValueError("Invalid EC key.")
 
+    def _ec_key_point_for_curve(self, curve: ec.EllipticCurve):
+        """
+        Create an empty EC_POINT on the given curve
+        """
+        curve_nid = self._elliptic_curve_to_nid(curve)
+
+        group = self._lib.EC_GROUP_new_by_curve_name(curve_nid)
+        self.openssl_assert(group != self._ffi.NULL)
+        group = self._ffi.gc(group, self._lib.EC_GROUP_free)
+
+        point = self._lib.EC_POINT_new(group)
+        self.openssl_assert(point != self._ffi.NULL)
+        point = self._ffi.gc(point, self._lib.EC_POINT_free)
+
+        return group, point
+
+    def _ec_key_affine_coordinates_to_encoded_point(
+        self, curve: ec.EllipticCurve, x: int, y: int
+    ):
+        """
+        Convert the public key point affine coordinates to a buffer
+        containing an encoded EC point
+        """
+        assert self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+
+        if x < 0 or y < 0:
+            raise ValueError(
+                "Invalid EC key. Both x and y must be non-negative."
+            )
+
+        x = self._ffi.gc(self._int_to_bn(x), self._lib.BN_free)
+        y = self._ffi.gc(self._int_to_bn(y), self._lib.BN_free)
+
+        group, point = self._ec_key_point_for_curve(curve)
+
+        res = self._lib.EC_POINT_set_affine_coordinates(
+            group, point, x, y, self._ffi.NULL
+        )
+        if res != 1:
+            self._consume_errors()
+            raise ValueError("Invalid EC key.")
+
+        return self._ec_key_encode_point(group, point)
+
+    def _ec_key_encode_point(self, group, point):
+        """
+        Encode an EC_POINT to EC point format
+        """
+        self.openssl_assert(group != self._ffi.NULL)
+        self.openssl_assert(point != self._ffi.NULL)
+
+        with self._tmp_bn_ctx() as bn_ctx:
+            conversion = self._lib.POINT_CONVERSION_UNCOMPRESSED
+            buflen = self._lib.EC_POINT_point2oct(
+                group, point, conversion, self._ffi.NULL, 0, bn_ctx
+            )
+            self.openssl_assert(buflen > 0)
+            buf = self._ffi.new("char[]", buflen)
+            res = self._lib.EC_POINT_point2oct(
+                group, point, conversion, buf, buflen, bn_ctx
+            )
+            self.openssl_assert(buflen == res)
+
+        return self._ffi.buffer(buf)[:buflen]
+
     def _private_key_bytes(
         self,
         encoding: serialization.Encoding,
@@ -1514,7 +2168,6 @@ class Backend:
         encryption_algorithm: serialization.KeySerializationEncryption,
         key,
         evp_pkey,
-        cdata,
     ) -> bytes:
         # validate argument types
         if not isinstance(encoding, serialization.Encoding):
@@ -1576,19 +2229,69 @@ class Backend:
                     "Encrypted traditional OpenSSL format is not "
                     "supported in FIPS mode."
                 )
-            key_type = self._lib.EVP_PKEY_id(evp_pkey)
+            key_type = self._key_type_from_pkey(evp_pkey)
+
+            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                if key_type not in (
+                    self._lib.EVP_PKEY_DSA,
+                    self._lib.EVP_PKEY_EC,
+                    self._lib.EVP_PKEY_RSA
+                ):
+                    raise ValueError(
+                        "Unsupported key type for TraditionalOpenSSL"
+                    )
+
+                if encoding is serialization.Encoding.PEM:
+                    output_type = b"PEM"
+                elif encoding is serialization.Encoding.DER:
+                    if password:
+                        raise ValueError(
+                            "Encryption is not supported for DER encoded "
+                            "traditional OpenSSL keys"
+                        )
+                    output_type = b"DER"
+                else:
+                    raise ValueError("Unsupported encoding for TraditionalOpenSSL")
+
+                ctx = self._lib.OSSL_ENCODER_CTX_new_for_pkey(
+                    evp_pkey,
+                    self._lib.EVP_PKEY_KEYPAIR,
+                    output_type,
+                    b"type-specific",
+                    self._ffi.NULL
+                )
+                self.openssl_assert(ctx != self._ffi.NULL)
+                ctx = self._ffi.gc(ctx, self._lib.OSSL_ENCODER_CTX_free)
+                if password:
+                    # This is a curated value that we will update over time.
+                    res = self._lib.OSSL_ENCODER_CTX_set_cipher(
+                        ctx, b"aes-256-cbc", self._ffi.NULL
+                    )
+                    self.openssl_assert(res == 1)
+                    res = self._lib.OSSL_ENCODER_CTX_set_passphrase(
+                        ctx, password, len(password)
+                    )
+                    self.openssl_assert(res == 1)
+                return self._bio_func_output(
+                    lambda b, c: self._lib.OSSL_ENCODER_to_bio(c, b),
+                    ctx
+                )
 
             if encoding is serialization.Encoding.PEM:
                 if key_type == self._lib.EVP_PKEY_RSA:
                     write_bio = self._lib.PEM_write_bio_RSAPrivateKey
+                    cdata = self._lib.EVP_PKEY_get0_RSA(evp_pkey)
                 elif key_type == self._lib.EVP_PKEY_DSA:
                     write_bio = self._lib.PEM_write_bio_DSAPrivateKey
+                    cdata = self._lib.EVP_PKEY_get0_DSA(evp_pkey)
                 elif key_type == self._lib.EVP_PKEY_EC:
                     write_bio = self._lib.PEM_write_bio_ECPrivateKey
+                    cdata = self._lib.EVP_PKEY_get0_EC(evp_pkey)
                 else:
                     raise ValueError(
                         "Unsupported key type for TraditionalOpenSSL"
                     )
+                self.openssl_assert(cdata != self._ffi.NULL)
                 return self._private_key_bytes_via_bio(
                     write_bio, cdata, password
                 )
@@ -1601,14 +2304,18 @@ class Backend:
                     )
                 if key_type == self._lib.EVP_PKEY_RSA:
                     write_bio = self._lib.i2d_RSAPrivateKey_bio
+                    cdata = self._lib.EVP_PKEY_get0_RSA(evp_pkey)
                 elif key_type == self._lib.EVP_PKEY_EC:
                     write_bio = self._lib.i2d_ECPrivateKey_bio
+                    cdata = self._lib.EVP_PKEY_get0_EC(evp_pkey)
                 elif key_type == self._lib.EVP_PKEY_DSA:
                     write_bio = self._lib.i2d_DSAPrivateKey_bio
+                    cdata = self._lib.EVP_PKEY_get0_DSA(evp_pkey)
                 else:
                     raise ValueError(
                         "Unsupported key type for TraditionalOpenSSL"
                     )
+                self.openssl_assert(cdata != self._ffi.NULL)
                 return self._bio_func_output(write_bio, cdata)
 
             raise ValueError("Unsupported encoding for TraditionalOpenSSL")
@@ -1658,7 +2365,6 @@ class Backend:
         format: serialization.PublicFormat,
         key,
         evp_pkey,
-        cdata,
     ) -> bytes:
         if not isinstance(encoding, serialization.Encoding):
             raise TypeError("encoding must be an item from the Encoding enum")
@@ -1682,16 +2388,37 @@ class Backend:
         # PKCS1 + PEM/DER
         if format is serialization.PublicFormat.PKCS1:
             # Only RSA is supported here.
-            key_type = self._lib.EVP_PKEY_id(evp_pkey)
+            key_type = self._key_type_from_pkey(evp_pkey)
             if key_type != self._lib.EVP_PKEY_RSA:
                 raise ValueError("PKCS1 format is supported only for RSA keys")
 
-            if encoding is serialization.Encoding.PEM:
-                write_bio = self._lib.PEM_write_bio_RSAPublicKey
-            elif encoding is serialization.Encoding.DER:
-                write_bio = self._lib.i2d_RSAPublicKey_bio
+            if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                if encoding is serialization.Encoding.PEM:
+                    output_type = b"PEM"
+                elif encoding is serialization.Encoding.DER:
+                    output_type = b"DER"
+                else:
+                    raise ValueError("PKCS1 works only with PEM or DER encoding")
+
+                cdata = self._lib.OSSL_ENCODER_CTX_new_for_pkey(
+                    evp_pkey,
+                    self._lib.EVP_PKEY_PUBLIC_KEY,
+                    output_type,
+                    b"pkcs1",
+                    self._ffi.NULL
+                )
+                self.openssl_assert(cdata != self._ffi.NULL)
+                cdata = self._ffi.gc(cdata, self._lib.OSSL_ENCODER_CTX_free)
+                write_bio = lambda bio, ctx: self._lib.OSSL_ENCODER_to_bio(ctx, bio)
             else:
-                raise ValueError("PKCS1 works only with PEM or DER encoding")
+                if encoding is serialization.Encoding.PEM:
+                    write_bio = self._lib.PEM_write_bio_RSAPublicKey
+                elif encoding is serialization.Encoding.DER:
+                    write_bio = self._lib.i2d_RSAPublicKey_bio
+                else:
+                    raise ValueError("PKCS1 works only with PEM or DER encoding")
+                cdata = self._lib.EVP_PKEY_get0_RSA(evp_pkey)
+                self.openssl_assert(cdata != self._ffi.NULL)
             return self._bio_func_output(write_bio, cdata)
 
         # OpenSSH + OpenSSH
@@ -1723,20 +2450,34 @@ class Backend:
         if generator not in (2, 5):
             raise ValueError("DH generator must be 2 or 5")
 
-        dh_param_cdata = self._lib.DH_new()
-        self.openssl_assert(dh_param_cdata != self._ffi.NULL)
-        dh_param_cdata = self._ffi.gc(dh_param_cdata, self._lib.DH_free)
-
-        res = self._lib.DH_generate_parameters_ex(
-            dh_param_cdata, key_size, generator, self._ffi.NULL
+        evp_pkey_ctx = self._lib.EVP_PKEY_CTX_new_id(
+            self._lib.EVP_PKEY_DH, self._ffi.NULL
+        )
+        self.openssl_assert(evp_pkey_ctx != self._ffi.NULL)
+        evp_pkey_ctx = self._ffi.gc(evp_pkey_ctx, self._lib.EVP_PKEY_CTX_free)
+        res = self._lib.EVP_PKEY_paramgen_init(evp_pkey_ctx)
+        self.openssl_assert(res == 1)
+        res = self._lib.EVP_PKEY_CTX_set_dh_paramgen_prime_len(
+            evp_pkey_ctx, key_size
+        )
+        self.openssl_assert(res == 1)
+        res = self._lib.EVP_PKEY_CTX_set_dh_paramgen_generator(
+            evp_pkey_ctx, generator
         )
+        self.openssl_assert(res == 1)
+        evp_ppkey = self._ffi.new("EVP_PKEY **")
+        res = self._lib.EVP_PKEY_paramgen(evp_pkey_ctx, evp_ppkey)
         if res != 1:
             errors = self._consume_errors_with_text()
             raise ValueError("Unable to generate DH parameters", errors)
 
-        return _DHParameters(self, dh_param_cdata)
+        self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+
+        return _DHParameters(self, evp_pkey)
 
     def _dh_cdata_to_evp_pkey(self, dh_cdata):
+        assert not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
         evp_pkey = self._create_evp_pkey_gc()
         res = self._lib.EVP_PKEY_set1_DH(evp_pkey, dh_cdata)
         self.openssl_assert(res == 1)
@@ -1745,16 +2486,20 @@ class Backend:
     def generate_dh_private_key(
         self, parameters: dh.DHParameters
     ) -> dh.DHPrivateKey:
-        dh_key_cdata = _dh_params_dup(
-            parameters._dh_cdata, self  # type: ignore[attr-defined]
+        evp_pkey_ctx = self._lib.EVP_PKEY_CTX_new(
+            parameters._evp_pkey, self._ffi.NULL
         )
-
-        res = self._lib.DH_generate_key(dh_key_cdata)
+        self.openssl_assert(evp_pkey_ctx != self._ffi.NULL)
+        evp_pkey_ctx = self._ffi.gc(evp_pkey_ctx, self._lib.EVP_PKEY_CTX_free)
+        res = self._lib.EVP_PKEY_keygen_init(evp_pkey_ctx)
         self.openssl_assert(res == 1)
+        evp_ppkey = self._ffi.new("EVP_PKEY **")
+        res = self._lib.EVP_PKEY_keygen(evp_pkey_ctx, evp_ppkey)
+        self.openssl_assert(res == 1)
+        self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+        evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
 
-        evp_pkey = self._dh_cdata_to_evp_pkey(dh_key_cdata)
-
-        return _DHPrivateKey(self, dh_key_cdata, evp_pkey)
+        return _DHPrivateKey(self, evp_pkey)
 
     def generate_dh_private_key_and_parameters(
         self, generator: int, key_size: int
@@ -1768,10 +2513,6 @@ class Backend:
     ) -> dh.DHPrivateKey:
         parameter_numbers = numbers.public_numbers.parameter_numbers
 
-        dh_cdata = self._lib.DH_new()
-        self.openssl_assert(dh_cdata != self._ffi.NULL)
-        dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-
         p = self._int_to_bn(parameter_numbers.p)
         g = self._int_to_bn(parameter_numbers.g)
 
@@ -1783,41 +2524,113 @@ class Backend:
         pub_key = self._int_to_bn(numbers.public_numbers.y)
         priv_key = self._int_to_bn(numbers.x)
 
-        res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
-        self.openssl_assert(res == 1)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            g = self._ffi.gc(g, self._lib.BN_free)
+            pub_key = self._ffi.gc(pub_key, self._lib.BN_free)
+            priv_key = self._ffi.gc(priv_key, self._lib.BN_free)
+            key_type = self._lib.EVP_PKEY_DH
+            if q != self._ffi.NULL:
+                q = self._ffi.gc(q, self._lib.BN_free)
+                key_type = self._lib.EVP_PKEY_DHX
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"p", p),
+                (b"q", q),
+                (b"g", g),
+                (b"pub", pub_key),
+                (b"priv", priv_key),
+            ]:
+                if key == b"q" and bn == self._ffi.NULL:
+                    continue
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
 
-        res = self._lib.DH_set0_key(dh_cdata, pub_key, priv_key)
-        self.openssl_assert(res == 1)
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
 
-        codes = self._ffi.new("int[]", 1)
-        res = self._lib.DH_check(dh_cdata, codes)
-        self.openssl_assert(res == 1)
+            ctx = self._lib.EVP_PKEY_CTX_new_id(key_type, self._ffi.NULL)
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
 
-        # DH_check will return DH_NOT_SUITABLE_GENERATOR if p % 24 does not
-        # equal 11 when the generator is 2 (a quadratic nonresidue).
-        # We want to ignore that error because p % 24 == 23 is also fine.
-        # Specifically, g is then a quadratic residue. Within the context of
-        # Diffie-Hellman this means it can only generate half the possible
-        # values. That sounds bad, but quadratic nonresidues leak a bit of
-        # the key to the attacker in exchange for having the full key space
-        # available. See: https://crypto.stackexchange.com/questions/12961
-        if codes[0] != 0 and not (
-            parameter_numbers.g == 2
-            and codes[0] ^ self._lib.DH_NOT_SUITABLE_GENERATOR == 0
-        ):
-            raise ValueError("DH private numbers did not pass safety checks.")
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
 
-        evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEYPAIR, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+
+            check_ctx = self._lib.EVP_PKEY_CTX_new(evp_pkey, self._ffi.NULL);
+            self.openssl_assert(check_ctx != self._ffi.NULL);
+            check_ctx = self._ffi.gc(check_ctx, self._lib.EVP_PKEY_CTX_free);
+
+            if self._lib.EVP_PKEY_param_check(check_ctx) != 1:
+                err = self._lib.ERR_peek_error()
+                # DH_check will return DH_NOT_SUITABLE_GENERATOR if p % 24 does not
+                # equal 11 when the generator is 2 (a quadratic nonresidue).
+                # We want to ignore that error because p % 24 == 23 is also fine.
+                # Specifically, g is then a quadratic residue. Within the context of
+                # Diffie-Hellman this means it can only generate half the possible
+                # values. That sounds bad, but quadratic nonresidues leak a bit of
+                # the key to the attacker in exchange for having the full key space
+                # available. See: https://crypto.stackexchange.com/questions/12961
+                if (parameter_numbers.g == 2
+                    and self._lib.ERR_GET_LIB(err) == self._lib.ERR_LIB_DH
+                    and self._lib.ERR_GET_REASON(err) == 
+                        self._lib.DH_R_NOT_SUITABLE_GENERATOR
+                ):
+                    self._lib.ERR_clear_error()
+                else:
+                    errors = self._consume_errors_with_text()
+                    raise ValueError(
+                        "DH private numbers did not pass safety checks.",
+                        errors
+                    )
+        else:
+            dh_cdata = self._lib.DH_new()
+            self.openssl_assert(dh_cdata != self._ffi.NULL)
+            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
+
+            res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
+            self.openssl_assert(res == 1)
+
+            res = self._lib.DH_set0_key(dh_cdata, pub_key, priv_key)
+            self.openssl_assert(res == 1)
+
+            codes = self._ffi.new("int[]", 1)
+            res = self._lib.DH_check(dh_cdata, codes)
+            self.openssl_assert(res == 1)
+
+            # DH_check will return DH_NOT_SUITABLE_GENERATOR if p % 24 does not
+            # equal 11 when the generator is 2 (a quadratic nonresidue).
+            # We want to ignore that error because p % 24 == 23 is also fine.
+            # Specifically, g is then a quadratic residue. Within the context of
+            # Diffie-Hellman this means it can only generate half the possible
+            # values. That sounds bad, but quadratic nonresidues leak a bit of
+            # the key to the attacker in exchange for having the full key space
+            # available. See: https://crypto.stackexchange.com/questions/12961
+            if codes[0] != 0 and not (
+                parameter_numbers.g == 2
+                and codes[0] ^ self._lib.DH_NOT_SUITABLE_GENERATOR == 0
+            ):
+                raise ValueError("DH private numbers did not pass safety checks.")
+
+            evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
 
-        return _DHPrivateKey(self, dh_cdata, evp_pkey)
+        return _DHPrivateKey(self, evp_pkey)
 
     def load_dh_public_numbers(
         self, numbers: dh.DHPublicNumbers
     ) -> dh.DHPublicKey:
-        dh_cdata = self._lib.DH_new()
-        self.openssl_assert(dh_cdata != self._ffi.NULL)
-        dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-
         parameter_numbers = numbers.parameter_numbers
 
         p = self._int_to_bn(parameter_numbers.p)
@@ -1830,23 +2643,66 @@ class Backend:
 
         pub_key = self._int_to_bn(numbers.y)
 
-        res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
-        self.openssl_assert(res == 1)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            g = self._ffi.gc(g, self._lib.BN_free)
+            pub_key = self._ffi.gc(pub_key, self._lib.BN_free)
+            key_type = self._lib.EVP_PKEY_DH
+            if q != self._ffi.NULL:
+                q = self._ffi.gc(q, self._lib.BN_free)
+                key_type = self._lib.EVP_PKEY_DHX
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"p", p),
+                (b"q", q),
+                (b"g", g),
+                (b"pub", pub_key),
+            ]:
+                if key == b"q" and bn == self._ffi.NULL:
+                    continue
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
 
-        res = self._lib.DH_set0_key(dh_cdata, pub_key, self._ffi.NULL)
-        self.openssl_assert(res == 1)
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(key_type, self._ffi.NULL)
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_PUBLIC_KEY, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            dh_cdata = self._lib.DH_new()
+            self.openssl_assert(dh_cdata != self._ffi.NULL)
+            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
+
+            res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
+            self.openssl_assert(res == 1)
+
+            res = self._lib.DH_set0_key(dh_cdata, pub_key, self._ffi.NULL)
+            self.openssl_assert(res == 1)
 
-        evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
+            evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
 
-        return _DHPublicKey(self, dh_cdata, evp_pkey)
+        return _DHPublicKey(self, evp_pkey)
 
     def load_dh_parameter_numbers(
         self, numbers: dh.DHParameterNumbers
     ) -> dh.DHParameters:
-        dh_cdata = self._lib.DH_new()
-        self.openssl_assert(dh_cdata != self._ffi.NULL)
-        dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-
         p = self._int_to_bn(numbers.p)
         g = self._int_to_bn(numbers.g)
 
@@ -1855,18 +2711,61 @@ class Backend:
         else:
             q = self._ffi.NULL
 
-        res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
-        self.openssl_assert(res == 1)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            g = self._ffi.gc(g, self._lib.BN_free)
+            key_type = self._lib.EVP_PKEY_DH
+            if q != self._ffi.NULL:
+                q = self._ffi.gc(q, self._lib.BN_free)
+                key_type = self._lib.EVP_PKEY_DHX
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"p", p),
+                (b"q", q),
+                (b"g", g),
+            ]:
+                if key == b"q" and bn == self._ffi.NULL:
+                    continue
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
 
-        return _DHParameters(self, dh_cdata)
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(key_type, self._ffi.NULL)
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEY_PARAMETERS, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+        else:
+            dh_cdata = self._lib.DH_new()
+            self.openssl_assert(dh_cdata != self._ffi.NULL)
+            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
+
+            res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
+            self.openssl_assert(res == 1)
+
+            evp_pkey = self._dh_cdata_to_evp_pkey(dh_cdata)
+
+        return _DHParameters(self, evp_pkey)
 
     def dh_parameters_supported(
         self, p: int, g: int, q: typing.Optional[int] = None
     ) -> bool:
-        dh_cdata = self._lib.DH_new()
-        self.openssl_assert(dh_cdata != self._ffi.NULL)
-        dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
-
         p = self._int_to_bn(p)
         g = self._int_to_bn(g)
 
@@ -1875,14 +2774,67 @@ class Backend:
         else:
             q = self._ffi.NULL
 
-        res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
-        self.openssl_assert(res == 1)
+        if self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+            p = self._ffi.gc(p, self._lib.BN_free)
+            g = self._ffi.gc(g, self._lib.BN_free)
+            key_type = self._lib.EVP_PKEY_DH
+            if q != self._ffi.NULL:
+                q = self._ffi.gc(q, self._lib.BN_free)
+                key_type = self._lib.EVP_PKEY_DHX
+
+            bld = self._lib.OSSL_PARAM_BLD_new();
+            self.openssl_assert(bld != self._ffi.NULL)
+            bld = self._ffi.gc(bld, self._lib.OSSL_PARAM_BLD_free)
+
+            for key, bn in [
+                (b"p", p),
+                (b"q", q),
+                (b"g", g),
+            ]:
+                if key == b"q" and bn == self._ffi.NULL:
+                    continue
+                res = self._lib.OSSL_PARAM_BLD_push_BN(bld, key, bn)
+                self.openssl_assert(res == 1)
 
-        codes = self._ffi.new("int[]", 1)
-        res = self._lib.DH_check(dh_cdata, codes)
-        self.openssl_assert(res == 1)
+            params = self._lib.OSSL_PARAM_BLD_to_param(bld)
+            self.openssl_assert(params != self._ffi.NULL)
+            params = self._ffi.gc(params, self._lib.OSSL_PARAM_free)
+
+            ctx = self._lib.EVP_PKEY_CTX_new_id(key_type, self._ffi.NULL)
+            self.openssl_assert(ctx != self._ffi.NULL)
+            ctx = self._ffi.gc(ctx, self._lib.EVP_PKEY_CTX_free)
+
+            res = self._lib.EVP_PKEY_fromdata_init(ctx)
+            self.openssl_assert(res == 1)
+
+            evp_ppkey = self._ffi.new("EVP_PKEY **")
+            res = self._lib.EVP_PKEY_fromdata(
+                ctx, evp_ppkey, self._lib.EVP_PKEY_KEY_PARAMETERS, params
+            )
+            self.openssl_assert(res == 1)
+            self.openssl_assert(evp_ppkey[0] != self._ffi.NULL)
+            evp_pkey = self._ffi.gc(evp_ppkey[0], self._lib.EVP_PKEY_free)
+
+            check_ctx = self._lib.EVP_PKEY_CTX_new(evp_pkey, self._ffi.NULL);
+            self.openssl_assert(check_ctx != self._ffi.NULL);
+            check_ctx = self._ffi.gc(check_ctx, self._lib.EVP_PKEY_CTX_free);
+
+            res = self._lib.EVP_PKEY_param_check(check_ctx)
+            self._lib.ERR_clear_error()
+            return res == 1
+        else:
+            dh_cdata = self._lib.DH_new()
+            self.openssl_assert(dh_cdata != self._ffi.NULL)
+            dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
+
+            res = self._lib.DH_set0_pqg(dh_cdata, p, q, g)
+            self.openssl_assert(res == 1)
+
+            codes = self._ffi.new("int[]", 1)
+            res = self._lib.DH_check(dh_cdata, codes)
+            self.openssl_assert(res == 1)
 
-        return codes[0] == 0
+            return codes[0] == 0
 
     def dh_x942_serialization_supported(self) -> bool:
         return self._lib.Cryptography_HAS_EVP_PKEY_DHX == 1
@@ -1896,7 +2848,7 @@ class Backend:
         evp_pkey = self._create_evp_pkey_gc()
         res = self._lib.EVP_PKEY_set_type(evp_pkey, self._lib.NID_X25519)
         self.openssl_assert(res == 1)
-        res = self._lib.EVP_PKEY_set1_tls_encodedpoint(
+        res = self._lib.EVP_PKEY_set1_encoded_public_key(
             evp_pkey, data, len(data)
         )
         self.openssl_assert(res == 1)
@@ -1934,7 +2886,7 @@ class Backend:
         self.openssl_assert(evp_pkey != self._ffi.NULL)
         evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
         self.openssl_assert(
-            self._lib.EVP_PKEY_id(evp_pkey) == self._lib.EVP_PKEY_X25519
+            self._key_type_from_pkey(evp_pkey) == self._lib.EVP_PKEY_X25519
         )
         return _X25519PrivateKey(self, evp_pkey)
 
diff --git a/src/cryptography/hazmat/backends/openssl/cmac.py b/src/cryptography/hazmat/backends/openssl/cmac.py
index 6f7363294..4e49fcf90 100644
--- a/src/cryptography/hazmat/backends/openssl/cmac.py
+++ b/src/cryptography/hazmat/backends/openssl/cmac.py
@@ -40,45 +40,67 @@ class _CMACContext:
             adapter = registry[type(algorithm), CBC]
 
             evp_cipher = adapter(self._backend, algorithm, CBC)
+            cipher_name = self._backend._lib.EVP_CIPHER_name(evp_cipher)
 
-            ctx = self._backend._lib.CMAC_CTX_new()
+            evp_mac = self._backend._lib.EVP_MAC_fetch(
+                self._backend._ffi.NULL,
+                b"CMAC",
+                self._backend._ffi.NULL
+            )
+            self._backend.openssl_assert(evp_mac != self._backend._ffi.NULL)
+            evp_mac = self._backend._ffi.gc(
+                evp_mac, self._backend._lib.EVP_MAC_free
+            )
 
+            ctx = self._backend._lib.EVP_MAC_CTX_new(evp_mac)
             self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
-            ctx = self._backend._ffi.gc(ctx, self._backend._lib.CMAC_CTX_free)
+            ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_MAC_CTX_free)
+
+            bld = self._backend._lib.OSSL_PARAM_BLD_new();
+            self._backend.openssl_assert(bld != self._backend._ffi.NULL)
+            bld = self._backend._ffi.gc(bld, self._backend._lib.OSSL_PARAM_BLD_free)
+
+            res = self._backend._lib.OSSL_PARAM_BLD_push_utf8_string(
+                bld, b"cipher", cipher_name, 0
+            )
+            self._backend.openssl_assert(res == 1);
+
+            params = self._backend._lib.OSSL_PARAM_BLD_to_param(bld)
+            self._backend.openssl_assert(params != self._backend._ffi.NULL)
+            params = self._backend._ffi.gc(
+                params, self._backend._lib.OSSL_PARAM_free
+            )
 
             key_ptr = self._backend._ffi.from_buffer(self._key)
-            res = self._backend._lib.CMAC_Init(
-                ctx,
-                key_ptr,
-                len(self._key),
-                evp_cipher,
-                self._backend._ffi.NULL,
+            res = self._backend._lib.EVP_MAC_init(
+                ctx, key_ptr, len(self._key), params
             )
             self._backend.openssl_assert(res == 1)
 
         self._ctx = ctx
 
     def update(self, data: bytes) -> None:
-        res = self._backend._lib.CMAC_Update(self._ctx, data, len(data))
+        res = self._backend._lib.EVP_MAC_update(self._ctx, data, len(data))
         self._backend.openssl_assert(res == 1)
 
     def finalize(self) -> bytes:
         buf = self._backend._ffi.new("unsigned char[]", self._output_length)
         length = self._backend._ffi.new("size_t *", self._output_length)
-        res = self._backend._lib.CMAC_Final(self._ctx, buf, length)
+        res = self._backend._lib.EVP_MAC_final(
+            self._ctx, buf, length, self._output_length
+        )
         self._backend.openssl_assert(res == 1)
 
         self._ctx = None
 
-        return self._backend._ffi.buffer(buf)[:]
+        return self._backend._ffi.buffer(buf)[:length[0]]
 
     def copy(self) -> "_CMACContext":
-        copied_ctx = self._backend._lib.CMAC_CTX_new()
+        copied_ctx = self._backend._lib.EVP_MAC_CTX_dup(self._ctx)
+        self._backend.openssl_assert(copied_ctx != self._backend._ffi.NULL)
         copied_ctx = self._backend._ffi.gc(
-            copied_ctx, self._backend._lib.CMAC_CTX_free
+            copied_ctx, self._backend._lib.EVP_MAC_CTX_free
         )
-        res = self._backend._lib.CMAC_CTX_copy(copied_ctx, self._ctx)
-        self._backend.openssl_assert(res == 1)
         return _CMACContext(self._backend, self._algorithm, ctx=copied_ctx)
 
     def verify(self, signature: bytes) -> None:
diff --git a/src/cryptography/hazmat/backends/openssl/dh.py b/src/cryptography/hazmat/backends/openssl/dh.py
index c429c0239..da0117aca 100644
--- a/src/cryptography/hazmat/backends/openssl/dh.py
+++ b/src/cryptography/hazmat/backends/openssl/dh.py
@@ -12,49 +12,70 @@ if typing.TYPE_CHECKING:
     from cryptography.hazmat.backends.openssl.backend import Backend
 
 
-def _dh_params_dup(dh_cdata, backend: "Backend"):
-    lib = backend._lib
-    ffi = backend._ffi
+def _dh_params_dup(evp_pkey, backend: "Backend"):
+    pparams = backend._ffi.new("OSSL_PARAM **")
+    res = backend._lib.EVP_PKEY_todata(
+        evp_pkey, backend._lib.EVP_PKEY_KEY_PARAMETERS, pparams
+    )
+    backend.openssl_assert(res == 1)
+    backend.openssl_assert(pparams[0] != backend._ffi.NULL)
 
-    param_cdata = lib.DHparams_dup(dh_cdata)
-    backend.openssl_assert(param_cdata != ffi.NULL)
-    param_cdata = ffi.gc(param_cdata, lib.DH_free)
-    if lib.CRYPTOGRAPHY_IS_LIBRESSL:
-        # In libressl DHparams_dup don't copy q
-        q = ffi.new("BIGNUM **")
-        lib.DH_get0_pqg(dh_cdata, ffi.NULL, q, ffi.NULL)
-        q_dup = lib.BN_dup(q[0])
-        res = lib.DH_set0_pqg(param_cdata, ffi.NULL, q_dup, ffi.NULL)
-        backend.openssl_assert(res == 1)
+    params = backend._ffi.gc(pparams[0], backend._lib.OSSL_PARAM_free)
 
-    return param_cdata
+    ctx = backend._lib.EVP_PKEY_CTX_new(evp_pkey, backend._ffi.NULL)
+    backend.openssl_assert(ctx != backend._ffi.NULL)
+    ctx = backend._ffi.gc(ctx, backend._lib.EVP_PKEY_CTX_free)
 
+    res = backend._lib.EVP_PKEY_fromdata_init(ctx)
+    backend.openssl_assert(res == 1)
 
-def _dh_cdata_to_parameters(dh_cdata, backend: "Backend") -> "_DHParameters":
-    param_cdata = _dh_params_dup(dh_cdata, backend)
-    return _DHParameters(backend, param_cdata)
+    evp_ppkey = backend._ffi.new("EVP_PKEY **")
+    res = backend._lib.EVP_PKEY_fromdata(
+        ctx, evp_ppkey, backend._lib.EVP_PKEY_KEY_PARAMETERS, params
+    )
+    backend.openssl_assert(res == 1)
+    backend.openssl_assert(evp_ppkey[0] != backend._ffi.NULL)
+
+    evp_pkey = backend._ffi.gc(evp_ppkey[0], backend._lib.EVP_PKEY_free)
+
+    return evp_pkey
 
 
 class _DHParameters(dh.DHParameters):
-    def __init__(self, backend: "Backend", dh_cdata):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._dh_cdata = dh_cdata
+        self._evp_pkey = evp_pkey
 
     def parameter_numbers(self) -> dh.DHParameterNumbers:
-        p = self._backend._ffi.new("BIGNUM **")
-        g = self._backend._ffi.new("BIGNUM **")
-        q = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DH_get0_pqg(self._dh_cdata, p, q, g)
-        self._backend.openssl_assert(p[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(g[0] != self._backend._ffi.NULL)
+        pp = self._backend._ffi.new("BIGNUM **")
+        pg = self._backend._ffi.new("BIGNUM **")
+        pq = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [
+            (b"p", pp),
+            (b"q", pq),
+            (b"g", pg),
+        ]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            if key != b"q":
+                self._backend.openssl_assert(res == 1)
+                self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+
+        p = self._backend._ffi.gc(pp[0], self._backend._lib.BN_free)
+        g = self._backend._ffi.gc(pg[0], self._backend._lib.BN_free)
+
         q_val: typing.Optional[int]
-        if q[0] == self._backend._ffi.NULL:
-            q_val = None
-        else:
-            q_val = self._backend._bn_to_int(q[0])
+        q_val = None
+        if pq[0] != self._backend._ffi.NULL:
+            q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
+            q_val = self._backend._bn_to_int(q)
+
         return dh.DHParameterNumbers(
-            p=self._backend._bn_to_int(p[0]),
-            g=self._backend._bn_to_int(g[0]),
+            p=self._backend._bn_to_int(p),
+            g=self._backend._bn_to_int(g),
             q=q_val,
         )
 
@@ -72,82 +93,82 @@ class _DHParameters(dh.DHParameters):
         if format is not serialization.ParameterFormat.PKCS3:
             raise ValueError("Only PKCS3 serialization is supported")
 
-        q = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DH_get0_pqg(
-            self._dh_cdata, self._backend._ffi.NULL, q, self._backend._ffi.NULL
-        )
-        if (
-            q[0] != self._backend._ffi.NULL
-            and not self._backend._lib.Cryptography_HAS_EVP_PKEY_DHX
-        ):
-            raise UnsupportedAlgorithm(
-                "DH X9.42 serialization is not supported",
-                _Reasons.UNSUPPORTED_SERIALIZATION,
-            )
-
         if encoding is serialization.Encoding.PEM:
-            if q[0] != self._backend._ffi.NULL:
-                write_bio = self._backend._lib.PEM_write_bio_DHxparams
-            else:
-                write_bio = self._backend._lib.PEM_write_bio_DHparams
+            output_type = b"PEM"
         elif encoding is serialization.Encoding.DER:
-            if q[0] != self._backend._ffi.NULL:
-                write_bio = self._backend._lib.i2d_DHxparams_bio
-            else:
-                write_bio = self._backend._lib.i2d_DHparams_bio
+            output_type = b"DER"
         else:
             raise TypeError("encoding must be an item from the Encoding enum")
 
+        ctx = self._backend._lib.OSSL_ENCODER_CTX_new_for_pkey(
+            self._evp_pkey,
+            self._backend._lib.OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,
+            output_type,
+            self._backend._ffi.NULL,
+            self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+        ctx = self._backend._ffi.gc(
+            ctx, self._backend._lib.OSSL_ENCODER_CTX_free
+        )
         bio = self._backend._create_mem_bio_gc()
-        res = write_bio(bio, self._dh_cdata)
+        res = self._backend._lib.OSSL_ENCODER_to_bio(ctx, bio)
         self._backend.openssl_assert(res == 1)
         return self._backend._read_mem_bio(bio)
 
 
-def _get_dh_num_bits(backend, dh_cdata) -> int:
-    p = backend._ffi.new("BIGNUM **")
-    backend._lib.DH_get0_pqg(dh_cdata, p, backend._ffi.NULL, backend._ffi.NULL)
-    backend.openssl_assert(p[0] != backend._ffi.NULL)
-    return backend._lib.BN_num_bits(p[0])
-
-
 class _DHPrivateKey(dh.DHPrivateKey):
-    def __init__(self, backend: "Backend", dh_cdata, evp_pkey):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._dh_cdata = dh_cdata
         self._evp_pkey = evp_pkey
-        self._key_size_bytes = self._backend._lib.DH_size(dh_cdata)
+        self._key_size = self._backend._lib.EVP_PKEY_bits(evp_pkey)
 
     @property
     def key_size(self) -> int:
-        return _get_dh_num_bits(self._backend, self._dh_cdata)
+        return self._key_size
 
     def private_numbers(self) -> dh.DHPrivateNumbers:
-        p = self._backend._ffi.new("BIGNUM **")
-        g = self._backend._ffi.new("BIGNUM **")
-        q = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DH_get0_pqg(self._dh_cdata, p, q, g)
-        self._backend.openssl_assert(p[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(g[0] != self._backend._ffi.NULL)
-        if q[0] == self._backend._ffi.NULL:
-            q_val = None
-        else:
-            q_val = self._backend._bn_to_int(q[0])
-        pub_key = self._backend._ffi.new("BIGNUM **")
-        priv_key = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DH_get0_key(self._dh_cdata, pub_key, priv_key)
-        self._backend.openssl_assert(pub_key[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(priv_key[0] != self._backend._ffi.NULL)
+        pp = self._backend._ffi.new("BIGNUM **")
+        pg = self._backend._ffi.new("BIGNUM **")
+        pq = self._backend._ffi.new("BIGNUM **")
+        ppub_key = self._backend._ffi.new("BIGNUM **")
+        ppriv_key = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [
+            (b"p", pp),
+            (b"q", pq),
+            (b"g", pg),
+            (b"pub", ppub_key),
+            (b"priv", ppriv_key),
+        ]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            if key != b"q":
+                self._backend.openssl_assert(res == 1)
+                self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+
+        p = self._backend._ffi.gc(pp[0], self._backend._lib.BN_free)
+        g = self._backend._ffi.gc(pg[0], self._backend._lib.BN_free)
+        pub_key = self._backend._ffi.gc(ppub_key[0], self._backend._lib.BN_free)
+        priv_key = self._backend._ffi.gc(ppriv_key[0], self._backend._lib.BN_free)
+
+        q_val = None
+        if pq[0] != self._backend._ffi.NULL:
+            q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
+            q_val = self._backend._bn_to_int(q)
+
         return dh.DHPrivateNumbers(
             public_numbers=dh.DHPublicNumbers(
                 parameter_numbers=dh.DHParameterNumbers(
-                    p=self._backend._bn_to_int(p[0]),
-                    g=self._backend._bn_to_int(g[0]),
+                    p=self._backend._bn_to_int(p),
+                    g=self._backend._bn_to_int(g),
                     q=q_val,
                 ),
-                y=self._backend._bn_to_int(pub_key[0]),
+                y=self._backend._bn_to_int(pub_key),
             ),
-            x=self._backend._bn_to_int(priv_key[0]),
+            x=self._backend._bn_to_int(priv_key),
         )
 
     def exchange(self, peer_public_key: dh.DHPublicKey) -> bytes:
@@ -179,7 +200,7 @@ class _DHPrivateKey(dh.DHPrivateKey):
         self._backend.openssl_assert(res == 1)
 
         key = self._backend._ffi.buffer(buf, keylen[0])[:]
-        pad = self._key_size_bytes - len(key)
+        pad = self._backend._lib.EVP_PKEY_size(self._evp_pkey) - len(key)
 
         if pad > 0:
             key = (b"\x00" * pad) + key
@@ -195,24 +216,41 @@ class _DHPrivateKey(dh.DHPrivateKey):
             )
 
     def public_key(self) -> dh.DHPublicKey:
-        dh_cdata = _dh_params_dup(self._dh_cdata, self._backend)
-        pub_key = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DH_get0_key(
-            self._dh_cdata, pub_key, self._backend._ffi.NULL
+        pparams = self._backend._ffi.new("OSSL_PARAM **")
+        res = self._backend._lib.EVP_PKEY_todata(
+            self._evp_pkey, self._backend._lib.EVP_PKEY_PUBLIC_KEY, pparams
         )
-        self._backend.openssl_assert(pub_key[0] != self._backend._ffi.NULL)
-        pub_key_dup = self._backend._lib.BN_dup(pub_key[0])
-        self._backend.openssl_assert(pub_key_dup != self._backend._ffi.NULL)
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(pparams[0] != self._backend._ffi.NULL)
+
+        params = self._backend._ffi.gc(
+            pparams[0], self._backend._lib.OSSL_PARAM_free
+        )
+
+        ctx = self._backend._lib.EVP_PKEY_CTX_new(
+            self._evp_pkey, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+        ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_PKEY_CTX_free)
+
+        res = self._backend._lib.EVP_PKEY_fromdata_init(ctx)
+        self._backend.openssl_assert(res == 1)
 
-        res = self._backend._lib.DH_set0_key(
-            dh_cdata, pub_key_dup, self._backend._ffi.NULL
+        ppub_key = self._backend._ffi.new("EVP_PKEY **")
+        res = self._backend._lib.EVP_PKEY_fromdata(
+            ctx, ppub_key, self._backend._lib.EVP_PKEY_PUBLIC_KEY, params
         )
         self._backend.openssl_assert(res == 1)
-        evp_pkey = self._backend._dh_cdata_to_evp_pkey(dh_cdata)
-        return _DHPublicKey(self._backend, dh_cdata, evp_pkey)
+        self._backend.openssl_assert(ppub_key[0] != self._backend._ffi.NULL)
+
+        pub_key = self._backend._ffi.gc(
+            ppub_key[0], self._backend._lib.EVP_PKEY_free
+        )
+        return _DHPublicKey(self._backend, pub_key)
 
     def parameters(self) -> dh.DHParameters:
-        return _dh_cdata_to_parameters(self._dh_cdata, self._backend)
+        params = _dh_params_dup(self._evp_pkey, self._backend)
+        return _DHParameters(self._backend, params)
 
     def private_bytes(
         self,
@@ -225,14 +263,13 @@ class _DHPrivateKey(dh.DHPrivateKey):
                 "DH private keys support only PKCS8 serialization"
             )
         if not self._backend._lib.Cryptography_HAS_EVP_PKEY_DHX:
-            q = self._backend._ffi.new("BIGNUM **")
-            self._backend._lib.DH_get0_pqg(
-                self._dh_cdata,
-                self._backend._ffi.NULL,
-                q,
-                self._backend._ffi.NULL,
+            pq = self._backend._ffi.new("BIGNUM **")
+
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, b"q", pq
             )
-            if q[0] != self._backend._ffi.NULL:
+            if res == 1 and pq[0] != self._backend._ffi.NULL:
+                _q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
                 raise UnsupportedAlgorithm(
                     "DH X9.42 serialization is not supported",
                     _Reasons.UNSUPPORTED_SERIALIZATION,
@@ -244,48 +281,60 @@ class _DHPrivateKey(dh.DHPrivateKey):
             encryption_algorithm,
             self,
             self._evp_pkey,
-            self._dh_cdata,
         )
 
 
 class _DHPublicKey(dh.DHPublicKey):
-    def __init__(self, backend: "Backend", dh_cdata, evp_pkey):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._dh_cdata = dh_cdata
         self._evp_pkey = evp_pkey
-        self._key_size_bits = _get_dh_num_bits(self._backend, self._dh_cdata)
+        self._key_size = self._backend._lib.EVP_PKEY_bits(evp_pkey)
 
     @property
     def key_size(self) -> int:
-        return self._key_size_bits
+        return self._key_size
 
     def public_numbers(self) -> dh.DHPublicNumbers:
-        p = self._backend._ffi.new("BIGNUM **")
-        g = self._backend._ffi.new("BIGNUM **")
-        q = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DH_get0_pqg(self._dh_cdata, p, q, g)
-        self._backend.openssl_assert(p[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(g[0] != self._backend._ffi.NULL)
-        if q[0] == self._backend._ffi.NULL:
-            q_val = None
-        else:
-            q_val = self._backend._bn_to_int(q[0])
-        pub_key = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DH_get0_key(
-            self._dh_cdata, pub_key, self._backend._ffi.NULL
-        )
-        self._backend.openssl_assert(pub_key[0] != self._backend._ffi.NULL)
+        pp = self._backend._ffi.new("BIGNUM **")
+        pg = self._backend._ffi.new("BIGNUM **")
+        pq = self._backend._ffi.new("BIGNUM **")
+        ppub_key = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [
+            (b"p", pp),
+            (b"q", pq),
+            (b"g", pg),
+            (b"pub", ppub_key),
+        ]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            if key != b"q":
+                self._backend.openssl_assert(res == 1)
+                self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+
+        p = self._backend._ffi.gc(pp[0], self._backend._lib.BN_free)
+        g = self._backend._ffi.gc(pg[0], self._backend._lib.BN_free)
+        pub_key = self._backend._ffi.gc(ppub_key[0], self._backend._lib.BN_free)
+
+        q_val = None
+        if pq[0] != self._backend._ffi.NULL:
+            q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
+            q_val = self._backend._bn_to_int(q)
+
         return dh.DHPublicNumbers(
             parameter_numbers=dh.DHParameterNumbers(
-                p=self._backend._bn_to_int(p[0]),
-                g=self._backend._bn_to_int(g[0]),
+                p=self._backend._bn_to_int(p),
+                g=self._backend._bn_to_int(g),
                 q=q_val,
             ),
-            y=self._backend._bn_to_int(pub_key[0]),
+            y=self._backend._bn_to_int(pub_key),
         )
 
     def parameters(self) -> dh.DHParameters:
-        return _dh_cdata_to_parameters(self._dh_cdata, self._backend)
+        params = _dh_params_dup(self._evp_pkey, self._backend)
+        return _DHParameters(self._backend, params)
 
     def public_bytes(
         self,
@@ -299,19 +348,18 @@ class _DHPublicKey(dh.DHPublicKey):
             )
 
         if not self._backend._lib.Cryptography_HAS_EVP_PKEY_DHX:
-            q = self._backend._ffi.new("BIGNUM **")
-            self._backend._lib.DH_get0_pqg(
-                self._dh_cdata,
-                self._backend._ffi.NULL,
-                q,
-                self._backend._ffi.NULL,
+            pq = self._backend._ffi.new("BIGNUM **")
+
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, b"q", pq
             )
-            if q[0] != self._backend._ffi.NULL:
+            if res == 1 and pq[0] != self._backend._ffi.NULL:
+                _q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
                 raise UnsupportedAlgorithm(
                     "DH X9.42 serialization is not supported",
                     _Reasons.UNSUPPORTED_SERIALIZATION,
                 )
 
         return self._backend._public_key_bytes(
-            encoding, format, self, self._evp_pkey, None
+            encoding, format, self, self._evp_pkey
         )
diff --git a/src/cryptography/hazmat/backends/openssl/dsa.py b/src/cryptography/hazmat/backends/openssl/dsa.py
index 15bd84a7b..47a0422fa 100644
--- a/src/cryptography/hazmat/backends/openssl/dsa.py
+++ b/src/cryptography/hazmat/backends/openssl/dsa.py
@@ -20,19 +20,29 @@ if typing.TYPE_CHECKING:
 def _dsa_sig_sign(
     backend: "Backend", private_key: "_DSAPrivateKey", data: bytes
 ) -> bytes:
-    sig_buf_len = backend._lib.DSA_size(private_key._dsa_cdata)
-    sig_buf = backend._ffi.new("unsigned char[]", sig_buf_len)
-    buflen = backend._ffi.new("unsigned int *")
-
-    # The first parameter passed to DSA_sign is unused by OpenSSL but
-    # must be an integer.
-    res = backend._lib.DSA_sign(
-        0, data, len(data), sig_buf, buflen, private_key._dsa_cdata
+
+    pctx = backend._lib.EVP_PKEY_CTX_new(
+        private_key._evp_pkey, backend._ffi.NULL
+    )
+    backend.openssl_assert(pctx != backend._ffi.NULL)
+    pctx = backend._ffi.gc(pctx, backend._lib.EVP_PKEY_CTX_free)
+    res = backend._lib.EVP_PKEY_sign_init(pctx)
+    if res != 1:
+        errors = backend._consume_errors()
+        raise ValueError("Unable to sign with this key", errors)
+
+    buflen = backend._ffi.new("size_t *")
+    res = backend._lib.EVP_PKEY_sign(
+        pctx, backend._ffi.NULL, buflen, data, len(data)
     )
     backend.openssl_assert(res == 1)
-    backend.openssl_assert(buflen[0])
+    buf = backend._ffi.new("unsigned char[]", buflen[0])
+    res = backend._lib.EVP_PKEY_sign(pctx, buf, buflen, data, len(data))
+    if res != 1:
+        errors = backend._consume_errors_with_text()
+        raise ValueError("Signing with DSA key failed", errors)
 
-    return backend._ffi.buffer(sig_buf)[: buflen[0]]
+    return backend._ffi.buffer(buf)[:buflen[0]]
 
 
 def _dsa_sig_verify(
@@ -41,34 +51,54 @@ def _dsa_sig_verify(
     signature: bytes,
     data: bytes,
 ) -> None:
-    # The first parameter passed to DSA_verify is unused by OpenSSL but
-    # must be an integer.
-    res = backend._lib.DSA_verify(
-        0, data, len(data), signature, len(signature), public_key._dsa_cdata
+    pctx = backend._lib.EVP_PKEY_CTX_new(
+        public_key._evp_pkey, backend._ffi.NULL
     )
+    backend.openssl_assert(pctx != backend._ffi.NULL)
+    pctx = backend._ffi.gc(pctx, backend._lib.EVP_PKEY_CTX_free)
+    res = backend._lib.EVP_PKEY_verify_init(pctx)
+    if res != 1:
+        errors = backend._consume_errors()
+        raise ValueError("Unable to verify with this key", errors)
 
+    res = backend._lib.EVP_PKEY_verify(
+        pctx, signature, len(signature), data, len(data)
+    )
     if res != 1:
         backend._consume_errors()
         raise InvalidSignature
 
 
 class _DSAParameters(dsa.DSAParameters):
-    def __init__(self, backend: "Backend", dsa_cdata):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._dsa_cdata = dsa_cdata
+        self._evp_pkey = evp_pkey
 
     def parameter_numbers(self) -> dsa.DSAParameterNumbers:
-        p = self._backend._ffi.new("BIGNUM **")
-        q = self._backend._ffi.new("BIGNUM **")
-        g = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DSA_get0_pqg(self._dsa_cdata, p, q, g)
-        self._backend.openssl_assert(p[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(q[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(g[0] != self._backend._ffi.NULL)
+        pp = self._backend._ffi.new("BIGNUM **")
+        pq = self._backend._ffi.new("BIGNUM **")
+        pg = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [
+            (b"p", pp),
+            (b"q", pq),
+            (b"g", pg),
+        ]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            self._backend.openssl_assert(res == 1)
+            self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+
+        p = self._backend._ffi.gc(pp[0], self._backend._lib.BN_free)
+        q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
+        g = self._backend._ffi.gc(pg[0], self._backend._lib.BN_free)
+
         return dsa.DSAParameterNumbers(
-            p=self._backend._bn_to_int(p[0]),
-            q=self._backend._bn_to_int(q[0]),
-            g=self._backend._bn_to_int(g[0]),
+            p=self._backend._bn_to_int(p),
+            q=self._backend._bn_to_int(q),
+            g=self._backend._bn_to_int(g),
         )
 
     def generate_private_key(self) -> dsa.DSAPrivateKey:
@@ -78,73 +108,120 @@ class _DSAParameters(dsa.DSAParameters):
 class _DSAPrivateKey(dsa.DSAPrivateKey):
     _key_size: int
 
-    def __init__(self, backend: "Backend", dsa_cdata, evp_pkey):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._dsa_cdata = dsa_cdata
         self._evp_pkey = evp_pkey
-
-        p = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DSA_get0_pqg(
-            dsa_cdata, p, self._backend._ffi.NULL, self._backend._ffi.NULL
-        )
-        self._backend.openssl_assert(p[0] != backend._ffi.NULL)
-        self._key_size = self._backend._lib.BN_num_bits(p[0])
+        self._key_size = self._backend._lib.EVP_PKEY_bits(evp_pkey)
 
     @property
     def key_size(self) -> int:
         return self._key_size
 
     def private_numbers(self) -> dsa.DSAPrivateNumbers:
-        p = self._backend._ffi.new("BIGNUM **")
-        q = self._backend._ffi.new("BIGNUM **")
-        g = self._backend._ffi.new("BIGNUM **")
-        pub_key = self._backend._ffi.new("BIGNUM **")
-        priv_key = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DSA_get0_pqg(self._dsa_cdata, p, q, g)
-        self._backend.openssl_assert(p[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(q[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(g[0] != self._backend._ffi.NULL)
-        self._backend._lib.DSA_get0_key(self._dsa_cdata, pub_key, priv_key)
-        self._backend.openssl_assert(pub_key[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(priv_key[0] != self._backend._ffi.NULL)
+        pp = self._backend._ffi.new("BIGNUM **")
+        pq = self._backend._ffi.new("BIGNUM **")
+        pg = self._backend._ffi.new("BIGNUM **")
+        ppub_key = self._backend._ffi.new("BIGNUM **")
+        ppriv_key = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [
+            (b"p", pp),
+            (b"q", pq),
+            (b"g", pg),
+            (b"pub", ppub_key),
+            (b"priv", ppriv_key),
+        ]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            self._backend.openssl_assert(res == 1)
+            self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+
+        p = self._backend._ffi.gc(pp[0], self._backend._lib.BN_free)
+        q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
+        g = self._backend._ffi.gc(pg[0], self._backend._lib.BN_free)
+        pub_key = self._backend._ffi.gc(ppub_key[0], self._backend._lib.BN_free)
+        priv_key = self._backend._ffi.gc(ppriv_key[0], self._backend._lib.BN_free)
         return dsa.DSAPrivateNumbers(
             public_numbers=dsa.DSAPublicNumbers(
                 parameter_numbers=dsa.DSAParameterNumbers(
-                    p=self._backend._bn_to_int(p[0]),
-                    q=self._backend._bn_to_int(q[0]),
-                    g=self._backend._bn_to_int(g[0]),
+                    p=self._backend._bn_to_int(p),
+                    q=self._backend._bn_to_int(q),
+                    g=self._backend._bn_to_int(g),
                 ),
-                y=self._backend._bn_to_int(pub_key[0]),
+                y=self._backend._bn_to_int(pub_key),
             ),
-            x=self._backend._bn_to_int(priv_key[0]),
+            x=self._backend._bn_to_int(priv_key),
         )
 
     def public_key(self) -> dsa.DSAPublicKey:
-        dsa_cdata = self._backend._lib.DSAparams_dup(self._dsa_cdata)
-        self._backend.openssl_assert(dsa_cdata != self._backend._ffi.NULL)
-        dsa_cdata = self._backend._ffi.gc(
-            dsa_cdata, self._backend._lib.DSA_free
+        pparams = self._backend._ffi.new("OSSL_PARAM **")
+        res = self._backend._lib.EVP_PKEY_todata(
+            self._evp_pkey, self._backend._lib.EVP_PKEY_PUBLIC_KEY, pparams
         )
-        pub_key = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DSA_get0_key(
-            self._dsa_cdata, pub_key, self._backend._ffi.NULL
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(pparams[0] != self._backend._ffi.NULL)
+
+        params = self._backend._ffi.gc(
+            pparams[0], self._backend._lib.OSSL_PARAM_free
         )
-        self._backend.openssl_assert(pub_key[0] != self._backend._ffi.NULL)
-        pub_key_dup = self._backend._lib.BN_dup(pub_key[0])
-        res = self._backend._lib.DSA_set0_key(
-            dsa_cdata, pub_key_dup, self._backend._ffi.NULL
+
+        ctx = self._backend._lib.EVP_PKEY_CTX_new_id(
+            self._backend._lib.EVP_PKEY_DSA, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+        ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_PKEY_CTX_free)
+
+        res = self._backend._lib.EVP_PKEY_fromdata_init(ctx)
+        self._backend.openssl_assert(res == 1)
+
+        ppub_key = self._backend._ffi.new("EVP_PKEY **")
+        res = self._backend._lib.EVP_PKEY_fromdata(
+            ctx, ppub_key, self._backend._lib.EVP_PKEY_PUBLIC_KEY, params
         )
         self._backend.openssl_assert(res == 1)
-        evp_pkey = self._backend._dsa_cdata_to_evp_pkey(dsa_cdata)
-        return _DSAPublicKey(self._backend, dsa_cdata, evp_pkey)
+        self._backend.openssl_assert(ppub_key[0] != self._backend._ffi.NULL)
+
+        pub_key = self._backend._ffi.gc(
+            ppub_key[0], self._backend._lib.EVP_PKEY_free
+        )
+
+        return _DSAPublicKey(self._backend, pub_key)
 
     def parameters(self) -> dsa.DSAParameters:
-        dsa_cdata = self._backend._lib.DSAparams_dup(self._dsa_cdata)
-        self._backend.openssl_assert(dsa_cdata != self._backend._ffi.NULL)
-        dsa_cdata = self._backend._ffi.gc(
-            dsa_cdata, self._backend._lib.DSA_free
+        pparams = self._backend._ffi.new("OSSL_PARAM **")
+        res = self._backend._lib.EVP_PKEY_todata(
+            self._evp_pkey, self._backend._lib.EVP_PKEY_KEY_PARAMETERS, pparams
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(pparams[0] != self._backend._ffi.NULL)
+
+        params = self._backend._ffi.gc(
+            pparams[0], self._backend._lib.OSSL_PARAM_free
         )
-        return _DSAParameters(self._backend, dsa_cdata)
+
+        ctx = self._backend._lib.EVP_PKEY_CTX_new_id(
+            self._backend._lib.EVP_PKEY_DSA, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+        ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_PKEY_CTX_free)
+
+        res = self._backend._lib.EVP_PKEY_fromdata_init(ctx)
+        self._backend.openssl_assert(res == 1)
+
+        evp_ppkey = self._backend._ffi.new("EVP_PKEY **")
+        res = self._backend._lib.EVP_PKEY_fromdata(
+            ctx, evp_ppkey, self._backend._lib.EVP_PKEY_KEY_PARAMETERS, params
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(evp_ppkey[0] != self._backend._ffi.NULL)
+
+        evp_pkey = self._backend._ffi.gc(
+            evp_ppkey[0], self._backend._lib.EVP_PKEY_free
+        )
+
+        return _DSAParameters(self._backend, evp_pkey)
 
     def private_bytes(
         self,
@@ -158,7 +235,6 @@ class _DSAPrivateKey(dsa.DSAPrivateKey):
             encryption_algorithm,
             self,
             self._evp_pkey,
-            self._dsa_cdata,
         )
 
     def sign(
@@ -173,49 +249,81 @@ class _DSAPrivateKey(dsa.DSAPrivateKey):
 class _DSAPublicKey(dsa.DSAPublicKey):
     _key_size: int
 
-    def __init__(self, backend: "Backend", dsa_cdata, evp_pkey):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._dsa_cdata = dsa_cdata
         self._evp_pkey = evp_pkey
-        p = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DSA_get0_pqg(
-            dsa_cdata, p, self._backend._ffi.NULL, self._backend._ffi.NULL
-        )
-        self._backend.openssl_assert(p[0] != backend._ffi.NULL)
-        self._key_size = self._backend._lib.BN_num_bits(p[0])
+        self._key_size = self._backend._lib.EVP_PKEY_bits(evp_pkey)
 
     @property
     def key_size(self) -> int:
         return self._key_size
 
     def public_numbers(self) -> dsa.DSAPublicNumbers:
-        p = self._backend._ffi.new("BIGNUM **")
-        q = self._backend._ffi.new("BIGNUM **")
-        g = self._backend._ffi.new("BIGNUM **")
-        pub_key = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.DSA_get0_pqg(self._dsa_cdata, p, q, g)
-        self._backend.openssl_assert(p[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(q[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(g[0] != self._backend._ffi.NULL)
-        self._backend._lib.DSA_get0_key(
-            self._dsa_cdata, pub_key, self._backend._ffi.NULL
-        )
-        self._backend.openssl_assert(pub_key[0] != self._backend._ffi.NULL)
+        pp = self._backend._ffi.new("BIGNUM **")
+        pq = self._backend._ffi.new("BIGNUM **")
+        pg = self._backend._ffi.new("BIGNUM **")
+        ppub_key = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [
+            (b"p", pp),
+            (b"q", pq),
+            (b"g", pg),
+            (b"pub", ppub_key),
+        ]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            self._backend.openssl_assert(res == 1)
+            self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+
+        p = self._backend._ffi.gc(pp[0], self._backend._lib.BN_free)
+        q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
+        g = self._backend._ffi.gc(pg[0], self._backend._lib.BN_free)
+        pub_key = self._backend._ffi.gc(ppub_key[0], self._backend._lib.BN_free)
+
         return dsa.DSAPublicNumbers(
             parameter_numbers=dsa.DSAParameterNumbers(
-                p=self._backend._bn_to_int(p[0]),
-                q=self._backend._bn_to_int(q[0]),
-                g=self._backend._bn_to_int(g[0]),
+                p=self._backend._bn_to_int(p),
+                q=self._backend._bn_to_int(q),
+                g=self._backend._bn_to_int(g),
             ),
-            y=self._backend._bn_to_int(pub_key[0]),
+            y=self._backend._bn_to_int(pub_key),
         )
 
     def parameters(self) -> dsa.DSAParameters:
-        dsa_cdata = self._backend._lib.DSAparams_dup(self._dsa_cdata)
-        dsa_cdata = self._backend._ffi.gc(
-            dsa_cdata, self._backend._lib.DSA_free
+        pparams = self._backend._ffi.new("OSSL_PARAM **")
+        res = self._backend._lib.EVP_PKEY_todata(
+            self._evp_pkey, self._backend._lib.EVP_PKEY_KEY_PARAMETERS, pparams
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(pparams[0] != self._backend._ffi.NULL)
+
+        params = self._backend._ffi.gc(
+            pparams[0], self._backend._lib.OSSL_PARAM_free
+        )
+
+        ctx = self._backend._lib.EVP_PKEY_CTX_new_id(
+            self._backend._lib.EVP_PKEY_DSA, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+        ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_PKEY_CTX_free)
+
+        res = self._backend._lib.EVP_PKEY_fromdata_init(ctx)
+        self._backend.openssl_assert(res == 1)
+
+        evp_ppkey = self._backend._ffi.new("EVP_PKEY **")
+        res = self._backend._lib.EVP_PKEY_fromdata(
+            ctx, evp_ppkey, self._backend._lib.EVP_PKEY_KEY_PARAMETERS, params
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(evp_ppkey[0] != self._backend._ffi.NULL)
+
+        evp_pkey = self._backend._ffi.gc(
+            evp_ppkey[0], self._backend._lib.EVP_PKEY_free
         )
-        return _DSAParameters(self._backend, dsa_cdata)
+
+        return _DSAParameters(self._backend, evp_pkey)
 
     def public_bytes(
         self,
@@ -223,7 +331,7 @@ class _DSAPublicKey(dsa.DSAPublicKey):
         format: serialization.PublicFormat,
     ) -> bytes:
         return self._backend._public_key_bytes(
-            encoding, format, self, self._evp_pkey, None
+            encoding, format, self, self._evp_pkey
         )
 
     def verify(
diff --git a/src/cryptography/hazmat/backends/openssl/ec.py b/src/cryptography/hazmat/backends/openssl/ec.py
index 9bc6dd384..54bd3bd1f 100644
--- a/src/cryptography/hazmat/backends/openssl/ec.py
+++ b/src/cryptography/hazmat/backends/openssl/ec.py
@@ -30,53 +30,67 @@ def _check_signature_algorithm(
         )
 
 
-def _ec_key_curve_sn(backend: "Backend", ec_key) -> str:
-    group = backend._lib.EC_KEY_get0_group(ec_key)
-    backend.openssl_assert(group != backend._ffi.NULL)
-
-    nid = backend._lib.EC_GROUP_get_curve_name(group)
-    # The following check is to find EC keys with unnamed curves and raise
-    # an error for now.
-    if nid == backend._lib.NID_undef:
-        raise ValueError(
-            "ECDSA keys with explicit parameters are unsupported at this time"
-        )
-
-    # This is like the above check, but it also catches the case where you
-    # explicitly encoded a curve with the same parameters as a named curve.
-    # Don't do that.
-    if (
-        not backend._lib.CRYPTOGRAPHY_IS_LIBRESSL
-        and backend._lib.EC_GROUP_get_asn1_flag(group) == 0
-    ):
+def _ec_key_curve_sn(backend: "Backend", evp_pkey) -> str:
+    value = backend._ffi.new("int *")
+    res = backend._lib.EVP_PKEY_get_int_param(
+        evp_pkey, b"decoded-from-explicit", value
+    )
+    backend.openssl_assert(res == 1);
+    if value[0] == 1:
         raise ValueError(
             "ECDSA keys with explicit parameters are unsupported at this time"
         )
 
-    curve_name = backend._lib.OBJ_nid2sn(nid)
-    backend.openssl_assert(curve_name != backend._ffi.NULL)
-
-    sn = backend._ffi.string(curve_name).decode("ascii")
-    return sn
+    buflen = backend._ffi.new("size_t *")
+    backend._lib.EVP_PKEY_get_group_name(
+        evp_pkey, backend._ffi.NULL, 0, buflen
+    )
+    buf = backend._ffi.new("char []", buflen[0] + 1)
+    res = backend._lib.EVP_PKEY_get_group_name(
+        evp_pkey, buf, buflen[0] + 1, buflen
+    )
+    backend.openssl_assert(res == 1)
+    return backend._ffi.buffer(buf)[:buflen[0]].decode("ascii")
 
 
-def _mark_asn1_named_ec_curve(backend: "Backend", ec_cdata):
+def _mark_asn1_named_ec_curve(backend: "Backend", evp_pkey):
     """
     Set the named curve flag on the EC_KEY. This causes OpenSSL to
     serialize EC keys along with their curve OID which makes
     deserialization easier.
     """
 
-    backend._lib.EC_KEY_set_asn1_flag(
-        ec_cdata, backend._lib.OPENSSL_EC_NAMED_CURVE
+    res = backend._lib.EVP_PKEY_set_utf8_string_param(
+        evp_pkey, b"encoding", b"named_curve"
     )
+    backend.openssl_assert(res == 1)
 
 
-def _check_key_infinity(backend: "Backend", ec_cdata) -> None:
-    point = backend._lib.EC_KEY_get0_public_key(ec_cdata)
+def _check_key_infinity(backend: "Backend", evp_pkey) -> None:
+    _, group = backend._ec_key_determine_group_get_func(
+        evp_pkey
+    )
+
+    buflen = backend._ffi.new("size_t *")
+    res = backend._lib.EVP_PKEY_get_octet_string_param(
+        evp_pkey, b"pub", backend._ffi.NULL, 0, buflen
+    )
+    backend.openssl_assert(res == 1)
+    buf = backend._ffi.new("unsigned char[]", buflen[0])
+    res = backend._lib.EVP_PKEY_get_octet_string_param(
+        evp_pkey, b"pub", buf, buflen[0], buflen
+    )
+    backend.openssl_assert(res == 1)
+
+    point = backend._lib.EC_POINT_new(group)
     backend.openssl_assert(point != backend._ffi.NULL)
-    group = backend._lib.EC_KEY_get0_group(ec_cdata)
-    backend.openssl_assert(group != backend._ffi.NULL)
+    point = backend._ffi.gc(point, backend._lib.EC_POINT_free)
+
+    res = backend._lib.EC_POINT_oct2point(
+        group, point, buf, buflen[0], backend._ffi.NULL
+    )
+    backend.openssl_assert(res == 1)
+
     if backend._lib.EC_POINT_is_at_infinity(group, point):
         raise ValueError(
             "Cannot load an EC public key where the point is at infinity"
@@ -96,16 +110,28 @@ def _sn_to_elliptic_curve(backend: "Backend", sn: str) -> ec.EllipticCurve:
 def _ecdsa_sig_sign(
     backend: "Backend", private_key: "_EllipticCurvePrivateKey", data: bytes
 ) -> bytes:
-    max_size = backend._lib.ECDSA_size(private_key._ec_key)
-    backend.openssl_assert(max_size > 0)
+    pctx = backend._lib.EVP_PKEY_CTX_new(
+        private_key._evp_pkey, backend._ffi.NULL
+    )
+    backend.openssl_assert(pctx != backend._ffi.NULL)
+    pctx = backend._ffi.gc(pctx, backend._lib.EVP_PKEY_CTX_free)
+    res = backend._lib.EVP_PKEY_sign_init(pctx)
+    if res != 1:
+        errors = backend._consume_errors()
+        raise ValueError("Unable to sign with this key", errors)
 
-    sigbuf = backend._ffi.new("unsigned char[]", max_size)
-    siglen_ptr = backend._ffi.new("unsigned int[]", 1)
-    res = backend._lib.ECDSA_sign(
-        0, data, len(data), sigbuf, siglen_ptr, private_key._ec_key
+    buflen = backend._ffi.new("size_t *")
+    res = backend._lib.EVP_PKEY_sign(
+        pctx, backend._ffi.NULL, buflen, data, len(data)
     )
     backend.openssl_assert(res == 1)
-    return backend._ffi.buffer(sigbuf)[: siglen_ptr[0]]
+    buf = backend._ffi.new("unsigned char[]", buflen[0])
+    res = backend._lib.EVP_PKEY_sign(pctx, buf, buflen, data, len(data))
+    if res != 1:
+        errors = backend._consume_errors_with_text()
+        raise ValueError("Signing with EC key failed", errors)
+
+    return backend._ffi.buffer(buf)[:buflen[0]]
 
 
 def _ecdsa_sig_verify(
@@ -114,8 +140,18 @@ def _ecdsa_sig_verify(
     signature: bytes,
     data: bytes,
 ) -> None:
-    res = backend._lib.ECDSA_verify(
-        0, data, len(data), signature, len(signature), public_key._ec_key
+    pctx = backend._lib.EVP_PKEY_CTX_new(
+        public_key._evp_pkey, backend._ffi.NULL
+    )
+    backend.openssl_assert(pctx != backend._ffi.NULL)
+    pctx = backend._ffi.gc(pctx, backend._lib.EVP_PKEY_CTX_free)
+    res = backend._lib.EVP_PKEY_verify_init(pctx)
+    if res != 1:
+        errors = backend._consume_errors()
+        raise ValueError("Unable to verify with this key", errors)
+
+    res = backend._lib.EVP_PKEY_verify(
+        pctx, signature, len(signature), data, len(data)
     )
     if res != 1:
         backend._consume_errors()
@@ -123,15 +159,14 @@ def _ecdsa_sig_verify(
 
 
 class _EllipticCurvePrivateKey(ec.EllipticCurvePrivateKey):
-    def __init__(self, backend: "Backend", ec_key_cdata, evp_pkey):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._ec_key = ec_key_cdata
         self._evp_pkey = evp_pkey
 
-        sn = _ec_key_curve_sn(backend, ec_key_cdata)
+        sn = _ec_key_curve_sn(backend, evp_pkey)
         self._curve = _sn_to_elliptic_curve(backend, sn)
-        _mark_asn1_named_ec_curve(backend, ec_key_cdata)
-        _check_key_infinity(backend, ec_key_cdata)
+        _mark_asn1_named_ec_curve(backend, evp_pkey)
+        _check_key_infinity(backend, evp_pkey)
 
     @property
     def curve(self) -> ec.EllipticCurve:
@@ -162,25 +197,48 @@ class _EllipticCurvePrivateKey(ec.EllipticCurvePrivateKey):
         return _evp_pkey_derive(self._backend, self._evp_pkey, peer_public_key)
 
     def public_key(self) -> ec.EllipticCurvePublicKey:
-        group = self._backend._lib.EC_KEY_get0_group(self._ec_key)
-        self._backend.openssl_assert(group != self._backend._ffi.NULL)
+        pparams = self._backend._ffi.new("OSSL_PARAM **")
+        res = self._backend._lib.EVP_PKEY_todata(
+            self._evp_pkey, self._backend._lib.EVP_PKEY_PUBLIC_KEY, pparams
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(pparams[0] != self._backend._ffi.NULL)
 
-        curve_nid = self._backend._lib.EC_GROUP_get_curve_name(group)
-        public_ec_key = self._backend._ec_key_new_by_curve_nid(curve_nid)
+        params = self._backend._ffi.gc(
+            pparams[0], self._backend._lib.OSSL_PARAM_free
+        )
 
-        point = self._backend._lib.EC_KEY_get0_public_key(self._ec_key)
-        self._backend.openssl_assert(point != self._backend._ffi.NULL)
+        ctx = self._backend._lib.EVP_PKEY_CTX_new_id(
+            self._backend._lib.EVP_PKEY_EC, self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+        ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_PKEY_CTX_free)
+
+        res = self._backend._lib.EVP_PKEY_fromdata_init(ctx)
+        self._backend.openssl_assert(res == 1)
 
-        res = self._backend._lib.EC_KEY_set_public_key(public_ec_key, point)
+        ppub_key = self._backend._ffi.new("EVP_PKEY **")
+        res = self._backend._lib.EVP_PKEY_fromdata(
+            ctx, ppub_key, self._backend._lib.EVP_PKEY_PUBLIC_KEY, params
+        )
         self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(ppub_key[0] != self._backend._ffi.NULL)
 
-        evp_pkey = self._backend._ec_cdata_to_evp_pkey(public_ec_key)
+        pub_key = self._backend._ffi.gc(
+            ppub_key[0], self._backend._lib.EVP_PKEY_free
+        )
 
-        return _EllipticCurvePublicKey(self._backend, public_ec_key, evp_pkey)
+        return _EllipticCurvePublicKey(self._backend, pub_key)
 
     def private_numbers(self) -> ec.EllipticCurvePrivateNumbers:
-        bn = self._backend._lib.EC_KEY_get0_private_key(self._ec_key)
-        private_value = self._backend._bn_to_int(bn)
+        ppriv = self._backend._ffi.new("BIGNUM **")
+        res = self._backend._lib.EVP_PKEY_get_bn_param(
+            self._evp_pkey, b"priv", ppriv
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(ppriv[0] != self._backend._ffi.NULL)
+        priv = self._backend._ffi.gc(ppriv[0], self._backend._lib.BN_free)
+        private_value = self._backend._bn_to_int(priv)
         return ec.EllipticCurvePrivateNumbers(
             private_value=private_value,
             public_numbers=self.public_key().public_numbers(),
@@ -198,7 +256,6 @@ class _EllipticCurvePrivateKey(ec.EllipticCurvePrivateKey):
             encryption_algorithm,
             self,
             self._evp_pkey,
-            self._ec_key,
         )
 
     def sign(
@@ -215,15 +272,14 @@ class _EllipticCurvePrivateKey(ec.EllipticCurvePrivateKey):
 
 
 class _EllipticCurvePublicKey(ec.EllipticCurvePublicKey):
-    def __init__(self, backend: "Backend", ec_key_cdata, evp_pkey):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._ec_key = ec_key_cdata
         self._evp_pkey = evp_pkey
 
-        sn = _ec_key_curve_sn(backend, ec_key_cdata)
+        sn = _ec_key_curve_sn(backend, evp_pkey)
         self._curve = _sn_to_elliptic_curve(backend, sn)
-        _mark_asn1_named_ec_curve(backend, ec_key_cdata)
-        _check_key_infinity(backend, ec_key_cdata)
+        _mark_asn1_named_ec_curve(backend, evp_pkey)
+        _check_key_infinity(backend, evp_pkey)
 
     @property
     def curve(self) -> ec.EllipticCurve:
@@ -235,10 +291,28 @@ class _EllipticCurvePublicKey(ec.EllipticCurvePublicKey):
 
     def public_numbers(self) -> ec.EllipticCurvePublicNumbers:
         get_func, group = self._backend._ec_key_determine_group_get_func(
-            self._ec_key
+            self._evp_pkey
+        )
+
+        buflen = self._backend._ffi.new("size_t *")
+        res = self._backend._lib.EVP_PKEY_get_octet_string_param(
+            self._evp_pkey, b"pub", self._backend._ffi.NULL, 0, buflen
         )
-        point = self._backend._lib.EC_KEY_get0_public_key(self._ec_key)
+        self._backend.openssl_assert(res == 1)
+        buf = self._backend._ffi.new("unsigned char[]", buflen[0])
+        res = self._backend._lib.EVP_PKEY_get_octet_string_param(
+            self._evp_pkey, b"pub", buf, buflen[0], buflen
+        )
+        self._backend.openssl_assert(res == 1)
+
+        point = self._backend._lib.EC_POINT_new(group)
         self._backend.openssl_assert(point != self._backend._ffi.NULL)
+        point = self._backend._ffi.gc(point, self._backend._lib.EC_POINT_free)
+
+        res = self._backend._lib.EC_POINT_oct2point(
+            group, point, buf, buflen[0], self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(res == 1)
 
         with self._backend._tmp_bn_ctx() as bn_ctx:
             bn_x = self._backend._lib.BN_CTX_get(bn_ctx)
@@ -259,10 +333,30 @@ class _EllipticCurvePublicKey(ec.EllipticCurvePublicKey):
             assert format is serialization.PublicFormat.UncompressedPoint
             conversion = self._backend._lib.POINT_CONVERSION_UNCOMPRESSED
 
-        group = self._backend._lib.EC_KEY_get0_group(self._ec_key)
-        self._backend.openssl_assert(group != self._backend._ffi.NULL)
-        point = self._backend._lib.EC_KEY_get0_public_key(self._ec_key)
+        _, group = self._backend._ec_key_determine_group_get_func(
+            self._evp_pkey
+        )
+
+        buflen = self._backend._ffi.new("size_t *")
+        res = self._backend._lib.EVP_PKEY_get_octet_string_param(
+            self._evp_pkey, b"pub", self._backend._ffi.NULL, 0, buflen
+        )
+        self._backend.openssl_assert(res == 1)
+        buf = self._backend._ffi.new("unsigned char[]", buflen[0])
+        res = self._backend._lib.EVP_PKEY_get_octet_string_param(
+            self._evp_pkey, b"pub", buf, buflen[0], buflen
+        )
+        self._backend.openssl_assert(res == 1)
+
+        point = self._backend._lib.EC_POINT_new(group)
         self._backend.openssl_assert(point != self._backend._ffi.NULL)
+        point = self._backend._ffi.gc(point, self._backend._lib.EC_POINT_free)
+
+        res = self._backend._lib.EC_POINT_oct2point(
+            group, point, buf, buflen[0], self._backend._ffi.NULL
+        )
+        self._backend.openssl_assert(res == 1)
+
         with self._backend._tmp_bn_ctx() as bn_ctx:
             buflen = self._backend._lib.EC_POINT_point2oct(
                 group, point, conversion, self._backend._ffi.NULL, 0, bn_ctx
@@ -298,7 +392,7 @@ class _EllipticCurvePublicKey(ec.EllipticCurvePublicKey):
             return self._encode_point(format)
         else:
             return self._backend._public_key_bytes(
-                encoding, format, self, self._evp_pkey, None
+                encoding, format, self, self._evp_pkey
             )
 
     def verify(
diff --git a/src/cryptography/hazmat/backends/openssl/ed25519.py b/src/cryptography/hazmat/backends/openssl/ed25519.py
index 6f393e5b6..8104cbafe 100644
--- a/src/cryptography/hazmat/backends/openssl/ed25519.py
+++ b/src/cryptography/hazmat/backends/openssl/ed25519.py
@@ -42,7 +42,7 @@ class _Ed25519PublicKey(Ed25519PublicKey):
             return self._raw_public_bytes()
 
         return self._backend._public_key_bytes(
-            encoding, format, self, self._evp_pkey, None
+            encoding, format, self, self._evp_pkey
         )
 
     def _raw_public_bytes(self) -> bytes:
@@ -141,7 +141,7 @@ class _Ed25519PrivateKey(Ed25519PrivateKey):
             return self._raw_private_bytes()
 
         return self._backend._private_key_bytes(
-            encoding, format, encryption_algorithm, self, self._evp_pkey, None
+            encoding, format, encryption_algorithm, self, self._evp_pkey
         )
 
     def _raw_private_bytes(self) -> bytes:
diff --git a/src/cryptography/hazmat/backends/openssl/ed448.py b/src/cryptography/hazmat/backends/openssl/ed448.py
index 0d27ea638..e5fc43c1c 100644
--- a/src/cryptography/hazmat/backends/openssl/ed448.py
+++ b/src/cryptography/hazmat/backends/openssl/ed448.py
@@ -43,7 +43,7 @@ class _Ed448PublicKey(Ed448PublicKey):
             return self._raw_public_bytes()
 
         return self._backend._public_key_bytes(
-            encoding, format, self, self._evp_pkey, None
+            encoding, format, self, self._evp_pkey
         )
 
     def _raw_public_bytes(self) -> bytes:
@@ -142,7 +142,7 @@ class _Ed448PrivateKey(Ed448PrivateKey):
             return self._raw_private_bytes()
 
         return self._backend._private_key_bytes(
-            encoding, format, encryption_algorithm, self, self._evp_pkey, None
+            encoding, format, encryption_algorithm, self, self._evp_pkey
         )
 
     def _raw_private_bytes(self) -> bytes:
diff --git a/src/cryptography/hazmat/backends/openssl/hmac.py b/src/cryptography/hazmat/backends/openssl/hmac.py
index ba3dfb53f..135e5aeae 100644
--- a/src/cryptography/hazmat/backends/openssl/hmac.py
+++ b/src/cryptography/hazmat/backends/openssl/hmac.py
@@ -27,9 +27,6 @@ class _HMACContext(hashes.HashContext):
         self._backend = backend
 
         if ctx is None:
-            ctx = self._backend._lib.HMAC_CTX_new()
-            self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
-            ctx = self._backend._ffi.gc(ctx, self._backend._lib.HMAC_CTX_free)
             evp_md = self._backend._evp_md_from_algorithm(algorithm)
             if evp_md == self._backend._ffi.NULL:
                 raise UnsupportedAlgorithm(
@@ -38,11 +35,42 @@ class _HMACContext(hashes.HashContext):
                     ),
                     _Reasons.UNSUPPORTED_HASH,
                 )
+            md_name = self._backend._lib.EVP_MD_name(evp_md)
+
+            evp_mac = self._backend._lib.EVP_MAC_fetch(
+                self._backend._ffi.NULL,
+                b"HMAC",
+                self._backend._ffi.NULL
+            )
+            self._backend.openssl_assert(evp_mac != self._backend._ffi.NULL)
+            evp_mac = self._backend._ffi.gc(
+                evp_mac, self._backend._lib.EVP_MAC_free
+            )
+
+            ctx = self._backend._lib.EVP_MAC_CTX_new(evp_mac)
+            self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
+            ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_MAC_CTX_free)
+
+            bld = self._backend._lib.OSSL_PARAM_BLD_new();
+            self._backend.openssl_assert(bld != self._backend._ffi.NULL)
+            bld = self._backend._ffi.gc(bld, self._backend._lib.OSSL_PARAM_BLD_free)
+
+            res = self._backend._lib.OSSL_PARAM_BLD_push_utf8_string(
+                bld, b"digest", md_name, 0
+            )
+            self._backend.openssl_assert(res == 1);
+
+            params = self._backend._lib.OSSL_PARAM_BLD_to_param(bld)
+            self._backend.openssl_assert(params != self._backend._ffi.NULL)
+            params = self._backend._ffi.gc(
+                params, self._backend._lib.OSSL_PARAM_free
+            )
+
             key_ptr = self._backend._ffi.from_buffer(key)
-            res = self._backend._lib.HMAC_Init_ex(
-                ctx, key_ptr, len(key), evp_md, self._backend._ffi.NULL
+            res = self._backend._lib.EVP_MAC_init(
+                ctx, key_ptr, len(key), params
             )
-            self._backend.openssl_assert(res != 0)
+            self._backend.openssl_assert(res == 1)
 
         self._ctx = ctx
         self._key = key
@@ -52,29 +80,29 @@ class _HMACContext(hashes.HashContext):
         return self._algorithm
 
     def copy(self) -> "_HMACContext":
-        copied_ctx = self._backend._lib.HMAC_CTX_new()
+        copied_ctx = self._backend._lib.EVP_MAC_CTX_dup(self._ctx)
         self._backend.openssl_assert(copied_ctx != self._backend._ffi.NULL)
         copied_ctx = self._backend._ffi.gc(
-            copied_ctx, self._backend._lib.HMAC_CTX_free
+            copied_ctx, self._backend._lib.EVP_MAC_CTX_free
         )
-        res = self._backend._lib.HMAC_CTX_copy(copied_ctx, self._ctx)
-        self._backend.openssl_assert(res != 0)
         return _HMACContext(
             self._backend, self._key, self.algorithm, ctx=copied_ctx
         )
 
     def update(self, data: bytes) -> None:
         data_ptr = self._backend._ffi.from_buffer(data)
-        res = self._backend._lib.HMAC_Update(self._ctx, data_ptr, len(data))
-        self._backend.openssl_assert(res != 0)
+        res = self._backend._lib.EVP_MAC_update(self._ctx, data_ptr, len(data))
+        self._backend.openssl_assert(res == 1)
 
     def finalize(self) -> bytes:
         buf = self._backend._ffi.new(
             "unsigned char[]", self._backend._lib.EVP_MAX_MD_SIZE
         )
-        outlen = self._backend._ffi.new("unsigned int *")
-        res = self._backend._lib.HMAC_Final(self._ctx, buf, outlen)
-        self._backend.openssl_assert(res != 0)
+        outlen = self._backend._ffi.new("size_t *")
+        res = self._backend._lib.EVP_MAC_final(
+            self._ctx, buf, outlen, self._backend._lib.EVP_MAX_MD_SIZE
+        )
+        self._backend.openssl_assert(res == 1)
         self._backend.openssl_assert(outlen[0] == self.algorithm.digest_size)
         return self._backend._ffi.buffer(buf)[: outlen[0]]
 
diff --git a/src/cryptography/hazmat/backends/openssl/rsa.py b/src/cryptography/hazmat/backends/openssl/rsa.py
index e18bab3ff..ab0546e58 100644
--- a/src/cryptography/hazmat/backends/openssl/rsa.py
+++ b/src/cryptography/hazmat/backends/openssl/rsa.py
@@ -360,13 +360,11 @@ def _rsa_sig_recover(
 
 class _RSAPrivateKey(RSAPrivateKey):
     _evp_pkey: object
-    _rsa_cdata: object
     _key_size: int
 
     def __init__(
         self,
         backend: "Backend",
-        rsa_cdata,
         evp_pkey,
         *,
         unsafe_skip_rsa_key_validation: bool,
@@ -378,7 +376,10 @@ class _RSAPrivateKey(RSAPrivateKey):
         # added an init arg that allows skipping the checks. You should not
         # use this in production code unless you understand the consequences.
         if not unsafe_skip_rsa_key_validation:
-            res = backend._lib.RSA_check_key(rsa_cdata)
+            pkey_ctx = backend._lib.EVP_PKEY_CTX_new(evp_pkey, backend._ffi.NULL)
+            backend.openssl_assert(pkey_ctx != backend._ffi.NULL)
+            pkey_ctx = backend._ffi.gc(pkey_ctx, backend._lib.EVP_PKEY_CTX_free)
+            res = backend._lib.EVP_PKEY_check(pkey_ctx)
             if res != 1:
                 errors = backend._consume_errors_with_text()
                 raise ValueError("Invalid private key", errors)
@@ -386,31 +387,28 @@ class _RSAPrivateKey(RSAPrivateKey):
             # if p and q are odd just to be safe.
             p = backend._ffi.new("BIGNUM **")
             q = backend._ffi.new("BIGNUM **")
-            backend._lib.RSA_get0_factors(rsa_cdata, p, q)
+            p[0] = backend._ffi.NULL
+            q[0] = backend._ffi.NULL
+            res = backend._lib.EVP_PKEY_get_bn_param(evp_pkey, b"rsa-factor1", p)
+            backend.openssl_assert(res == 1)
+            res = backend._lib.EVP_PKEY_get_bn_param(evp_pkey, b"rsa-factor2", q)
+            backend.openssl_assert(res == 1)
             backend.openssl_assert(p[0] != backend._ffi.NULL)
             backend.openssl_assert(q[0] != backend._ffi.NULL)
-            p_odd = backend._lib.BN_is_odd(p[0])
-            q_odd = backend._lib.BN_is_odd(q[0])
+            p_val = backend._ffi.gc(p[0], backend._lib.BN_free)
+            q_val = backend._ffi.gc(q[0], backend._lib.BN_free)
+            p_odd = backend._lib.BN_is_odd(p_val)
+            q_odd = backend._lib.BN_is_odd(q_val)
             if p_odd != 1 or q_odd != 1:
                 errors = backend._consume_errors_with_text()
                 raise ValueError("Invalid private key", errors)
 
         self._backend = backend
-        self._rsa_cdata = rsa_cdata
         self._evp_pkey = evp_pkey
         # Used for lazy blinding
         self._blinded = False
         self._blinding_lock = threading.Lock()
-
-        n = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.RSA_get0_key(
-            self._rsa_cdata,
-            n,
-            self._backend._ffi.NULL,
-            self._backend._ffi.NULL,
-        )
-        self._backend.openssl_assert(n[0] != self._backend._ffi.NULL)
-        self._key_size = self._backend._lib.BN_num_bits(n[0])
+        self._key_size = self._backend._lib.EVP_PKEY_bits(evp_pkey)
 
     def _enable_blinding(self) -> None:
         # If you call blind on an already blinded RSA key OpenSSL will turn
@@ -425,10 +423,15 @@ class _RSAPrivateKey(RSAPrivateKey):
         # Check if it's not True again in case another thread raced past the
         # first non-locked check.
         if not self._blinded:
-            res = self._backend._lib.RSA_blinding_on(
-                self._rsa_cdata, self._backend._ffi.NULL
-            )
-            self._backend.openssl_assert(res == 1)
+            if not self._backend._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
+                rsa_cdata = self._backend.EVP_PKEY_get0_RSA(self._evp_pkey)
+                self._backend.openssl_assert(
+                    rsa_cdata != self._backend._ffi.NULL
+                )
+                res = self._backend._lib.RSA_blinding_on(
+                    rsa_cdata, self._backend._ffi.NULL
+                )
+                self._backend.openssl_assert(res == 1)
             self._blinded = True
 
     @property
@@ -444,44 +447,84 @@ class _RSAPrivateKey(RSAPrivateKey):
         return _enc_dec_rsa(self._backend, self, ciphertext, padding)
 
     def public_key(self) -> RSAPublicKey:
-        ctx = self._backend._lib.RSAPublicKey_dup(self._rsa_cdata)
+        pparams = self._backend._ffi.new("OSSL_PARAM **")
+        res = self._backend._lib.EVP_PKEY_todata(
+            self._evp_pkey, self._backend._lib.EVP_PKEY_PUBLIC_KEY, pparams
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(pparams[0] != self._backend._ffi.NULL)
+
+        params = self._backend._ffi.gc(
+            pparams[0], self._backend._lib.OSSL_PARAM_free
+        )
+
+        ctx = self._backend._lib.EVP_PKEY_CTX_new_id(
+            self._backend._lib.EVP_PKEY_RSA, self._backend._ffi.NULL
+        )
         self._backend.openssl_assert(ctx != self._backend._ffi.NULL)
-        ctx = self._backend._ffi.gc(ctx, self._backend._lib.RSA_free)
-        evp_pkey = self._backend._rsa_cdata_to_evp_pkey(ctx)
-        return _RSAPublicKey(self._backend, ctx, evp_pkey)
+        ctx = self._backend._ffi.gc(ctx, self._backend._lib.EVP_PKEY_CTX_free)
 
-    def private_numbers(self) -> RSAPrivateNumbers:
-        n = self._backend._ffi.new("BIGNUM **")
-        e = self._backend._ffi.new("BIGNUM **")
-        d = self._backend._ffi.new("BIGNUM **")
-        p = self._backend._ffi.new("BIGNUM **")
-        q = self._backend._ffi.new("BIGNUM **")
-        dmp1 = self._backend._ffi.new("BIGNUM **")
-        dmq1 = self._backend._ffi.new("BIGNUM **")
-        iqmp = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.RSA_get0_key(self._rsa_cdata, n, e, d)
-        self._backend.openssl_assert(n[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(e[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(d[0] != self._backend._ffi.NULL)
-        self._backend._lib.RSA_get0_factors(self._rsa_cdata, p, q)
-        self._backend.openssl_assert(p[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(q[0] != self._backend._ffi.NULL)
-        self._backend._lib.RSA_get0_crt_params(
-            self._rsa_cdata, dmp1, dmq1, iqmp
+        res = self._backend._lib.EVP_PKEY_fromdata_init(ctx)
+        self._backend.openssl_assert(res == 1)
+
+        ppub_key = self._backend._ffi.new("EVP_PKEY **")
+        res = self._backend._lib.EVP_PKEY_fromdata(
+            ctx, ppub_key, self._backend._lib.EVP_PKEY_PUBLIC_KEY, params
+        )
+        self._backend.openssl_assert(res == 1)
+        self._backend.openssl_assert(ppub_key[0] != self._backend._ffi.NULL)
+
+        pub_key = self._backend._ffi.gc(
+            ppub_key[0], self._backend._lib.EVP_PKEY_free
         )
-        self._backend.openssl_assert(dmp1[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(dmq1[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(iqmp[0] != self._backend._ffi.NULL)
+
+        return _RSAPublicKey(self._backend, pub_key)
+
+    def private_numbers(self) -> RSAPrivateNumbers:
+        pn = self._backend._ffi.new("BIGNUM **")
+        pe = self._backend._ffi.new("BIGNUM **")
+        pd = self._backend._ffi.new("BIGNUM **")
+        pp = self._backend._ffi.new("BIGNUM **")
+        pq = self._backend._ffi.new("BIGNUM **")
+        pdmp1 = self._backend._ffi.new("BIGNUM **")
+        pdmq1 = self._backend._ffi.new("BIGNUM **")
+        piqmp = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [
+            (b"n", pn),
+            (b"e", pe),
+            (b"d", pd),
+            (b"rsa-factor1", pp),
+            (b"rsa-factor2", pq),
+            (b"rsa-exponent1", pdmp1),
+            (b"rsa-exponent2", pdmq1),
+            (b"rsa-coefficient1", piqmp),
+        ]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            self._backend.openssl_assert(res == 1)
+            self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+
+        n = self._backend._ffi.gc(pn[0], self._backend._lib.BN_free)
+        e = self._backend._ffi.gc(pe[0], self._backend._lib.BN_free)
+        d = self._backend._ffi.gc(pd[0], self._backend._lib.BN_free)
+        p = self._backend._ffi.gc(pp[0], self._backend._lib.BN_free)
+        q = self._backend._ffi.gc(pq[0], self._backend._lib.BN_free)
+        dmp1 = self._backend._ffi.gc(pdmp1[0], self._backend._lib.BN_free)
+        dmq1 = self._backend._ffi.gc(pdmq1[0], self._backend._lib.BN_free)
+        iqmp = self._backend._ffi.gc(piqmp[0], self._backend._lib.BN_free)
         return RSAPrivateNumbers(
-            p=self._backend._bn_to_int(p[0]),
-            q=self._backend._bn_to_int(q[0]),
-            d=self._backend._bn_to_int(d[0]),
-            dmp1=self._backend._bn_to_int(dmp1[0]),
-            dmq1=self._backend._bn_to_int(dmq1[0]),
-            iqmp=self._backend._bn_to_int(iqmp[0]),
+            p=self._backend._bn_to_int(p),
+            q=self._backend._bn_to_int(q),
+            d=self._backend._bn_to_int(d),
+            dmp1=self._backend._bn_to_int(dmp1),
+            dmq1=self._backend._bn_to_int(dmq1),
+            iqmp=self._backend._bn_to_int(iqmp),
             public_numbers=RSAPublicNumbers(
-                e=self._backend._bn_to_int(e[0]),
-                n=self._backend._bn_to_int(n[0]),
+                e=self._backend._bn_to_int(e),
+                n=self._backend._bn_to_int(n),
             ),
         )
 
@@ -497,7 +540,6 @@ class _RSAPrivateKey(RSAPrivateKey):
             encryption_algorithm,
             self,
             self._evp_pkey,
-            self._rsa_cdata,
         )
 
     def sign(
@@ -513,23 +555,12 @@ class _RSAPrivateKey(RSAPrivateKey):
 
 class _RSAPublicKey(RSAPublicKey):
     _evp_pkey: object
-    _rsa_cdata: object
     _key_size: int
 
-    def __init__(self, backend: "Backend", rsa_cdata, evp_pkey):
+    def __init__(self, backend: "Backend", evp_pkey):
         self._backend = backend
-        self._rsa_cdata = rsa_cdata
         self._evp_pkey = evp_pkey
-
-        n = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.RSA_get0_key(
-            self._rsa_cdata,
-            n,
-            self._backend._ffi.NULL,
-            self._backend._ffi.NULL,
-        )
-        self._backend.openssl_assert(n[0] != self._backend._ffi.NULL)
-        self._key_size = self._backend._lib.BN_num_bits(n[0])
+        self._key_size = self._backend._lib.EVP_PKEY_bits(evp_pkey)
 
     @property
     def key_size(self) -> int:
@@ -539,16 +570,21 @@ class _RSAPublicKey(RSAPublicKey):
         return _enc_dec_rsa(self._backend, self, plaintext, padding)
 
     def public_numbers(self) -> RSAPublicNumbers:
-        n = self._backend._ffi.new("BIGNUM **")
-        e = self._backend._ffi.new("BIGNUM **")
-        self._backend._lib.RSA_get0_key(
-            self._rsa_cdata, n, e, self._backend._ffi.NULL
-        )
-        self._backend.openssl_assert(n[0] != self._backend._ffi.NULL)
-        self._backend.openssl_assert(e[0] != self._backend._ffi.NULL)
+        pn = self._backend._ffi.new("BIGNUM **")
+        pe = self._backend._ffi.new("BIGNUM **")
+
+        for key, pbn in [(b"n", pn), (b"e", pe)]:
+            pbn[0] = self._backend._ffi.NULL
+            res = self._backend._lib.EVP_PKEY_get_bn_param(
+                self._evp_pkey, key, pbn
+            )
+            self._backend.openssl_assert(res == 1)
+            self._backend.openssl_assert(pbn[0] != self._backend._ffi.NULL)
+        n = self._backend._ffi.gc(pn[0], self._backend._lib.BN_free)
+        e = self._backend._ffi.gc(pe[0], self._backend._lib.BN_free)
         return RSAPublicNumbers(
-            e=self._backend._bn_to_int(e[0]),
-            n=self._backend._bn_to_int(n[0]),
+            e=self._backend._bn_to_int(e),
+            n=self._backend._bn_to_int(n),
         )
 
     def public_bytes(
@@ -557,7 +593,7 @@ class _RSAPublicKey(RSAPublicKey):
         format: serialization.PublicFormat,
     ) -> bytes:
         return self._backend._public_key_bytes(
-            encoding, format, self, self._evp_pkey, self._rsa_cdata
+            encoding, format, self, self._evp_pkey
         )
 
     def verify(
diff --git a/src/cryptography/hazmat/backends/openssl/x25519.py b/src/cryptography/hazmat/backends/openssl/x25519.py
index e3b41eced..88b8d8fff 100644
--- a/src/cryptography/hazmat/backends/openssl/x25519.py
+++ b/src/cryptography/hazmat/backends/openssl/x25519.py
@@ -43,12 +43,12 @@ class _X25519PublicKey(X25519PublicKey):
             return self._raw_public_bytes()
 
         return self._backend._public_key_bytes(
-            encoding, format, self, self._evp_pkey, None
+            encoding, format, self, self._evp_pkey
         )
 
     def _raw_public_bytes(self) -> bytes:
         ucharpp = self._backend._ffi.new("unsigned char **")
-        res = self._backend._lib.EVP_PKEY_get1_tls_encodedpoint(
+        res = self._backend._lib.EVP_PKEY_get1_encoded_public_key(
             self._evp_pkey, ucharpp
         )
         self._backend.openssl_assert(res == 32)
@@ -108,7 +108,7 @@ class _X25519PrivateKey(X25519PrivateKey):
             return self._raw_private_bytes()
 
         return self._backend._private_key_bytes(
-            encoding, format, encryption_algorithm, self, self._evp_pkey, None
+            encoding, format, encryption_algorithm, self, self._evp_pkey
         )
 
     def _raw_private_bytes(self) -> bytes:
diff --git a/src/cryptography/hazmat/backends/openssl/x448.py b/src/cryptography/hazmat/backends/openssl/x448.py
index d738188c7..19cc0e5b6 100644
--- a/src/cryptography/hazmat/backends/openssl/x448.py
+++ b/src/cryptography/hazmat/backends/openssl/x448.py
@@ -42,7 +42,7 @@ class _X448PublicKey(X448PublicKey):
             return self._raw_public_bytes()
 
         return self._backend._public_key_bytes(
-            encoding, format, self, self._evp_pkey, None
+            encoding, format, self, self._evp_pkey
         )
 
     def _raw_public_bytes(self) -> bytes:
@@ -103,7 +103,7 @@ class _X448PrivateKey(X448PrivateKey):
             return self._raw_private_bytes()
 
         return self._backend._private_key_bytes(
-            encoding, format, encryption_algorithm, self, self._evp_pkey, None
+            encoding, format, encryption_algorithm, self, self._evp_pkey
         )
 
     def _raw_private_bytes(self) -> bytes:
diff --git a/src/cryptography/hazmat/bindings/openssl/_conditional.py b/src/cryptography/hazmat/bindings/openssl/_conditional.py
index 7903a9bb4..0756661e2 100644
--- a/src/cryptography/hazmat/bindings/openssl/_conditional.py
+++ b/src/cryptography/hazmat/bindings/openssl/_conditional.py
@@ -103,8 +103,8 @@ def cryptography_has_evp_digestfinal_xof() -> typing.List[str]:
 
 def cryptography_has_evp_pkey_get_set_tls_encodedpoint() -> typing.List[str]:
     return [
-        "EVP_PKEY_get1_tls_encodedpoint",
-        "EVP_PKEY_set1_tls_encodedpoint",
+        "EVP_PKEY_get1_encoded_public_key",
+        "EVP_PKEY_set1_encoded_public_key",
     ]
 
 
diff --git a/src/cryptography/hazmat/bindings/openssl/binding.py b/src/cryptography/hazmat/bindings/openssl/binding.py
index a1602164d..d7efd51cb 100644
--- a/src/cryptography/hazmat/bindings/openssl/binding.py
+++ b/src/cryptography/hazmat/bindings/openssl/binding.py
@@ -148,17 +148,18 @@ class Binding:
         # This function enables FIPS mode for OpenSSL 3.0.0 on installs that
         # have the FIPS provider installed properly.
         _openssl_assert(self.lib, self.lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER)
-        self._base_provider = self.lib.OSSL_PROVIDER_load(
-            self.ffi.NULL, b"base"
-        )
-        _openssl_assert(self.lib, self._base_provider != self.ffi.NULL)
-        self.lib._fips_provider = self.lib.OSSL_PROVIDER_load(
-            self.ffi.NULL, b"fips"
-        )
-        _openssl_assert(self.lib, self.lib._fips_provider != self.ffi.NULL)
+        if self.lib.EVP_default_properties_is_fips_enabled(self.ffi.NULL) == 0:
+            self._base_provider = self.lib.OSSL_PROVIDER_load(
+                self.ffi.NULL, b"base"
+            )
+            _openssl_assert(self.lib, self._base_provider != self.ffi.NULL)
+            self.lib._fips_provider = self.lib.OSSL_PROVIDER_load(
+                self.ffi.NULL, b"fips"
+            )
+            _openssl_assert(self.lib, self.lib._fips_provider != self.ffi.NULL)
 
-        res = self.lib.EVP_default_properties_enable_fips(self.ffi.NULL, 1)
-        _openssl_assert(self.lib, res == 1)
+            res = self.lib.EVP_default_properties_enable_fips(self.ffi.NULL, 1)
+            _openssl_assert(self.lib, res == 1)
 
     @classmethod
     def _register_osrandom_engine(cls) -> None:
@@ -185,7 +186,7 @@ class Binding:
                 # are ugly legacy, but we aren't going to get rid of them
                 # any time soon.
                 if cls.lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
-                    if not os.environ.get("CRYPTOGRAPHY_OPENSSL_NO_LEGACY"):
+                    if False:
                         cls._legacy_provider = cls.lib.OSSL_PROVIDER_load(
                             cls.ffi.NULL, b"legacy"
                         )
@@ -194,12 +195,12 @@ class Binding:
                         )
                         _legacy_provider_error(cls._legacy_provider_loaded)
 
-                    cls._default_provider = cls.lib.OSSL_PROVIDER_load(
-                        cls.ffi.NULL, b"default"
-                    )
-                    _openssl_assert(
-                        cls.lib, cls._default_provider != cls.ffi.NULL
-                    )
+                        cls._default_provider = cls.lib.OSSL_PROVIDER_load(
+                            cls.ffi.NULL, b"default"
+                        )
+                        _openssl_assert(
+                            cls.lib, cls._default_provider != cls.ffi.NULL
+                        )
 
     @classmethod
     def init_static_locks(cls) -> None:
