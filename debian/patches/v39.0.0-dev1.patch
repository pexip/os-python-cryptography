diff --git a/CHANGELOG.rst b/CHANGELOG.rst
index 7606ce745..1e22b2417 100644
--- a/CHANGELOG.rst
+++ b/CHANGELOG.rst
@@ -1,13 +1,68 @@
 Changelog
 =========
 
-.. _v38-0-2:
+.. _v39-0-0:
+
+39.0.0 - `main`_
+~~~~~~~~~~~~~~~~
+
+.. note:: This version is not yet released and is under active development.
+
+* **BACKWARDS INCOMPATIBLE:** Support for OpenSSL 1.1.0 has been removed.
+  Users on older version of OpenSSL will need to upgrade.
+* **BACKWARDS INCOMPATIBLE:** Dropped support for LibreSSL < 3.5. The new
+  minimum LibreSSL version is 3.5.0. Going forward our policy is to support
+  versions of LibreSSL that are available in versions of OpenBSD that are
+  still receiving security support.
+* **BACKWARDS INCOMPATIBLE:** Removed the ``encode_point`` and
+  ``from_encoded_point`` methods on
+  :class:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers`,
+  which had been deprecated for several years.
+  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.public_bytes`
+  and
+  :meth:`~cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey.from_encoded_point`
+  should be used instead.
+* **BACKWARDS INCOMPATIBLE:** Support for using MD5 or SHA1 in
+  :class:`~cryptography.x509.CertificateBuilder`, other X.509 builders, and
+  PKCS7 has been removed.
+* **BACKWARDS INCOMPATIBLE:** Dropped support for macOS 10.10 and 10.11, macOS
+  users must upgrade to 10.12 or newer.
+* Added support for
+  :ref:`disabling the legacy provider in OpenSSL 3.0.x<legacy-provider>`.
+* Added support for disabling RSA key validation checks when loading RSA
+  keys via
+  :func:`~cryptography.hazmat.primitives.serialization.load_pem_private_key`,
+  :func:`~cryptography.hazmat.primitives.serialization.load_der_private_key`,
+  and
+  :meth:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateNumbers.private_key`.
+  This speeds up key loading but is :term:`unsafe` if you are loading potentially
+  attacker supplied keys.
+* Significantly improved performance for
+  :class:`~cryptography.hazmat.primitives.ciphers.aead.ChaCha20Poly1305`
+  when repeatedly calling ``encrypt`` or ``decrypt`` with the same key.
+* Added support for creating OCSP requests with precomputed hashes using
+  :meth:`~cryptography.x509.ocsp.OCSPRequestBuilder.add_certificate_by_hash`.
+
+.. _v38-0-3:
 
-38.0.2 - 2022-10-11
+38.0.3 - 2022-11-01
 ~~~~~~~~~~~~~~~~~~~
 
+* Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.7,
+  which resolves *CVE-2022-3602* and *CVE-2022-3786*.
+
+.. _v38-0-2:
+
+38.0.2 - 2022-10-11 (YANKED)
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+.. attention::
+
+    This release was subsequently yanked from PyPI due to a regression in OpenSSL.
+
 * Updated Windows, macOS, and Linux wheels to be compiled with OpenSSL 3.0.6.
 
+
 .. _v38-0-1:
 
 38.0.1 - 2022-09-07
diff --git a/README.rst b/README.rst
index 9b260f5e4..19f1678b7 100644
--- a/README.rst
+++ b/README.rst
@@ -14,7 +14,7 @@ pyca/cryptography
 
 
 ``cryptography`` is a package which provides cryptographic recipes and
-primitives to Python developers.  Our goal is for it to be your "cryptographic
+primitives to Python developers. Our goal is for it to be your "cryptographic
 standard library". It supports Python 3.6+ and PyPy3 7.2+.
 
 ``cryptography`` includes both high level recipes and low level interfaces to
diff --git a/docs/conf.py b/docs/conf.py
index 0c38d4dbf..8dc36102b 100644
--- a/docs/conf.py
+++ b/docs/conf.py
@@ -197,14 +197,12 @@ linkcheck_retries = 10
 linkcheck_timeout = 5
 
 linkcheck_ignore = [
-    # Small DH key results in a TLS failure on modern OpenSSL
-    r"https://info.isl.ntt.co.jp/crypt/eng/camellia/",
     # Inconsistent small DH params they seem incapable of fixing
     r"https://www.secg.org/sec1-v2.pdf",
-    # Incomplete cert chain
+    # Cert is issued from an untrusted root
     r"https://e-trust.gosuslugi.ru",
-    # Expired cert (1 week at time of writing)
-    r"https://www.cosic.esat.kuleuven.be",
+    # Incomplete cert chain
+    r"https://www.oscca.gov.cn",
 ]
 
 autosectionlabel_prefix_document = True
diff --git a/docs/doing-a-release.rst b/docs/doing-a-release.rst
index 12d6bb063..c1571226e 100644
--- a/docs/doing-a-release.rst
+++ b/docs/doing-a-release.rst
@@ -82,18 +82,20 @@ the expected OpenSSL version.
 Post-release tasks
 ------------------
 
+* Send an email to the `mailing list`_ and `python-announce`_ announcing the
+  release.
+* Close the `milestone`_ for the previous release on GitHub.
+* For major version releases, send a pull request to pyOpenSSL increasing the
+  maximum ``cryptography`` version pin and perform a pyOpenSSL release.
 * Update the version number to the next major (e.g. ``0.5.dev1``) in
   ``src/cryptography/__about__.py`` and
   ``vectors/cryptography_vectors/__about__.py``.
-* Close the `milestone`_ for the previous release on GitHub.
 * Add new :doc:`/changelog` entry with next version and note that it is under
   active development
 * Send a pull request with these items
 * Check for any outstanding code undergoing a deprecation cycle by looking in
   ``cryptography.utils`` for ``DeprecatedIn**`` definitions. If any exist open
   a ticket to increment them for the next release.
-* Send an email to the `mailing list`_ and `python-announce`_ announcing the
-  release.
 
 .. _`CVE from MITRE`: https://cveform.mitre.org/
 .. _`oss-security`: https://www.openwall.com/lists/oss-security/
diff --git a/docs/faq.rst b/docs/faq.rst
index f9f35c149..a52034569 100644
--- a/docs/faq.rst
+++ b/docs/faq.rst
@@ -111,14 +111,14 @@ earlier the default compiler is extremely old. Use ``pkg_add`` to install a
 newer ``gcc`` and then install ``cryptography`` using
 ``CC=/path/to/newer/gcc pip install cryptography``.
 
-Installing cryptography with OpenSSL 0.9.8, 1.0.0, 1.0.1, 1.0.2 fails
----------------------------------------------------------------------
+Installing cryptography with OpenSSL 0.9.8, 1.0.0, 1.0.1, 1.0.2, 1.1.0 fails
+----------------------------------------------------------------------------
 
-The OpenSSL project has dropped support for the 0.9.8, 1.0.0, 1.0.1, and 1.0.2
-release series. Since they are no longer receiving security patches from
-upstream, ``cryptography`` is also dropping support for them. To fix this issue
-you should upgrade to a newer version of OpenSSL (1.1.0 or later). This may
-require you to upgrade to a newer operating system.
+The OpenSSL project has dropped support for the 0.9.8, 1.0.0, 1.0.1, 1.0.2,
+and 1.1.0 release series. Since they are no longer receiving security patches
+from upstream, ``cryptography`` is also dropping support for them. To fix this
+issue you should upgrade to a newer version of OpenSSL (1.1.1 or later). This
+may require you to upgrade to a newer operating system.
 
 Installing ``cryptography`` fails with ``error: Can not find Rust compiler``
 ----------------------------------------------------------------------------
@@ -185,6 +185,7 @@ For example, this is a PEM file for a RSA Public Key: ::
 
 What happened to the backend argument?
 --------------------------------------
+
 ``cryptography`` stopped requiring the use of ``backend`` arguments in
 version 3.1 and deprecated their use in version 36.0. If you are on an older
 version that requires these arguments please view the appropriate documentation
@@ -194,6 +195,24 @@ Note that for forward compatibility ``backend`` is still silently accepted by
 functions that previously required it, but it is ignored and no longer
 documented.
 
+Will you upload wheels for my non-x86 non-ARM64 CPU architecture?
+-----------------------------------------------------------------
+
+Maybe! But there's some pre-requisites. For us to build wheels and upload them
+to PyPI, we consider it necessary to run our tests for that architecture as a
+part of our CI (i.e. for every commit). If we don't run the tests, it's hard
+to have confidence that everything works -- particularly with cryptography,
+which frequently employs per-architecture assembly code.
+
+For us to add something to CI we need a provider which offers builds on that
+architecture, which integrate into our workflows, has sufficient capacity, and
+performs well enough not to regress the contributor experience. We don't think
+this is an insurmountable bar, but it's also not one that can be cleared
+lightly.
+
+If you are interested in helping support a new CPU architecture, we encourage
+you to reach out, discuss, and contribute that support. We will attempt to be
+supportive, but we cannot commit to doing the work ourselves.
 
 .. _`NaCl`: https://nacl.cr.yp.to/
 .. _`PyNaCl`: https://pynacl.readthedocs.io
diff --git a/docs/glossary.rst b/docs/glossary.rst
index b85a61091..0fa40245d 100644
--- a/docs/glossary.rst
+++ b/docs/glossary.rst
@@ -100,6 +100,11 @@ Glossary
         name. U-labels use unicode characters outside the ASCII range and
         are encoded as A-labels when stored in certificates.
 
+    unsafe
+        This is a term used to describe an operation where the user must
+        ensure that the input is correct. Failure to do so can result in
+        crashes, hangs, and other security issues.
+
 .. _`hardware security module`: https://en.wikipedia.org/wiki/Hardware_security_module
 .. _`idna`: https://pypi.org/project/idna/
 .. _`buffer protocol`: https://docs.python.org/3/c-api/buffer.html
diff --git a/docs/hazmat/primitives/asymmetric/rsa.rst b/docs/hazmat/primitives/asymmetric/rsa.rst
index d21cb8012..384cab073 100644
--- a/docs/hazmat/primitives/asymmetric/rsa.rst
+++ b/docs/hazmat/primitives/asymmetric/rsa.rst
@@ -473,7 +473,21 @@ is unavailable.
         A `Chinese remainder theorem`_ coefficient used to speed up RSA
         operations. Calculated as: q\ :sup:`-1` mod p
 
-    .. method:: private_key()
+    .. method:: private_key(*, unsafe_skip_rsa_key_validation=False)
+
+        :param unsafe_skip_rsa_key_validation:
+
+            .. versionadded:: 39.0.0
+
+            A keyword-only argument that defaults to ``False``. If ``True``
+            RSA private keys will not be validated. This significantly speeds up
+            loading the keys, but is is :term:`unsafe` unless you are certain
+            the key is valid. User supplied keys should never be loaded with
+            this parameter set to ``True``. If you do load an invalid key this
+            way and attempt to use it OpenSSL may hang, crash, or otherwise
+            misbehave.
+
+        :type unsafe_skip_rsa_key_validation: bool
 
         :returns: An instance of
             :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`.
@@ -541,6 +555,11 @@ Key interfaces
 
         .. versionadded:: 0.4
 
+        .. warning::
+
+            Our implementation of PKCS1 v1.5 decryption is not constant time. See
+            :doc:`/limitations` for details.
+
         Decrypt data that was encrypted with the public key.
 
         :param bytes ciphertext: The ciphertext to decrypt.
diff --git a/docs/hazmat/primitives/asymmetric/serialization.rst b/docs/hazmat/primitives/asymmetric/serialization.rst
index db3271b90..b60102047 100644
--- a/docs/hazmat/primitives/asymmetric/serialization.rst
+++ b/docs/hazmat/primitives/asymmetric/serialization.rst
@@ -125,7 +125,7 @@ all begin with ``-----BEGIN {format}-----`` and end with ``-----END
     extract the public key with
     :meth:`Certificate.public_key <cryptography.x509.Certificate.public_key>`.
 
-.. function:: load_pem_private_key(data, password)
+.. function:: load_pem_private_key(data, password, *, unsafe_skip_rsa_key_validation=False)
 
     .. versionadded:: 0.6
 
@@ -141,7 +141,20 @@ all begin with ``-----BEGIN {format}-----`` and end with ``-----END
 
     :param password: The password to use to decrypt the data. Should
         be ``None`` if the private key is not encrypted.
-    :type data: :term:`bytes-like`
+    :type password: :term:`bytes-like`
+
+    :param unsafe_skip_rsa_key_validation:
+
+        .. versionadded:: 39.0.0
+
+        A keyword-only argument that defaults to ``False``. If ``True``
+        RSA private keys will not be validated. This significantly speeds up
+        loading the keys, but is is :term:`unsafe` unless you are certain the
+        key is valid. User supplied keys should never be loaded with this
+        parameter set to ``True``. If you do load an invalid key this way and
+        attempt to use it OpenSSL may hang, crash, or otherwise misbehave.
+
+    :type unsafe_skip_rsa_key_validation: bool
 
     :returns: One of
         :class:`~cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey`,
@@ -234,7 +247,7 @@ data is binary. DER keys may be in a variety of formats, but as long as you
 know whether it is a public or private key the loading functions will handle
 the rest.
 
-.. function:: load_der_private_key(data, password)
+.. function:: load_der_private_key(data, password, *, unsafe_skip_rsa_key_validation=False)
 
     .. versionadded:: 0.8
 
@@ -248,6 +261,19 @@ the rest.
         be ``None`` if the private key is not encrypted.
     :type password: :term:`bytes-like`
 
+    :param unsafe_skip_rsa_key_validation:
+
+        .. versionadded:: 39.0.0
+
+        A keyword-only argument that defaults to ``False``. If ``True``
+        RSA private keys will not be validated. This significantly speeds up
+        loading the keys, but is is :term:`unsafe` unless you are certain the
+        key is valid. User supplied keys should never be loaded with this
+        parameter set to ``True``. If you do load an invalid key this way and
+        attempt to use it OpenSSL may hang, crash, or otherwise misbehave.
+
+    :type unsafe_skip_rsa_key_validation: bool
+
     :returns: One of
         :class:`~cryptography.hazmat.primitives.asymmetric.ed25519.Ed25519PrivateKey`,
         :class:`~cryptography.hazmat.primitives.asymmetric.x25519.X25519PrivateKey`,
diff --git a/docs/hazmat/primitives/cryptographic-hashes.rst b/docs/hazmat/primitives/cryptographic-hashes.rst
index 572822e40..b6c889df4 100644
--- a/docs/hazmat/primitives/cryptographic-hashes.rst
+++ b/docs/hazmat/primitives/cryptographic-hashes.rst
@@ -117,7 +117,7 @@ SHA-family of hashes.
 .. note::
 
     While the RFC specifies keying, personalization, and salting features,
-    these are not supported at this time due to limitations in OpenSSL 1.1.0.
+    these are not supported at this time due to limitations in OpenSSL.
 
 .. class:: BLAKE2b(digest_size)
 
@@ -292,5 +292,5 @@ Interfaces
 .. _`Lifetimes of cryptographic hash functions`: https://valerieaurora.org/hash.html
 .. _`BLAKE2`: https://blake2.net
 .. _`length-extension attacks`: https://en.wikipedia.org/wiki/Length_extension_attack
-.. _`GM/T 0004-2012`: http://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002389/files/302a3ada057c4a73830536d03e683110.pdf
+.. _`GM/T 0004-2012`: https://www.oscca.gov.cn/sca/xxgk/2010-12/17/1002389/files/302a3ada057c4a73830536d03e683110.pdf
 .. _`draft-sca-cfrg-sm3`: https://datatracker.ietf.org/doc/html/draft-sca-cfrg-sm3
diff --git a/docs/hazmat/primitives/symmetric-encryption.rst b/docs/hazmat/primitives/symmetric-encryption.rst
index ec17e731c..2bf7a88cb 100644
--- a/docs/hazmat/primitives/symmetric-encryption.rst
+++ b/docs/hazmat/primitives/symmetric-encryption.rst
@@ -152,7 +152,9 @@ Algorithms
         nonce with the same key compromises the security of every message
         encrypted with that key. The nonce does not need to be kept secret
         and may be included with the ciphertext. This must be ``128``
-        :term:`bits` in length.
+        :term:`bits` in length. The 128-bit value is a concatenation of 4-byte
+        little-endian counter and the 12-byte nonce (as described in
+        :rfc:`7539`).
     :type nonce: :term:`bytes-like`
 
         .. note::
@@ -618,8 +620,6 @@ Interfaces
             into. This buffer should be ``len(data) + n - 1`` bytes where ``n``
             is the block size (in bytes) of the cipher and mode combination.
         :return int: Number of bytes written.
-        :raises NotImplementedError: This is raised if the version of ``cffi``
-            used is too old (this can happen on older PyPy releases).
         :raises ValueError: This is raised if the supplied buffer is too small.
 
         .. doctest::
diff --git a/docs/installation.rst b/docs/installation.rst
index 361ed5a07..145376f1b 100644
--- a/docs/installation.rst
+++ b/docs/installation.rst
@@ -22,7 +22,7 @@ operating systems.
 * ARM64 macOS 12 Monterey
 * x86-64 Ubuntu 18.04, 20.04, 22.04, rolling
 * ARM64 Ubuntu 20.04
-* x86-64 Debian Stretch (9.x), Buster (10.x), Bullseye (11.x), Bookworm (12.x)
+* x86-64 Debian Buster (10.x), Bullseye (11.x), Bookworm (12.x)
   and Sid (unstable)
 * x86-64 Alpine (latest)
 * ARM64 Alpine (latest)
@@ -31,16 +31,12 @@ operating systems.
 We test compiling with ``clang`` as well as ``gcc`` and use the following
 OpenSSL releases:
 
-* ``OpenSSL 1.1.0-latest``
 * ``OpenSSL 1.1.1-latest``
 * ``OpenSSL 3.0-latest``
 
-In addition we test against several versions of LibreSSL and the latest commit
-in BoringSSL.
-
-.. warning::
-
-    Cryptography 37.0.0 has deprecated support for OpenSSL 1.1.0.
+In addition we test against versions of LibreSSL that are available in
+versions of OpenBSD that are receiving security support at the time of a given
+``cryptography`` release, and the latest commit in BoringSSL.
 
 
 Building cryptography on Windows
@@ -274,8 +270,8 @@ To build cryptography and dynamically link it:
 
 .. code-block:: console
 
-    $ brew install openssl@1.1 rust
-    $ env LDFLAGS="-L$(brew --prefix openssl@1.1)/lib" CFLAGS="-I$(brew --prefix openssl@1.1)/include" pip install cryptography
+    $ brew install openssl@3 rust
+    $ env LDFLAGS="-L$(brew --prefix openssl@3)/lib" CFLAGS="-I$(brew --prefix openssl@3)/include" pip install cryptography
 
 `MacPorts`_:
 
@@ -290,8 +286,8 @@ You can also build cryptography statically:
 
 .. code-block:: console
 
-    $ brew install openssl@1.1 rust
-    $ env CRYPTOGRAPHY_SUPPRESS_LINK_FLAGS=1 LDFLAGS="$(brew --prefix openssl@1.1)/lib/libssl.a $(brew --prefix openssl@1.1)/lib/libcrypto.a" CFLAGS="-I$(brew --prefix openssl@1.1)/include" pip install cryptography
+    $ brew install openssl@3 rust
+    $ env CRYPTOGRAPHY_SUPPRESS_LINK_FLAGS=1 LDFLAGS="$(brew --prefix openssl@3)/lib/libssl.a $(brew --prefix openssl@3)/lib/libcrypto.a" CFLAGS="-I$(brew --prefix openssl@3)/include" pip install cryptography
 
 `MacPorts`_:
 
diff --git a/docs/limitations.rst b/docs/limitations.rst
index 227ed6cd7..3f43c743c 100644
--- a/docs/limitations.rst
+++ b/docs/limitations.rst
@@ -24,21 +24,23 @@ RSA PKCS1 v1.5 constant time decryption
 ---------------------------------------
 
 RSA decryption has several different modes, one of which is PKCS1 v1.5. When
-used in online contexts, a secure protocol implementation requires that peers
-not be able to tell whether RSA PKCS1 v1.5 decryption failed or succeeded,
-even by timing variability.
+used in **online contexts**, a secure protocol implementation requires that
+peers not be able to tell whether RSA PKCS1 v1.5 decryption failed or
+succeeded, even by timing variability.
 
 ``cryptography`` does not provide an API that makes this possible, due to the
 fact that RSA decryption raises an exception on failure, which takes a
 different amount of time than returning a value in the success case.
 
-For this reason, at present, we recommend not implementing online protocols
+Fixing this would require a new API in ``cryptography``, but OpenSSL does
+not expose an API for straightforwardly implementing this while reusing
+its own constant-time logic. See `issue 6167`_ for more information.
+
+For this reason we recommend not implementing online protocols
 that use RSA PKCS1 v1.5 decryption with ``cryptography`` -- independent of this
 limitation, such protocols generally have poor security properties due to their
 lack of forward security.
 
-If a constant time RSA PKCS1 v1.5 decryption API is truly required, you should
-contribute one to ``cryptography``.
-
 .. _`Memory wiping`: https://devblogs.microsoft.com/oldnewthing/?p=4223
 .. _`CERT secure coding guidelines`: https://wiki.sei.cmu.edu/confluence/display/c/MEM03-C.+Clear+sensitive+information+stored+in+reusable+resources
+.. _`issue 6167`: https://github.com/pyca/cryptography/issues/6167#issuecomment-1276151799
\ No newline at end of file
diff --git a/docs/openssl.rst b/docs/openssl.rst
index b628d0a94..edf185d2e 100644
--- a/docs/openssl.rst
+++ b/docs/openssl.rst
@@ -44,6 +44,18 @@ control.
 
         This will activate the default OpenSSL CSPRNG.
 
+.. _legacy-provider:
+
+Legacy provider in OpenSSL 3.x
+------------------------------
+
+.. versionadded:: 39.0.0
+
+Users can set ``CRYPTOGRAPHY_OPENSSL_NO_LEGACY`` environment variable to
+disable the legacy provider in OpenSSL 3.x. This will disable legacy
+cryptographic algorithms, including ``Blowfish``, ``CAST5``, ``SEED``,
+``ARC4``, and ``RC2`` (which is used by some encrypted serialization formats).
+
 OS random engine
 ----------------
 
diff --git a/docs/spelling_wordlist.txt b/docs/spelling_wordlist.txt
index 14f31e1b1..56a9ac881 100644
--- a/docs/spelling_wordlist.txt
+++ b/docs/spelling_wordlist.txt
@@ -96,6 +96,7 @@ plaintext
 Poly
 pre
 precompute
+precomputed
 preprocessor
 preprocessors
 presentational
diff --git a/docs/x509/ocsp.rst b/docs/x509/ocsp.rst
index aee6fdd73..603f9f6dd 100644
--- a/docs/x509/ocsp.rst
+++ b/docs/x509/ocsp.rst
@@ -134,7 +134,8 @@ Creating Requests
     .. method:: add_certificate(cert, issuer, algorithm)
 
         Adds a request using a certificate, issuer certificate, and hash
-        algorithm. This can only be called once.
+        algorithm. You can call this method or ``add_certificate_by_hash``
+        only once.
 
         :param cert: The :class:`~cryptography.x509.Certificate` whose validity
             is being checked.
@@ -151,6 +152,35 @@ Creating Requests
             :class:`~cryptography.hazmat.primitives.hashes.SHA384`, and
             :class:`~cryptography.hazmat.primitives.hashes.SHA512` are allowed.
 
+    .. method:: add_certificate_by_hash(issuer_name_hash, issuer_key_hash, serial_number, algorithm)
+
+        .. versionadded:: 39.0.0
+
+        Adds a request using the issuer's name hash, key hash, the certificate
+        serial number and hash algorithm. You can call this method or
+        ``add_certificate`` only once.
+
+        :param issuer_name_hash: The hash of the issuer's DER encoded name using the
+            same hash algorithm as the one specified in the ``algorithm`` parameter.
+        :type issuer_name_hash: bytes
+
+        :param issuer_key_hash: The hash of the issuer's public key bit string
+            DER encoding using the same hash algorithm as the one specified in
+            the ``algorithm`` parameter.
+        :type issuer_key_hash: bytes
+
+        :param serial_number: The serial number of the certificate being checked.
+        :type serial_number: int
+
+        :param algorithm: A
+            :class:`~cryptography.hazmat.primitives.hashes.HashAlgorithm`
+            instance. For OCSP only
+            :class:`~cryptography.hazmat.primitives.hashes.SHA1`,
+            :class:`~cryptography.hazmat.primitives.hashes.SHA224`,
+            :class:`~cryptography.hazmat.primitives.hashes.SHA256`,
+            :class:`~cryptography.hazmat.primitives.hashes.SHA384`, and
+            :class:`~cryptography.hazmat.primitives.hashes.SHA512` are allowed.
+
     .. method:: add_extension(extval, critical)
 
         Adds an extension to the request.
diff --git a/setup.cfg b/setup.cfg
index d96bb2d4f..d42e78930 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -32,6 +32,7 @@ classifiers =
 	Programming Language :: Python :: 3.8
 	Programming Language :: Python :: 3.9
 	Programming Language :: Python :: 3.10
+	Programming Language :: Python :: 3.11
 	Programming Language :: Python :: Implementation :: CPython
 	Programming Language :: Python :: Implementation :: PyPy
 	Topic :: Security :: Cryptography
@@ -65,7 +66,7 @@ test =
 	pytz
 	hypothesis>=1.11.4,!=3.79.2
 docs = 
-	sphinx >= 1.6.5,!=1.8.0,!=3.1.0,!=3.1.1
+	sphinx >= 1.6.5,!=1.8.0,!=3.1.0,!=3.1.1,!=5.2.0,!=5.2.0.post0
 	sphinx_rtd_theme
 docstest = 
 	pyenchant >= 1.6.11
diff --git a/setup.py b/setup.py
index 320994e69..4a7866c5f 100644
--- a/setup.py
+++ b/setup.py
@@ -10,6 +10,7 @@ import re
 import shutil
 import subprocess
 import sys
+import warnings
 
 from setuptools import setup
 
@@ -30,6 +31,11 @@ except ImportError:
     raise
 
 
+# distutils emits this warning if you pass `setup()` an unknown option. This
+# is what happens if you somehow run this file without `cffi` installed:
+# `cffi_modules` is an unknown option.
+warnings.filterwarnings("error", message="Unknown distribution option")
+
 base_dir = os.path.dirname(__file__)
 src_dir = os.path.join(base_dir, "src")
 
diff --git a/src/_cffi_src/build_openssl.py b/src/_cffi_src/build_openssl.py
index 3ead86a89..0b5115fd9 100644
--- a/src/_cffi_src/build_openssl.py
+++ b/src/_cffi_src/build_openssl.py
@@ -81,7 +81,6 @@ ffi = build_ffi_for_binding(
         "bignum",
         "bio",
         "cmac",
-        "conf",
         "crypto",
         "dh",
         "dsa",
diff --git a/src/_cffi_src/openssl/asn1.py b/src/_cffi_src/openssl/asn1.py
index 17ded38b3..98a933c19 100644
--- a/src/_cffi_src/openssl/asn1.py
+++ b/src/_cffi_src/openssl/asn1.py
@@ -42,7 +42,6 @@ FUNCTIONS = """
 void ASN1_OBJECT_free(ASN1_OBJECT *);
 
 /*  ASN1 STRING */
-unsigned char *ASN1_STRING_data(ASN1_STRING *);
 const unsigned char *ASN1_STRING_get0_data(const ASN1_STRING *);
 int ASN1_STRING_set(ASN1_STRING *, const void *, int);
 
@@ -71,13 +70,11 @@ ASN1_ENUMERATED *ASN1_ENUMERATED_new(void);
 void ASN1_ENUMERATED_free(ASN1_ENUMERATED *);
 int ASN1_ENUMERATED_set(ASN1_ENUMERATED *, long);
 
-/* These became const ASN1_* in 1.1.0 */
-int ASN1_STRING_type(ASN1_STRING *);
-int ASN1_STRING_to_UTF8(unsigned char **, ASN1_STRING *);
-int i2a_ASN1_INTEGER(BIO *, ASN1_INTEGER *);
+int ASN1_STRING_type(const ASN1_STRING *);
+int ASN1_STRING_to_UTF8(unsigned char **, const ASN1_STRING *);
+int i2a_ASN1_INTEGER(BIO *, const ASN1_INTEGER *);
 
-/* This became const ASN1_TIME in 1.1.0f */
-ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(ASN1_TIME *,
+ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *,
                                                    ASN1_GENERALIZEDTIME **);
 
 int ASN1_STRING_length(ASN1_STRING *);
diff --git a/src/_cffi_src/openssl/bio.py b/src/_cffi_src/openssl/bio.py
index 3e83f2fb1..6207cb2e2 100644
--- a/src/_cffi_src/openssl/bio.py
+++ b/src/_cffi_src/openssl/bio.py
@@ -21,7 +21,6 @@ size_t BIO_ctrl_pending(BIO *);
 int BIO_read(BIO *, void *, int);
 int BIO_gets(BIO *, char *, int);
 int BIO_write(BIO *, const void *, int);
-/* Added in 1.1.0 */
 int BIO_up_ref(BIO *);
 
 BIO *BIO_new(BIO_METHOD *);
@@ -43,7 +42,11 @@ void BIO_ADDR_free(BIO_ADDR *);
 
 CUSTOMIZATIONS = """
 #if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL
+
+#if !defined(_WIN32)
 #include <sys/socket.h>
+#endif
+
 #include <stdlib.h>
 typedef struct sockaddr BIO_ADDR;
 
diff --git a/src/_cffi_src/openssl/conf.py b/src/_cffi_src/openssl/conf.py
deleted file mode 100644
index dd1e80a70..000000000
--- a/src/_cffi_src/openssl/conf.py
+++ /dev/null
@@ -1,18 +0,0 @@
-# This file is dual licensed under the terms of the Apache License, Version
-# 2.0, and the BSD License. See the LICENSE file in the root of this repository
-# for complete details.
-
-
-INCLUDES = """
-#include <openssl/conf.h>
-"""
-
-TYPES = """
-"""
-
-FUNCTIONS = """
-void OPENSSL_config(const char *);
-"""
-
-CUSTOMIZATIONS = """
-"""
diff --git a/src/_cffi_src/openssl/crypto.py b/src/_cffi_src/openssl/crypto.py
index 4f1d29dcb..cbef38804 100644
--- a/src/_cffi_src/openssl/crypto.py
+++ b/src/_cffi_src/openssl/crypto.py
@@ -33,7 +33,6 @@ const char *SSLeay_version(int);
 unsigned long OpenSSL_version_num(void);
 const char *OpenSSL_version(int);
 
-/* this is a macro in 1.1.0 */
 void *OPENSSL_malloc(size_t);
 void OPENSSL_free(void *);
 
@@ -75,7 +74,7 @@ CUSTOMIZATIONS = """
 # define OPENSSL_DIR             SSLEAY_DIR
 #endif
 
-#if CRYPTOGRAPHY_IS_LIBRESSL
+#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_360
 static const long Cryptography_HAS_OPENSSL_CLEANUP = 0;
 void (*OPENSSL_cleanup)(void) = NULL;
 #else
diff --git a/src/_cffi_src/openssl/cryptography.py b/src/_cffi_src/openssl/cryptography.py
index f92dd2a0a..f53ee72ac 100644
--- a/src/_cffi_src/openssl/cryptography.py
+++ b/src/_cffi_src/openssl/cryptography.py
@@ -4,10 +4,25 @@
 
 
 INCLUDES = """
-/* define our OpenSSL API compatibility level to 1.0.1. Any symbols older than
-   that will raise an error during compilation. We can raise this number again
-   after we drop 1.0.2 support in the distant future.  */
-#define OPENSSL_API_COMPAT 0x10001000L
+/* define our OpenSSL API compatibility level to 1.1.0. Any symbols older than
+   that will raise an error during compilation. */
+#define OPENSSL_API_COMPAT 0x10100000L
+
+#if defined(_WIN32)
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <Wincrypt.h>
+#include <Winsock2.h>
+/*
+    undef some macros that are defined by wincrypt.h but are also types in
+    boringssl. openssl has worked around this but boring has not yet. see:
+    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base
+    /win/wincrypt_shim.h
+*/
+#undef X509_NAME
+#undef X509_EXTENSIONS
+#undef PKCS7_SIGNER_INFO
+#endif
 
 #include <openssl/opensslv.h>
 
@@ -24,39 +39,16 @@ INCLUDES = """
 #define CRYPTOGRAPHY_IS_BORINGSSL 0
 #endif
 
-/*
-    LibreSSL removed e_os2.h from the public headers so we'll only include it
-    if we're using vanilla OpenSSL.
-*/
-#if !CRYPTOGRAPHY_IS_LIBRESSL
-#include <openssl/e_os2.h>
-#endif
-#if defined(_WIN32)
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-#include <Wincrypt.h>
-#include <Winsock2.h>
-#endif
-
 #if CRYPTOGRAPHY_IS_LIBRESSL
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_322 \
-    (LIBRESSL_VERSION_NUMBER < 0x3020200f)
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_332 \
-    (LIBRESSL_VERSION_NUMBER < 0x3030200f)
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_340 \
-    (LIBRESSL_VERSION_NUMBER < 0x3040000f)
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_350 \
-    (LIBRESSL_VERSION_NUMBER < 0x3050000f)
+#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_360 \
+    (LIBRESSL_VERSION_NUMBER < 0x3060000f)
 
 #else
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_322 (0)
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_332 (0)
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_340 (0)
-#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_350 (0)
+#define CRYPTOGRAPHY_LIBRESSL_LESS_THAN_360 (0)
 #endif
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000
-    #error "pyca/cryptography MUST be linked with Openssl 1.1.0 or later"
+#if OPENSSL_VERSION_NUMBER < 0x10101000
+    #error "pyca/cryptography MUST be linked with Openssl 1.1.1 or later"
 #endif
 
 #define CRYPTOGRAPHY_OPENSSL_111D_OR_GREATER \
@@ -64,8 +56,6 @@ INCLUDES = """
 #define CRYPTOGRAPHY_OPENSSL_300_OR_GREATER \
     (OPENSSL_VERSION_NUMBER >= 0x30000000 && !CRYPTOGRAPHY_IS_LIBRESSL)
 
-#define CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 \
-    (OPENSSL_VERSION_NUMBER < 0x10101000 || CRYPTOGRAPHY_IS_LIBRESSL)
 #define CRYPTOGRAPHY_OPENSSL_LESS_THAN_111B \
     (OPENSSL_VERSION_NUMBER < 0x10101020 || CRYPTOGRAPHY_IS_LIBRESSL)
 #define CRYPTOGRAPHY_OPENSSL_LESS_THAN_111D \
@@ -84,14 +74,10 @@ TYPES = """
 static const int CRYPTOGRAPHY_OPENSSL_111D_OR_GREATER;
 static const int CRYPTOGRAPHY_OPENSSL_300_OR_GREATER;
 
-static const int CRYPTOGRAPHY_OPENSSL_LESS_THAN_111;
 static const int CRYPTOGRAPHY_OPENSSL_LESS_THAN_111B;
 static const int CRYPTOGRAPHY_OPENSSL_LESS_THAN_111E;
 static const int CRYPTOGRAPHY_NEEDS_OSRANDOM_ENGINE;
 
-static const int CRYPTOGRAPHY_LIBRESSL_LESS_THAN_340;
-static const int CRYPTOGRAPHY_LIBRESSL_LESS_THAN_350;
-
 static const int CRYPTOGRAPHY_IS_LIBRESSL;
 static const int CRYPTOGRAPHY_IS_BORINGSSL;
 """
diff --git a/src/_cffi_src/openssl/dh.py b/src/_cffi_src/openssl/dh.py
index c378ad1b4..44b3d817a 100644
--- a/src/_cffi_src/openssl/dh.py
+++ b/src/_cffi_src/openssl/dh.py
@@ -20,145 +20,23 @@ int DH_size(const DH *);
 int DH_generate_key(DH *);
 DH *DHparams_dup(DH *);
 
-/* added in 1.1.0 when the DH struct was opaqued */
 void DH_get0_pqg(const DH *, const BIGNUM **, const BIGNUM **,
                  const BIGNUM **);
 int DH_set0_pqg(DH *, BIGNUM *, BIGNUM *, BIGNUM *);
 void DH_get0_key(const DH *, const BIGNUM **, const BIGNUM **);
 int DH_set0_key(DH *, BIGNUM *, BIGNUM *);
 
-int Cryptography_DH_check(const DH *, int *);
+int DH_check(const DH *, int *);
 int DH_generate_parameters_ex(DH *, int, int, BN_GENCB *);
 DH *d2i_DHparams_bio(BIO *, DH **);
 int i2d_DHparams_bio(BIO *, DH *);
-DH *Cryptography_d2i_DHxparams_bio(BIO *, DH **);
-int Cryptography_i2d_DHxparams_bio(BIO *, DH *);
+DH *d2i_DHxparams_bio(BIO *, DH **);
+int i2d_DHxparams_bio(BIO *, DH *);
 """
 
 CUSTOMIZATIONS = """
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_350
-#ifndef DH_CHECK_Q_NOT_PRIME
-#define DH_CHECK_Q_NOT_PRIME            0x10
-#endif
-
-#ifndef DH_CHECK_INVALID_Q_VALUE
-#define DH_CHECK_INVALID_Q_VALUE        0x20
-#endif
-
-#ifndef DH_CHECK_INVALID_J_VALUE
-#define DH_CHECK_INVALID_J_VALUE        0x40
-#endif
-
-/* DH_check implementation taken from OpenSSL 1.1.0pre6 */
-
-/*-
- * Check that p is a safe prime and
- * if g is 2, 3 or 5, check that it is a suitable generator
- * where
- * for 2, p mod 24 == 11
- * for 3, p mod 12 == 5
- * for 5, p mod 10 == 3 or 7
- * should hold.
- */
-
-int Cryptography_DH_check(const DH *dh, int *ret)
-{
-    int ok = 0, r;
-    BN_CTX *ctx = NULL;
-    BN_ULONG l;
-    BIGNUM *t1 = NULL, *t2 = NULL;
-
-    *ret = 0;
-    ctx = BN_CTX_new();
-    if (ctx == NULL)
-        goto err;
-    BN_CTX_start(ctx);
-    t1 = BN_CTX_get(ctx);
-    if (t1 == NULL)
-        goto err;
-    t2 = BN_CTX_get(ctx);
-    if (t2 == NULL)
-        goto err;
-
-    if (dh->q) {
-        if (BN_cmp(dh->g, BN_value_one()) <= 0)
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-        else if (BN_cmp(dh->g, dh->p) >= 0)
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-        else {
-            /* Check g^q == 1 mod p */
-            if (!BN_mod_exp(t1, dh->g, dh->q, dh->p, ctx))
-                goto err;
-            if (!BN_is_one(t1))
-                *ret |= DH_NOT_SUITABLE_GENERATOR;
-        }
-        r = BN_is_prime_ex(dh->q, BN_prime_checks, ctx, NULL);
-        if (r < 0)
-            goto err;
-        if (!r)
-            *ret |= DH_CHECK_Q_NOT_PRIME;
-        /* Check p == 1 mod q  i.e. q divides p - 1 */
-        if (!BN_div(t1, t2, dh->p, dh->q, ctx))
-            goto err;
-        if (!BN_is_one(t2))
-            *ret |= DH_CHECK_INVALID_Q_VALUE;
-        if (dh->j && BN_cmp(dh->j, t1))
-            *ret |= DH_CHECK_INVALID_J_VALUE;
-
-    } else if (BN_is_word(dh->g, DH_GENERATOR_2)) {
-        l = BN_mod_word(dh->p, 24);
-        if (l == (BN_ULONG)-1)
-            goto err;
-        if (l != 11)
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-    } else if (BN_is_word(dh->g, DH_GENERATOR_5)) {
-        l = BN_mod_word(dh->p, 10);
-        if (l == (BN_ULONG)-1)
-            goto err;
-        if ((l != 3) && (l != 7))
-            *ret |= DH_NOT_SUITABLE_GENERATOR;
-    } else
-        *ret |= DH_UNABLE_TO_CHECK_GENERATOR;
-
-    r = BN_is_prime_ex(dh->p, BN_prime_checks, ctx, NULL);
-    if (r < 0)
-        goto err;
-    if (!r)
-        *ret |= DH_CHECK_P_NOT_PRIME;
-    else if (!dh->q) {
-        if (!BN_rshift1(t1, dh->p))
-            goto err;
-        r = BN_is_prime_ex(t1, BN_prime_checks, ctx, NULL);
-        if (r < 0)
-            goto err;
-        if (!r)
-            *ret |= DH_CHECK_P_NOT_SAFE_PRIME;
-    }
-    ok = 1;
- err:
-    if (ctx != NULL) {
-        BN_CTX_end(ctx);
-        BN_CTX_free(ctx);
-    }
-    return (ok);
-}
-#else
-int Cryptography_DH_check(const DH *dh, int *ret) {
-    return DH_check(dh, ret);
-}
-#endif
-
-/* These functions were added in OpenSSL 1.1.0f commit d0c50e80a8 */
-/* Define our own to simplify support across all versions. */
-#if defined(EVP_PKEY_DHX) && EVP_PKEY_DHX != -1
-DH *Cryptography_d2i_DHxparams_bio(BIO *bp, DH **x) {
-    return ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x);
-}
-int Cryptography_i2d_DHxparams_bio(BIO *bp, DH *x) {
-    return ASN1_i2d_bio_of_const(DH, i2d_DHxparams, bp, x);
-}
-#else
-DH *(*Cryptography_d2i_DHxparams_bio)(BIO *bp, DH **x) = NULL;
-int (*Cryptography_i2d_DHxparams_bio)(BIO *bp, DH *x) = NULL;
+#if !(defined(EVP_PKEY_DHX) && EVP_PKEY_DHX != -1)
+DH *(*d2i_DHxparams_bio)(BIO *bp, DH **x) = NULL;
+int (*i2d_DHxparams_bio)(BIO *bp, DH *x) = NULL;
 #endif
 """
diff --git a/src/_cffi_src/openssl/dsa.py b/src/_cffi_src/openssl/dsa.py
index 7f3f452eb..cf34913b5 100644
--- a/src/_cffi_src/openssl/dsa.py
+++ b/src/_cffi_src/openssl/dsa.py
@@ -22,7 +22,6 @@ int DSA_sign(int, const unsigned char *, int, unsigned char *, unsigned int *,
 int DSA_verify(int, const unsigned char *, int, const unsigned char *, int,
                DSA *);
 
-/* added in 1.1.0 to access the opaque struct */
 void DSA_get0_pqg(const DSA *, const BIGNUM **, const BIGNUM **,
                   const BIGNUM **);
 int DSA_set0_pqg(DSA *, BIGNUM *, BIGNUM *, BIGNUM *);
diff --git a/src/_cffi_src/openssl/evp.py b/src/_cffi_src/openssl/evp.py
index f4d9fb953..7a3ae2744 100644
--- a/src/_cffi_src/openssl/evp.py
+++ b/src/_cffi_src/openssl/evp.py
@@ -34,7 +34,6 @@ static const int EVP_CTRL_AEAD_SET_TAG;
 static const int Cryptography_HAS_SCRYPT;
 static const int Cryptography_HAS_EVP_PKEY_DHX;
 static const int Cryptography_HAS_EVP_PKEY_get_set_tls_encodedpoint;
-static const int Cryptography_HAS_ONESHOT_EVP_DIGEST_SIGN_VERIFY;
 static const long Cryptography_HAS_RAW_KEY;
 static const long Cryptography_HAS_EVP_DIGESTFINAL_XOF;
 static const long Cryptography_HAS_300_FIPS;
@@ -129,20 +128,16 @@ int EVP_PKEY_id(const EVP_PKEY *);
 EVP_MD_CTX *EVP_MD_CTX_new(void);
 void EVP_MD_CTX_free(EVP_MD_CTX *);
 
-/* Added in 1.1.1 */
 int EVP_DigestSign(EVP_MD_CTX *, unsigned char *, size_t *,
                    const unsigned char *, size_t);
 int EVP_DigestVerify(EVP_MD_CTX *, const unsigned char *, size_t,
                      const unsigned char *, size_t);
-/* Added in 1.1.0 */
 size_t EVP_PKEY_get1_tls_encodedpoint(EVP_PKEY *, unsigned char **);
 int EVP_PKEY_set1_tls_encodedpoint(EVP_PKEY *, const unsigned char *,
                                    size_t);
 
-/* EVP_PKEY * became const in 1.1.0 */
-int EVP_PKEY_bits(EVP_PKEY *);
+int EVP_PKEY_bits(const EVP_PKEY *);
 
-void OpenSSL_add_all_algorithms(void);
 int EVP_PKEY_assign_RSA(EVP_PKEY *, RSA *);
 
 EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *);
@@ -203,18 +198,7 @@ int (*EVP_PKEY_set1_tls_encodedpoint)(EVP_PKEY *, const unsigned char *,
                                       size_t) = NULL;
 #endif
 
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_340 || \
-    (CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 && !CRYPTOGRAPHY_IS_LIBRESSL)
-static const long Cryptography_HAS_ONESHOT_EVP_DIGEST_SIGN_VERIFY = 0;
-int (*EVP_DigestSign)(EVP_MD_CTX *, unsigned char *, size_t *,
-                      const unsigned char *tbs, size_t) = NULL;
-int (*EVP_DigestVerify)(EVP_MD_CTX *, const unsigned char *, size_t,
-                        const unsigned char *, size_t) = NULL;
-#else
-static const long Cryptography_HAS_ONESHOT_EVP_DIGEST_SIGN_VERIFY = 1;
-#endif
-
-#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_111
+#if CRYPTOGRAPHY_IS_LIBRESSL
 static const long Cryptography_HAS_RAW_KEY = 0;
 static const long Cryptography_HAS_EVP_DIGESTFINAL_XOF = 0;
 int (*EVP_DigestFinalXOF)(EVP_MD_CTX *, unsigned char *, size_t) = NULL;
@@ -231,17 +215,6 @@ static const long Cryptography_HAS_RAW_KEY = 1;
 static const long Cryptography_HAS_EVP_DIGESTFINAL_XOF = 1;
 #endif
 
-/* OpenSSL 1.1.0+ does this define for us, but if not present we'll do it */
-#if !defined(EVP_CTRL_AEAD_SET_IVLEN)
-# define EVP_CTRL_AEAD_SET_IVLEN EVP_CTRL_GCM_SET_IVLEN
-#endif
-#if !defined(EVP_CTRL_AEAD_GET_TAG)
-# define EVP_CTRL_AEAD_GET_TAG EVP_CTRL_GCM_GET_TAG
-#endif
-#if !defined(EVP_CTRL_AEAD_SET_TAG)
-# define EVP_CTRL_AEAD_SET_TAG EVP_CTRL_GCM_SET_TAG
-#endif
-
 /* This is tied to X25519 support so we reuse the Cryptography_HAS_X25519
    conditional to remove it. OpenSSL 1.1.0 didn't have this define, but
    1.1.1 will when it is released. We can remove this in the distant
@@ -294,10 +267,4 @@ int (*EVP_PKEY_set1_DH)(EVP_PKEY *, DH *) = NULL;
 #else
 static const long Cryptography_HAS_EVP_PKEY_DH = 1;
 #endif
-
-// This can be removed when we drop OpenSSL 1.1.0 support
-// OPENSSL_LESS_THAN_111
-#if !defined(EVP_PKEY_RSA_PSS)
-#define EVP_PKEY_RSA_PSS 912
-#endif
 """
diff --git a/src/_cffi_src/openssl/fips.py b/src/_cffi_src/openssl/fips.py
index dd81d06cf..9fb1e7aed 100644
--- a/src/_cffi_src/openssl/fips.py
+++ b/src/_cffi_src/openssl/fips.py
@@ -17,7 +17,7 @@ int FIPS_mode(void);
 """
 
 CUSTOMIZATIONS = """
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_350 || CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
 static const long Cryptography_HAS_FIPS = 0;
 int (*FIPS_mode_set)(int) = NULL;
 int (*FIPS_mode)(void) = NULL;
diff --git a/src/_cffi_src/openssl/rsa.py b/src/_cffi_src/openssl/rsa.py
index c8e3e5a91..b1f6e4a4d 100644
--- a/src/_cffi_src/openssl/rsa.py
+++ b/src/_cffi_src/openssl/rsa.py
@@ -27,7 +27,6 @@ RSA *RSAPublicKey_dup(RSA *);
 int RSA_blinding_on(RSA *, BN_CTX *);
 int RSA_print(BIO *, const RSA *, int);
 
-/* added in 1.1.0 when the RSA struct was opaqued */
 int RSA_set0_key(RSA *, BIGNUM *, BIGNUM *, BIGNUM *);
 int RSA_set0_factors(RSA *, BIGNUM *, BIGNUM *);
 int RSA_set0_crt_params(RSA *, BIGNUM *, BIGNUM *, BIGNUM *);
diff --git a/src/_cffi_src/openssl/src/osrandom_engine.c b/src/_cffi_src/openssl/src/osrandom_engine.c
index a84857b86..257fcd509 100644
--- a/src/_cffi_src/openssl/src/osrandom_engine.c
+++ b/src/_cffi_src/openssl/src/osrandom_engine.c
@@ -246,22 +246,7 @@ static void dev_urandom_close(void) {
 #if CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY
 static const char *Cryptography_osrandom_engine_name = "osrandom_engine getentropy()";
 
-static int getentropy_works = CRYPTOGRAPHY_OSRANDOM_GETENTROPY_NOT_INIT;
-
 static int osrandom_init(ENGINE *e) {
-#if !defined(__APPLE__)
-    getentropy_works = CRYPTOGRAPHY_OSRANDOM_GETENTROPY_WORKS;
-#else
-    if (__builtin_available(macOS 10.12, *)) {
-        getentropy_works = CRYPTOGRAPHY_OSRANDOM_GETENTROPY_WORKS;
-    } else {
-        getentropy_works = CRYPTOGRAPHY_OSRANDOM_GETENTROPY_FALLBACK;
-        int fd = dev_urandom_fd();
-        if (fd < 0) {
-            return 0;
-        }
-    }
-#endif
     return 1;
 }
 
@@ -269,34 +254,22 @@ static int osrandom_rand_bytes(unsigned char *buffer, int size) {
     int len;
     int res;
 
-    switch(getentropy_works) {
-#if defined(__APPLE__)
-    case CRYPTOGRAPHY_OSRANDOM_GETENTROPY_FALLBACK:
-        return dev_urandom_read(buffer, size);
-#endif
-    case CRYPTOGRAPHY_OSRANDOM_GETENTROPY_WORKS:
-        while (size > 0) {
-            /* OpenBSD and macOS restrict maximum buffer size to 256. */
-            len = size > 256 ? 256 : size;
-/* on mac, availability is already checked using `__builtin_available` above */
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wunguarded-availability"
-            res = getentropy(buffer, (size_t)len);
-#pragma clang diagnostic pop
-            if (res < 0) {
-                ERR_Cryptography_OSRandom_error(
-                    CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES,
-                    CRYPTOGRAPHY_OSRANDOM_R_GETENTROPY_FAILED,
-                    __FILE__, __LINE__
-                );
-                return 0;
-            }
-            buffer += len;
-            size -= len;
+    while (size > 0) {
+        /* OpenBSD and macOS restrict maximum buffer size to 256. */
+        len = size > 256 ? 256 : size;
+        res = getentropy(buffer, (size_t)len);
+        if (res < 0) {
+            ERR_Cryptography_OSRandom_error(
+                CRYPTOGRAPHY_OSRANDOM_F_RAND_BYTES,
+                CRYPTOGRAPHY_OSRANDOM_R_GETENTROPY_FAILED,
+                __FILE__, __LINE__
+            );
+            return 0;
         }
-        return 1;
+        buffer += len;
+        size -= len;
     }
-    __builtin_unreachable();
+    return 1;
 }
 
 static int osrandom_finish(ENGINE *e) {
@@ -308,13 +281,7 @@ static int osrandom_rand_status(void) {
 }
 
 static const char *osurandom_get_implementation(void) {
-    switch(getentropy_works) {
-    case CRYPTOGRAPHY_OSRANDOM_GETENTROPY_FALLBACK:
-        return "/dev/urandom";
-    case CRYPTOGRAPHY_OSRANDOM_GETENTROPY_WORKS:
-        return "getentropy";
-    }
-    __builtin_unreachable();
+    return "getentropy";
 }
 #endif /* CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY */
 
diff --git a/src/_cffi_src/openssl/src/osrandom_engine.h b/src/_cffi_src/openssl/src/osrandom_engine.h
index 93d918b88..376b8ff21 100644
--- a/src/_cffi_src/openssl/src/osrandom_engine.h
+++ b/src/_cffi_src/openssl/src/osrandom_engine.h
@@ -69,9 +69,7 @@
 
 /* Fallbacks need /dev/urandom helper functions. */
 #if CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_GETRANDOM || \
-     CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_DEV_URANDOM || \
-     (CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_GETENTROPY && \
-     defined(__APPLE__))
+     CRYPTOGRAPHY_OSRANDOM_ENGINE == CRYPTOGRAPHY_OSRANDOM_ENGINE_DEV_URANDOM
   #define CRYPTOGRAPHY_OSRANDOM_NEEDS_DEV_URANDOM 1
 #endif
 
diff --git a/src/_cffi_src/openssl/ssl.py b/src/_cffi_src/openssl/ssl.py
index 61f83ef8a..0a6a124e1 100644
--- a/src/_cffi_src/openssl/ssl.py
+++ b/src/_cffi_src/openssl/ssl.py
@@ -15,7 +15,6 @@ static const long Cryptography_HAS_TLS_ST;
 static const long Cryptography_HAS_SSL3_METHOD;
 static const long Cryptography_HAS_TLSv1_1;
 static const long Cryptography_HAS_TLSv1_2;
-static const long Cryptography_HAS_TLSv1_3;
 static const long Cryptography_HAS_TLSv1_3_FUNCTIONS;
 static const long Cryptography_HAS_SECURE_RENEGOTIATION;
 static const long Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS;
@@ -25,7 +24,6 @@ static const long Cryptography_HAS_PSK;
 static const long Cryptography_HAS_PSK_TLSv1_3;
 static const long Cryptography_HAS_VERIFIED_CHAIN;
 static const long Cryptography_HAS_KEYLOG;
-static const long Cryptography_HAS_GET_PROTO_VERSION;
 static const long Cryptography_HAS_TLSEXT_HOSTNAME;
 static const long Cryptography_HAS_SSL_COOKIE;
 
@@ -46,6 +44,7 @@ static const long Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF;
 static const long Cryptography_HAS_ALPN;
 static const long Cryptography_HAS_NEXTPROTONEG;
 static const long Cryptography_HAS_SET_CERT_CB;
+static const long Cryptography_HAS_GET_EXTMS_SUPPORT;
 static const long Cryptography_HAS_CUSTOM_EXT;
 static const long Cryptography_HAS_SRTP;
 static const long Cryptography_HAS_DTLS_GET_DATA_MTU;
@@ -188,7 +187,8 @@ int SSL_get_ex_data_X509_STORE_CTX_idx(void);
 void SSL_set_verify(SSL *, int, int (*)(int, X509_STORE_CTX *));
 int SSL_get_verify_mode(const SSL *);
 
-/* Added in 1.0.2 */
+long SSL_get_extms_support(SSL *);
+
 X509_VERIFY_PARAM *SSL_get0_param(SSL *);
 X509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *);
 
@@ -323,11 +323,7 @@ size_t SSL_get_peer_finished(const SSL *, void *, size_t);
 Cryptography_STACK_OF_X509_NAME *SSL_load_client_CA_file(const char *);
 
 const char *SSL_get_servername(const SSL *, const int);
-/* Function signature changed to const char * in 1.1.0 */
 const char *SSL_CIPHER_get_version(const SSL_CIPHER *);
-/* These became macros in 1.1.0 */
-int SSL_library_init(void);
-void SSL_load_error_strings(void);
 
 SSL_SESSION *SSL_get_session(const SSL *);
 const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *, unsigned int *);
@@ -373,31 +369,6 @@ unsigned long SSL_CTX_set_tmp_dh(SSL_CTX *, DH *);
 unsigned long SSL_CTX_set_tmp_ecdh(SSL_CTX *, EC_KEY *);
 unsigned long SSL_CTX_add_extra_chain_cert(SSL_CTX *, X509 *);
 
-/*- These aren't macros these functions are all const X on openssl > 1.0.x -*/
-
-/*  methods */
-
-const SSL_METHOD *TLSv1_1_method(void);
-const SSL_METHOD *TLSv1_1_server_method(void);
-const SSL_METHOD *TLSv1_1_client_method(void);
-
-const SSL_METHOD *TLSv1_2_method(void);
-const SSL_METHOD *TLSv1_2_server_method(void);
-const SSL_METHOD *TLSv1_2_client_method(void);
-
-const SSL_METHOD *SSLv3_method(void);
-const SSL_METHOD *SSLv3_server_method(void);
-const SSL_METHOD *SSLv3_client_method(void);
-
-const SSL_METHOD *TLSv1_method(void);
-const SSL_METHOD *TLSv1_server_method(void);
-const SSL_METHOD *TLSv1_client_method(void);
-
-const SSL_METHOD *DTLSv1_method(void);
-const SSL_METHOD *DTLSv1_server_method(void);
-const SSL_METHOD *DTLSv1_client_method(void);
-
-/* Added in 1.0.2 */
 const SSL_METHOD *DTLS_method(void);
 const SSL_METHOD *DTLS_server_method(void);
 const SSL_METHOD *DTLS_client_method(void);
@@ -447,9 +418,6 @@ int SSL_select_next_proto(unsigned char **, unsigned char *,
 int sk_SSL_CIPHER_num(Cryptography_STACK_OF_SSL_CIPHER *);
 const SSL_CIPHER *sk_SSL_CIPHER_value(Cryptography_STACK_OF_SSL_CIPHER *, int);
 
-/* ALPN APIs were introduced in OpenSSL 1.0.2.  To continue to support earlier
- * versions some special handling of these is necessary.
- */
 int SSL_CTX_set_alpn_protos(SSL_CTX *, const unsigned char *, unsigned);
 int SSL_set_alpn_protos(SSL *, const unsigned char *, unsigned);
 void SSL_CTX_set_alpn_select_cb(SSL_CTX *,
@@ -464,15 +432,11 @@ void SSL_get0_alpn_selected(const SSL *, const unsigned char **, unsigned *);
 
 long SSL_get_server_tmp_key(SSL *, EVP_PKEY **);
 
-/* SSL_CTX_set_cert_cb is introduced in OpenSSL 1.0.2. To continue to support
- * earlier versions some special handling of these is necessary.
- */
 void SSL_CTX_set_cert_cb(SSL_CTX *, int (*)(SSL *, void *), void *);
 void SSL_set_cert_cb(SSL *, int (*)(SSL *, void *), void *);
 
 int SSL_SESSION_set1_id_context(SSL_SESSION *, const unsigned char *,
                                 unsigned int);
-/* Added in 1.1.0 for the great opaquing of structs */
 size_t SSL_SESSION_get_master_key(const SSL_SESSION *, unsigned char *,
                                   size_t);
 size_t SSL_get_client_random(const SSL *, unsigned char *, size_t);
@@ -559,27 +523,14 @@ static const long Cryptography_HAS_TLSEXT_HOSTNAME = 1;
 int (*SSL_CTX_set_client_cert_engine)(SSL_CTX *, ENGINE *) = NULL;
 #endif
 
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_350 || CRYPTOGRAPHY_IS_BORINGSSL
+#if CRYPTOGRAPHY_IS_BORINGSSL
 static const long Cryptography_HAS_VERIFIED_CHAIN = 0;
 Cryptography_STACK_OF_X509 *(*SSL_get0_verified_chain)(const SSL *) = NULL;
 #else
 static const long Cryptography_HAS_VERIFIED_CHAIN = 1;
 #endif
 
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_350 || \
-    (CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 && !CRYPTOGRAPHY_IS_LIBRESSL)
-static const long Cryptography_HAS_KEYLOG = 0;
-void (*SSL_CTX_set_keylog_callback)(SSL_CTX *,
-                                    void (*) (const SSL *, const char *)
-                                    ) = NULL;
-void (*(*SSL_CTX_get_keylog_callback)(SSL_CTX *))(
-                                                  const SSL *,
-                                                  const char *
-                                                  ) = NULL;
-#else
 static const long Cryptography_HAS_KEYLOG = 1;
-#endif
-
 static const long Cryptography_HAS_SECURE_RENEGOTIATION = 1;
 
 #ifdef OPENSSL_NO_SSL3_METHOD
@@ -619,8 +570,12 @@ static const long SSL_OP_IGNORE_UNEXPECTED_EOF = 1;
 void (*SSL_CTX_set_cert_cb)(SSL_CTX *, int (*)(SSL *, void *), void *) = NULL;
 void (*SSL_set_cert_cb)(SSL *, int (*)(SSL *, void *), void *) = NULL;
 static const long Cryptography_HAS_SET_CERT_CB = 0;
+
+long (*SSL_get_extms_support)(SSL *) = NULL;
+static const long Cryptography_HAS_GET_EXTMS_SUPPORT = 0;
 #else
 static const long Cryptography_HAS_SET_CERT_CB = 1;
+static const long Cryptography_HAS_GET_EXTMS_SUPPORT = 1;
 #endif
 
 static const long Cryptography_HAS_SSL_CTX_CLEAR_OPTIONS = 1;
@@ -645,15 +600,11 @@ static const long TLS_ST_OK = 0;
 #endif
 
 #if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_332
-static const long SSL_OP_NO_DTLSv1 = 0;
-static const long SSL_OP_NO_DTLSv1_2 = 0;
-#endif
 long (*DTLS_set_link_mtu)(SSL *, long) = NULL;
 long (*DTLS_get_link_min_mtu)(SSL *) = NULL;
 #endif
 
-#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 || CRYPTOGRAPHY_IS_BORINGSSL
+#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL
 static const long Cryptography_HAS_DTLS_GET_DATA_MTU = 0;
 size_t (*DTLS_get_data_mtu)(SSL *) = NULL;
 #else
@@ -747,18 +698,7 @@ int (*SSL_set_tlsext_use_srtp)(SSL *, const char *) = NULL;
 SRTP_PROTECTION_PROFILE * (*SSL_get_selected_srtp_profile)(SSL *) = NULL;
 #endif
 
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_340 || \
-    (CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 && !CRYPTOGRAPHY_IS_LIBRESSL)
-static const long Cryptography_HAS_TLSv1_3 = 0;
-static const long TLS1_3_VERSION = 0;
-static const long SSL_OP_NO_TLSv1_3 = 0;
-#else
-static const long Cryptography_HAS_TLSv1_3 = 1;
-#endif
-
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_340 || \
-    (CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 && !CRYPTOGRAPHY_IS_LIBRESSL) || \
-    CRYPTOGRAPHY_IS_BORINGSSL
+#if CRYPTOGRAPHY_IS_BORINGSSL
 static const long Cryptography_HAS_TLSv1_3_FUNCTIONS = 0;
 
 static const long SSL_VERIFY_POST_HANDSHAKE = 0;
@@ -774,17 +714,6 @@ int (*SSL_CTX_set_max_early_data)(SSL_CTX *, uint32_t) = NULL;
 static const long Cryptography_HAS_TLSv1_3_FUNCTIONS = 1;
 #endif
 
-#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 && !CRYPTOGRAPHY_IS_LIBRESSL
-static const long Cryptography_HAS_GET_PROTO_VERSION = 0;
-
-long (*SSL_CTX_get_min_proto_version)(SSL_CTX *) = NULL;
-long (*SSL_CTX_get_max_proto_version)(SSL_CTX *) = NULL;
-long (*SSL_get_min_proto_version)(SSL *) = NULL;
-long (*SSL_get_max_proto_version)(SSL *) = NULL;
-#else
-static const long Cryptography_HAS_GET_PROTO_VERSION = 1;
-#endif
-
 #if CRYPTOGRAPHY_IS_BORINGSSL
 static const long Cryptography_HAS_SSL_COOKIE = 0;
 
@@ -805,8 +734,7 @@ void (*SSL_CTX_set_cookie_verify_cb)(SSL_CTX *,
 #else
 static const long Cryptography_HAS_SSL_COOKIE = 1;
 #endif
-#if CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 || \
-    CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL
+#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL
 static const long Cryptography_HAS_PSK_TLSv1_3 = 0;
 void (*SSL_CTX_set_psk_find_session_callback)(SSL_CTX *,
                                            int (*)(
@@ -823,7 +751,7 @@ void (*SSL_CTX_set_psk_use_session_callback)(SSL_CTX *,
                                               size_t *,
                                               SSL_SESSION **
                                           )) = NULL;
-#if CRYPTOGRAPHY_LIBRESSL_LESS_THAN_340 || CRYPTOGRAPHY_IS_BORINGSSL
+#if CRYPTOGRAPHY_IS_BORINGSSL
 const SSL_CIPHER *(*SSL_CIPHER_find)(SSL *, const unsigned char *) = NULL;
 #endif
 int (*SSL_SESSION_set1_master_key)(SSL_SESSION *, const unsigned char *,
diff --git a/src/_cffi_src/openssl/x509.py b/src/_cffi_src/openssl/x509.py
index 4ba14924a..5b06ad772 100644
--- a/src/_cffi_src/openssl/x509.py
+++ b/src/_cffi_src/openssl/x509.py
@@ -156,24 +156,20 @@ RSA *d2i_RSAPublicKey_bio(BIO *, RSA **);
 int i2d_RSAPublicKey_bio(BIO *, RSA *);
 int i2d_DSAPrivateKey_bio(BIO *, DSA *);
 
-/* These became const X509 in 1.1.0 */
-int X509_get_ext_count(X509 *);
-X509_EXTENSION *X509_get_ext(X509 *, int);
-X509_NAME *X509_get_subject_name(X509 *);
-X509_NAME *X509_get_issuer_name(X509 *);
+int X509_get_ext_count(const X509 *);
+X509_EXTENSION *X509_get_ext(const X509 *, int);
+X509_NAME *X509_get_subject_name(const X509 *);
+X509_NAME *X509_get_issuer_name(const X509 *);
 
-/* This became const ASN1_OBJECT * in 1.1.0 */
 X509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **,
-                                             ASN1_OBJECT *, int,
+                                             const ASN1_OBJECT *, int,
                                              ASN1_OCTET_STRING *);
 
 
-/* This became const X509_EXTENSION * in 1.1.0 */
-int X509_EXTENSION_get_critical(X509_EXTENSION *);
+int X509_EXTENSION_get_critical(const X509_EXTENSION *);
 
-/* This became const X509_REVOKED * in 1.1.0 */
-int X509_REVOKED_get_ext_count(X509_REVOKED *);
-X509_EXTENSION *X509_REVOKED_get_ext(X509_REVOKED *, int);
+int X509_REVOKED_get_ext_count(const X509_REVOKED *);
+X509_EXTENSION *X509_REVOKED_get_ext(const X509_REVOKED *, int);
 
 X509_REVOKED *X509_REVOKED_dup(X509_REVOKED *);
 
@@ -219,7 +215,6 @@ int i2d_EC_PUBKEY_bio(BIO *, EC_KEY *);
 EC_KEY *d2i_ECPrivateKey_bio(BIO *, EC_KEY **);
 int i2d_ECPrivateKey_bio(BIO *, EC_KEY *);
 
-/* these functions were added in 1.1.0 */
 const ASN1_INTEGER *X509_REVOKED_get0_serialNumber(const X509_REVOKED *);
 const ASN1_TIME *X509_REVOKED_get0_revocationDate(const X509_REVOKED *);
 """
diff --git a/src/_cffi_src/openssl/x509_vfy.py b/src/_cffi_src/openssl/x509_vfy.py
index 799751548..b31198863 100644
--- a/src/_cffi_src/openssl/x509_vfy.py
+++ b/src/_cffi_src/openssl/x509_vfy.py
@@ -18,7 +18,6 @@ typedef STACK_OF(X509_OBJECT) Cryptography_STACK_OF_X509_OBJECT;
 """
 
 TYPES = """
-static const long Cryptography_HAS_110_VERIFICATION_PARAMS;
 static const long Cryptography_HAS_X509_STORE_CTX_GET_ISSUER;
 
 typedef ... Cryptography_STACK_OF_ASN1_OBJECT;
@@ -211,22 +210,12 @@ X509_VERIFY_PARAM *X509_STORE_get0_param(X509_STORE *);
 Cryptography_STACK_OF_X509_OBJECT *X509_STORE_get0_objects(X509_STORE *);
 X509 *X509_OBJECT_get0_X509(X509_OBJECT *);
 
-/* added in 1.1.0 */
 X509 *X509_STORE_CTX_get0_cert(X509_STORE_CTX *);
 X509_STORE_CTX_get_issuer_fn X509_STORE_get_get_issuer(X509_STORE *);
 void X509_STORE_set_get_issuer(X509_STORE *, X509_STORE_CTX_get_issuer_fn);
 """
 
 CUSTOMIZATIONS = """
-#if CRYPTOGRAPHY_IS_LIBRESSL && CRYPTOGRAPHY_LIBRESSL_LESS_THAN_322
-static const long Cryptography_HAS_110_VERIFICATION_PARAMS = 0;
-#ifndef X509_CHECK_FLAG_NEVER_CHECK_SUBJECT
-static const long X509_CHECK_FLAG_NEVER_CHECK_SUBJECT = 0;
-#endif
-#else
-static const long Cryptography_HAS_110_VERIFICATION_PARAMS = 1;
-#endif
-
 #if CRYPTOGRAPHY_IS_LIBRESSL
 static const long Cryptography_HAS_X509_STORE_CTX_GET_ISSUER = 0;
 typedef void *X509_STORE_CTX_get_issuer_fn;
diff --git a/src/_cffi_src/openssl/x509name.py b/src/_cffi_src/openssl/x509name.py
index 37b0d9e74..6fdc2a3c1 100644
--- a/src/_cffi_src/openssl/x509name.py
+++ b/src/_cffi_src/openssl/x509name.py
@@ -32,23 +32,19 @@ void X509_NAME_ENTRY_free(X509_NAME_ENTRY *);
 int X509_NAME_get_index_by_NID(X509_NAME *, int, int);
 int X509_NAME_cmp(const X509_NAME *, const X509_NAME *);
 X509_NAME *X509_NAME_dup(X509_NAME *);
-/* These became const X509_NAME * in 1.1.0 */
-int X509_NAME_entry_count(X509_NAME *);
-X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *, int);
-char *X509_NAME_oneline(X509_NAME *, char *, int);
+int X509_NAME_entry_count(const X509_NAME *);
+X509_NAME_ENTRY *X509_NAME_get_entry(const X509_NAME *, int);
+char *X509_NAME_oneline(const X509_NAME *, char *, int);
 
-/* These became const X509_NAME_ENTRY * in 1.1.0 */
-ASN1_OBJECT *X509_NAME_ENTRY_get_object(X509_NAME_ENTRY *);
-ASN1_STRING *X509_NAME_ENTRY_get_data(X509_NAME_ENTRY *);
+ASN1_OBJECT *X509_NAME_ENTRY_get_object(const X509_NAME_ENTRY *);
+ASN1_STRING *X509_NAME_ENTRY_get_data(const X509_NAME_ENTRY *);
 int X509_NAME_add_entry(X509_NAME *, X509_NAME_ENTRY *, int, int);
 
-/* this became const unsigned char * in 1.1.0 */
-int X509_NAME_add_entry_by_NID(X509_NAME *, int, int, unsigned char *,
+int X509_NAME_add_entry_by_NID(X509_NAME *, int, int, const unsigned char *,
                                int, int, int);
 
-/* These became const ASN1_OBJECT * in 1.1.0 */
 X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **,
-                                               ASN1_OBJECT *, int,
+                                               const ASN1_OBJECT *, int,
                                                const unsigned char *, int);
 
 Cryptography_STACK_OF_X509_NAME *sk_X509_NAME_new_null(void);
diff --git a/src/_cffi_src/openssl/x509v3.py b/src/_cffi_src/openssl/x509v3.py
index 46569bdc0..863973fc0 100644
--- a/src/_cffi_src/openssl/x509v3.py
+++ b/src/_cffi_src/openssl/x509v3.py
@@ -48,8 +48,8 @@ void X509V3_set_ctx(X509V3_CTX *, X509 *, X509 *, X509_REQ *, X509_CRL *, int);
 int GENERAL_NAME_print(BIO *, GENERAL_NAME *);
 void GENERAL_NAMES_free(GENERAL_NAMES *);
 void *X509V3_EXT_d2i(X509_EXTENSION *);
-/* The last two char * args became const char * in 1.1.0 */
-X509_EXTENSION *X509V3_EXT_nconf(CONF *, X509V3_CTX *, char *, char *);
+X509_EXTENSION *X509V3_EXT_nconf(CONF *, X509V3_CTX *, const char *,
+                                 const char *);
 
 void *X509V3_set_ctx_nodb(X509V3_CTX *);
 
diff --git a/src/cryptography/__about__.py b/src/cryptography/__about__.py
index 1fe833a9c..7adbc4000 100644
--- a/src/cryptography/__about__.py
+++ b/src/cryptography/__about__.py
@@ -9,7 +9,7 @@ __all__ = [
     "__copyright__",
 ]
 
-__version__ = "38.0.2"
+__version__ = "39.0.0.dev1"
 
 __author__ = "The Python Cryptographic Authority and individual contributors"
 __copyright__ = "Copyright 2013-2022 {}".format(__author__)
diff --git a/src/cryptography/hazmat/backends/openssl/aead.py b/src/cryptography/hazmat/backends/openssl/aead.py
index f7914af5f..aa106fc3a 100644
--- a/src/cryptography/hazmat/backends/openssl/aead.py
+++ b/src/cryptography/hazmat/backends/openssl/aead.py
@@ -63,6 +63,29 @@ def _evp_cipher(cipher_name: bytes, backend: "Backend"):
     return evp_cipher
 
 
+def _aead_create_ctx(
+    backend: "Backend",
+    cipher: "_AEAD_TYPES",
+    key: bytes,
+):
+    ctx = backend._lib.EVP_CIPHER_CTX_new()
+    backend.openssl_assert(ctx != backend._ffi.NULL)
+    ctx = backend._ffi.gc(ctx, backend._lib.EVP_CIPHER_CTX_free)
+    cipher_name = _aead_cipher_name(cipher)
+    evp_cipher = _evp_cipher(cipher_name, backend)
+    key_ptr = backend._ffi.from_buffer(key)
+    res = backend._lib.EVP_CipherInit_ex(
+        ctx,
+        evp_cipher,
+        backend._ffi.NULL,
+        key_ptr,
+        backend._ffi.NULL,
+        0,
+    )
+    backend.openssl_assert(res != 0)
+    return ctx
+
+
 def _aead_setup(
     backend: "Backend",
     cipher_name: bytes,
@@ -84,8 +107,7 @@ def _aead_setup(
         int(operation == _ENCRYPT),
     )
     backend.openssl_assert(res != 0)
-    res = backend._lib.EVP_CIPHER_CTX_set_key_length(ctx, len(key))
-    backend.openssl_assert(res != 0)
+    # CCM requires the IVLEN to be set before calling SET_TAG on decrypt
     res = backend._lib.EVP_CIPHER_CTX_ctrl(
         ctx,
         backend._lib.EVP_CTRL_AEAD_SET_IVLEN,
@@ -95,10 +117,7 @@ def _aead_setup(
     backend.openssl_assert(res != 0)
     if operation == _DECRYPT:
         assert tag is not None
-        res = backend._lib.EVP_CIPHER_CTX_ctrl(
-            ctx, backend._lib.EVP_CTRL_AEAD_SET_TAG, len(tag), tag
-        )
-        backend.openssl_assert(res != 0)
+        _set_tag(backend, ctx, tag)
     elif cipher_name.endswith(b"-ccm"):
         res = backend._lib.EVP_CIPHER_CTX_ctrl(
             ctx, backend._lib.EVP_CTRL_AEAD_SET_TAG, tag_len, backend._ffi.NULL
@@ -119,6 +138,26 @@ def _aead_setup(
     return ctx
 
 
+def _set_tag(backend, ctx, tag: bytes) -> None:
+    res = backend._lib.EVP_CIPHER_CTX_ctrl(
+        ctx, backend._lib.EVP_CTRL_AEAD_SET_TAG, len(tag), tag
+    )
+    backend.openssl_assert(res != 0)
+
+
+def _set_nonce_operation(backend, ctx, nonce: bytes, operation: int) -> None:
+    nonce_ptr = backend._ffi.from_buffer(nonce)
+    res = backend._lib.EVP_CipherInit_ex(
+        ctx,
+        backend._ffi.NULL,
+        backend._ffi.NULL,
+        backend._ffi.NULL,
+        nonce_ptr,
+        int(operation == _ENCRYPT),
+    )
+    backend.openssl_assert(res != 0)
+
+
 def _set_length(backend: "Backend", ctx, data_len: int) -> None:
     intptr = backend._ffi.new("int *")
     res = backend._lib.EVP_CipherUpdate(
@@ -153,13 +192,24 @@ def _encrypt(
     data: bytes,
     associated_data: typing.List[bytes],
     tag_length: int,
+    ctx: typing.Any = None,
 ) -> bytes:
     from cryptography.hazmat.primitives.ciphers.aead import AESCCM, AESSIV
 
-    cipher_name = _aead_cipher_name(cipher)
-    ctx = _aead_setup(
-        backend, cipher_name, cipher._key, nonce, None, tag_length, _ENCRYPT
-    )
+    if ctx is None:
+        cipher_name = _aead_cipher_name(cipher)
+        ctx = _aead_setup(
+            backend,
+            cipher_name,
+            cipher._key,
+            nonce,
+            None,
+            tag_length,
+            _ENCRYPT,
+        )
+    else:
+        _set_nonce_operation(backend, ctx, nonce, _ENCRYPT)
+
     # CCM requires us to pass the length of the data before processing anything
     # However calling this with any other AEAD results in an error
     if isinstance(cipher, AESCCM):
@@ -200,6 +250,7 @@ def _decrypt(
     data: bytes,
     associated_data: typing.List[bytes],
     tag_length: int,
+    ctx: typing.Any = None,
 ) -> bytes:
     from cryptography.hazmat.primitives.ciphers.aead import AESCCM, AESSIV
 
@@ -215,10 +266,15 @@ def _decrypt(
     else:
         tag = data[-tag_length:]
         data = data[:-tag_length]
-    cipher_name = _aead_cipher_name(cipher)
-    ctx = _aead_setup(
-        backend, cipher_name, cipher._key, nonce, tag, tag_length, _DECRYPT
-    )
+    if ctx is None:
+        cipher_name = _aead_cipher_name(cipher)
+        ctx = _aead_setup(
+            backend, cipher_name, cipher._key, nonce, tag, tag_length, _DECRYPT
+        )
+    else:
+        _set_nonce_operation(backend, ctx, nonce, _DECRYPT)
+        _set_tag(backend, ctx, tag)
+
     # CCM requires us to pass the length of the data before processing anything
     # However calling this with any other AEAD results in an error
     if isinstance(cipher, AESCCM):
diff --git a/src/cryptography/hazmat/backends/openssl/backend.py b/src/cryptography/hazmat/backends/openssl/backend.py
index f8776b732..793fa2f71 100644
--- a/src/cryptography/hazmat/backends/openssl/backend.py
+++ b/src/cryptography/hazmat/backends/openssl/backend.py
@@ -186,7 +186,6 @@ class Backend:
         self._binding = binding.Binding()
         self._ffi = self._binding.ffi
         self._lib = self._binding.lib
-        self._rsa_skip_check_key = False
         self._fips_enabled = self._is_fips_enabled()
 
         self._cipher_registry = {}
@@ -203,8 +202,10 @@ class Backend:
             self._dh_types.append(self._lib.EVP_PKEY_DHX)
 
     def __repr__(self) -> str:
-        return "<OpenSSLBackend(version: {}, FIPS: {})>".format(
-            self.openssl_version_text(), self._fips_enabled
+        return "<OpenSSLBackend(version: {}, FIPS: {}, Legacy: {})>".format(
+            self.openssl_version_text(),
+            self._fips_enabled,
+            self._binding._legacy_provider_loaded,
         )
 
     def openssl_assert(
@@ -220,7 +221,7 @@ class Backend:
                 self._ffi.NULL
             )
         else:
-            mode = getattr(self._lib, "FIPS_mode", lambda: 0)()
+            mode = self._lib.FIPS_mode()
 
         if mode == 0:
             # OpenSSL without FIPS pushes an error on the error stack
@@ -403,26 +404,6 @@ class Backend:
         self.register_cipher_adapter(
             TripleDES, ECB, GetCipherByName("des-ede3")
         )
-        for mode_cls in [CBC, CFB, OFB, ECB]:
-            self.register_cipher_adapter(
-                _BlowfishInternal, mode_cls, GetCipherByName("bf-{mode.name}")
-            )
-        for mode_cls in [CBC, CFB, OFB, ECB]:
-            self.register_cipher_adapter(
-                _SEEDInternal, mode_cls, GetCipherByName("seed-{mode.name}")
-            )
-        for cipher_cls, mode_cls in itertools.product(
-            [_CAST5Internal, _IDEAInternal],
-            [CBC, OFB, CFB, ECB],
-        ):
-            self.register_cipher_adapter(
-                cipher_cls,
-                mode_cls,
-                GetCipherByName("{cipher.name}-{mode.name}"),
-            )
-        self.register_cipher_adapter(ARC4, type(None), GetCipherByName("rc4"))
-        # We don't actually support RC2, this is just used by some tests.
-        self.register_cipher_adapter(_RC2, type(None), GetCipherByName("rc2"))
         self.register_cipher_adapter(
             ChaCha20, type(None), GetCipherByName("chacha20")
         )
@@ -431,6 +412,42 @@ class Backend:
             self.register_cipher_adapter(
                 SM4, mode_cls, GetCipherByName("sm4-{mode.name}")
             )
+        # Don't register legacy ciphers if they're unavailable. Hypothetically
+        # this wouldn't be necessary because we test availability by seeing if
+        # we get an EVP_CIPHER * in the _CipherContext __init__, but OpenSSL 3
+        # will return a valid pointer even though the cipher is unavailable.
+        if (
+            self._binding._legacy_provider_loaded
+            or not self._lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+        ):
+            for mode_cls in [CBC, CFB, OFB, ECB]:
+                self.register_cipher_adapter(
+                    _BlowfishInternal,
+                    mode_cls,
+                    GetCipherByName("bf-{mode.name}"),
+                )
+            for mode_cls in [CBC, CFB, OFB, ECB]:
+                self.register_cipher_adapter(
+                    _SEEDInternal,
+                    mode_cls,
+                    GetCipherByName("seed-{mode.name}"),
+                )
+            for cipher_cls, mode_cls in itertools.product(
+                [_CAST5Internal, _IDEAInternal],
+                [CBC, OFB, CFB, ECB],
+            ):
+                self.register_cipher_adapter(
+                    cipher_cls,
+                    mode_cls,
+                    GetCipherByName("{cipher.name}-{mode.name}"),
+                )
+            self.register_cipher_adapter(
+                ARC4, type(None), GetCipherByName("rc4")
+            )
+            # We don't actually support RC2, this is just used by some tests.
+            self.register_cipher_adapter(
+                _RC2, type(None), GetCipherByName("rc2")
+            )
 
     def create_symmetric_encryption_ctx(
         self, cipher: CipherAlgorithm, mode: Mode
@@ -524,8 +541,9 @@ class Backend:
         self.openssl_assert(res == 1)
         evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
 
+        # We can skip RSA key validation here since we just generated the key
         return _RSAPrivateKey(
-            self, rsa_cdata, evp_pkey, self._rsa_skip_check_key
+            self, rsa_cdata, evp_pkey, unsafe_skip_rsa_key_validation=True
         )
 
     def generate_rsa_parameters_supported(
@@ -538,7 +556,9 @@ class Backend:
         )
 
     def load_rsa_private_numbers(
-        self, numbers: rsa.RSAPrivateNumbers
+        self,
+        numbers: rsa.RSAPrivateNumbers,
+        unsafe_skip_rsa_key_validation: bool,
     ) -> rsa.RSAPrivateKey:
         rsa._check_private_key_components(
             numbers.p,
@@ -570,7 +590,10 @@ class Backend:
         evp_pkey = self._rsa_cdata_to_evp_pkey(rsa_cdata)
 
         return _RSAPrivateKey(
-            self, rsa_cdata, evp_pkey, self._rsa_skip_check_key
+            self,
+            rsa_cdata,
+            evp_pkey,
+            unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,
         )
 
     def load_rsa_public_numbers(
@@ -635,7 +658,9 @@ class Backend:
         bio_data = self._ffi.buffer(buf[0], buf_len)[:]
         return bio_data
 
-    def _evp_pkey_to_private_key(self, evp_pkey) -> PRIVATE_KEY_TYPES:
+    def _evp_pkey_to_private_key(
+        self, evp_pkey, unsafe_skip_rsa_key_validation: bool
+    ) -> PRIVATE_KEY_TYPES:
         """
         Return the appropriate type of PrivateKey given an evp_pkey cdata
         pointer.
@@ -648,7 +673,10 @@ class Backend:
             self.openssl_assert(rsa_cdata != self._ffi.NULL)
             rsa_cdata = self._ffi.gc(rsa_cdata, self._lib.RSA_free)
             return _RSAPrivateKey(
-                self, rsa_cdata, evp_pkey, self._rsa_skip_check_key
+                self,
+                rsa_cdata,
+                evp_pkey,
+                unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,
             )
         elif (
             key_type == self._lib.EVP_PKEY_RSA_PSS
@@ -667,7 +695,9 @@ class Backend:
             res = self._lib.i2d_RSAPrivateKey_bio(bio, rsa_cdata)
             self.openssl_assert(res == 1)
             return self.load_der_private_key(
-                self._read_mem_bio(bio), password=None
+                self._read_mem_bio(bio),
+                password=None,
+                unsafe_skip_rsa_key_validation=unsafe_skip_rsa_key_validation,
             )
         elif key_type == self._lib.EVP_PKEY_DSA:
             dsa_cdata = self._lib.EVP_PKEY_get1_DSA(evp_pkey)
@@ -685,16 +715,15 @@ class Backend:
             dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
             return _DHPrivateKey(self, dh_cdata, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_ED25519", None):
-            # EVP_PKEY_ED25519 is not present in OpenSSL < 1.1.1
+            # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _Ed25519PrivateKey(self, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_X448", None):
-            # EVP_PKEY_X448 is not present in OpenSSL < 1.1.1
+            # EVP_PKEY_X448 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _X448PrivateKey(self, evp_pkey)
-        elif key_type == getattr(self._lib, "EVP_PKEY_X25519", None):
-            # EVP_PKEY_X25519 is not present in OpenSSL < 1.1.0
+        elif key_type == self._lib.EVP_PKEY_X25519:
             return _X25519PrivateKey(self, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_ED448", None):
-            # EVP_PKEY_ED448 is not present in OpenSSL < 1.1.1
+            # EVP_PKEY_ED448 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _Ed448PrivateKey(self, evp_pkey)
         else:
             raise UnsupportedAlgorithm("Unsupported key type.")
@@ -743,16 +772,15 @@ class Backend:
             dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
             return _DHPublicKey(self, dh_cdata, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_ED25519", None):
-            # EVP_PKEY_ED25519 is not present in OpenSSL < 1.1.1
+            # EVP_PKEY_ED25519 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _Ed25519PublicKey(self, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_X448", None):
-            # EVP_PKEY_X448 is not present in OpenSSL < 1.1.1
+            # EVP_PKEY_X448 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _X448PublicKey(self, evp_pkey)
-        elif key_type == getattr(self._lib, "EVP_PKEY_X25519", None):
-            # EVP_PKEY_X25519 is not present in OpenSSL < 1.1.0
+        elif key_type == self._lib.EVP_PKEY_X25519:
             return _X25519PublicKey(self, evp_pkey)
         elif key_type == getattr(self._lib, "EVP_PKEY_ED448", None):
-            # EVP_PKEY_X25519 is not present in OpenSSL < 1.1.1
+            # EVP_PKEY_ED448 is not present in CRYPTOGRAPHY_IS_LIBRESSL
             return _Ed448PublicKey(self, evp_pkey)
         else:
             raise UnsupportedAlgorithm("Unsupported key type.")
@@ -916,13 +944,16 @@ class Backend:
         return _CMACContext(self, algorithm)
 
     def load_pem_private_key(
-        self, data: bytes, password: typing.Optional[bytes]
+        self,
+        data: bytes,
+        password: typing.Optional[bytes],
+        unsafe_skip_rsa_key_validation: bool,
     ) -> PRIVATE_KEY_TYPES:
         return self._load_key(
             self._lib.PEM_read_bio_PrivateKey,
-            self._evp_pkey_to_private_key,
             data,
             password,
+            unsafe_skip_rsa_key_validation,
         )
 
     def load_pem_public_key(self, data: bytes) -> PUBLIC_KEY_TYPES:
@@ -980,7 +1011,10 @@ class Backend:
             self._handle_key_loading_error()
 
     def load_der_private_key(
-        self, data: bytes, password: typing.Optional[bytes]
+        self,
+        data: bytes,
+        password: typing.Optional[bytes],
+        unsafe_skip_rsa_key_validation: bool,
     ) -> PRIVATE_KEY_TYPES:
         # OpenSSL has a function called d2i_AutoPrivateKey that in theory
         # handles this automatically, however it doesn't handle encrypted
@@ -989,25 +1023,22 @@ class Backend:
         bio_data = self._bytes_to_bio(data)
         key = self._evp_pkey_from_der_traditional_key(bio_data, password)
         if key:
-            return self._evp_pkey_to_private_key(key)
+            return self._evp_pkey_to_private_key(
+                key, unsafe_skip_rsa_key_validation
+            )
         else:
             # Finally we try to load it with the method that handles encrypted
             # PKCS8 properly.
             return self._load_key(
                 self._lib.d2i_PKCS8PrivateKey_bio,
-                self._evp_pkey_to_private_key,
                 data,
                 password,
+                unsafe_skip_rsa_key_validation,
             )
 
     def _evp_pkey_from_der_traditional_key(self, bio_data, password):
         key = self._lib.d2i_PrivateKey_bio(bio_data.bio, self._ffi.NULL)
         if key != self._ffi.NULL:
-            # In OpenSSL 3.0.0-alpha15 there exist scenarios where the key will
-            # successfully load but errors are still put on the stack. Tracked
-            # as https://github.com/openssl/openssl/issues/14996
-            self._consume_errors()
-
             key = self._ffi.gc(key, self._lib.EVP_PKEY_free)
             if password is not None:
                 raise TypeError(
@@ -1053,9 +1084,7 @@ class Backend:
             self._consume_errors()
             res = self._lib.BIO_reset(mem_bio.bio)
             self.openssl_assert(res == 1)
-            dh_cdata = self._lib.Cryptography_d2i_DHxparams_bio(
-                mem_bio.bio, self._ffi.NULL
-            )
+            dh_cdata = self._lib.d2i_DHxparams_bio(mem_bio.bio, self._ffi.NULL)
             if dh_cdata != self._ffi.NULL:
                 dh_cdata = self._ffi.gc(dh_cdata, self._lib.DH_free)
                 return _DHParameters(self, dh_cdata)
@@ -1084,14 +1113,6 @@ class Backend:
         x509_req = self._ffi.gc(x509_req, self._lib.X509_REQ_free)
         return x509_req
 
-    def _ossl2csr(
-        self, x509_req: typing.Any
-    ) -> x509.CertificateSigningRequest:
-        bio = self._create_mem_bio_gc()
-        res = self._lib.i2d_X509_REQ_bio(bio, x509_req)
-        self.openssl_assert(res == 1)
-        return rust_x509.load_der_x509_csr(self._read_mem_bio(bio))
-
     def _crl2ossl(self, crl: x509.CertificateRevocationList) -> typing.Any:
         data = crl.public_bytes(serialization.Encoding.DER)
         mem_bio = self._bytes_to_bio(data)
@@ -1100,14 +1121,6 @@ class Backend:
         x509_crl = self._ffi.gc(x509_crl, self._lib.X509_CRL_free)
         return x509_crl
 
-    def _ossl2crl(
-        self, x509_crl: typing.Any
-    ) -> x509.CertificateRevocationList:
-        bio = self._create_mem_bio_gc()
-        res = self._lib.i2d_X509_CRL_bio(bio, x509_crl)
-        self.openssl_assert(res == 1)
-        return rust_x509.load_der_x509_crl(self._read_mem_bio(bio))
-
     def _crl_is_signature_valid(
         self,
         crl: x509.CertificateRevocationList,
@@ -1153,7 +1166,9 @@ class Backend:
         if self._lib.EVP_PKEY_cmp(key1._evp_pkey, key2._evp_pkey) != 1:
             raise ValueError("Keys do not correspond")
 
-    def _load_key(self, openssl_read_func, convert_func, data, password):
+    def _load_key(
+        self, openssl_read_func, data, password, unsafe_skip_rsa_key_validation
+    ):
         mem_bio = self._bytes_to_bio(data)
 
         userdata = self._ffi.new("CRYPTOGRAPHY_PASSWORD_DATA *")
@@ -1188,11 +1203,6 @@ class Backend:
             else:
                 self._handle_key_loading_error()
 
-        # In OpenSSL 3.0.0-alpha15 there exist scenarios where the key will
-        # successfully load but errors are still put on the stack. Tracked
-        # as https://github.com/openssl/openssl/issues/14996
-        self._consume_errors()
-
         evp_pkey = self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)
 
         if password is not None and userdata.called == 0:
@@ -1204,7 +1214,9 @@ class Backend:
             password is not None and userdata.called == 1
         ) or password is None
 
-        return convert_func(evp_pkey)
+        return self._evp_pkey_to_private_key(
+            evp_pkey, unsafe_skip_rsa_key_validation
+        )
 
     def _handle_key_loading_error(self) -> typing.NoReturn:
         errors = self._consume_errors()
@@ -1721,7 +1733,9 @@ class Backend:
         res = self._lib.DH_generate_parameters_ex(
             dh_param_cdata, key_size, generator, self._ffi.NULL
         )
-        self.openssl_assert(res == 1)
+        if res != 1:
+            errors = self._consume_errors_with_text()
+            raise ValueError("Unable to generate DH parameters", errors)
 
         return _DHParameters(self, dh_param_cdata)
 
@@ -1779,7 +1793,7 @@ class Backend:
         self.openssl_assert(res == 1)
 
         codes = self._ffi.new("int[]", 1)
-        res = self._lib.Cryptography_DH_check(dh_cdata, codes)
+        res = self._lib.DH_check(dh_cdata, codes)
         self.openssl_assert(res == 1)
 
         # DH_check will return DH_NOT_SUITABLE_GENERATOR if p % 24 does not
@@ -1868,7 +1882,7 @@ class Backend:
         self.openssl_assert(res == 1)
 
         codes = self._ffi.new("int[]", 1)
-        res = self._lib.Cryptography_DH_check(dh_cdata, codes)
+        res = self._lib.DH_check(dh_cdata, codes)
         self.openssl_assert(res == 1)
 
         return codes[0] == 0
@@ -1877,8 +1891,8 @@ class Backend:
         return self._lib.Cryptography_HAS_EVP_PKEY_DHX == 1
 
     def x25519_load_public_bytes(self, data: bytes) -> x25519.X25519PublicKey:
-        # When we drop support for CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 we can
-        # switch this to EVP_PKEY_new_raw_public_key
+        # If/when LibreSSL adds support for EVP_PKEY_new_raw_public_key we
+        # can switch to it (Cryptography_HAS_RAW_KEY)
         if len(data) != 32:
             raise ValueError("An X25519 public key is 32 bytes long")
 
@@ -1894,8 +1908,8 @@ class Backend:
     def x25519_load_private_bytes(
         self, data: bytes
     ) -> x25519.X25519PrivateKey:
-        # When we drop support for CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 we can
-        # switch this to EVP_PKEY_new_raw_private_key and drop the
+        # If/when LibreSSL adds support for EVP_PKEY_new_raw_private_key we
+        # can switch to it (Cryptography_HAS_RAW_KEY) drop the
         # zeroed_bytearray garbage.
         # OpenSSL only has facilities for loading PKCS8 formatted private
         # keys using the algorithm identifiers specified in
@@ -1980,7 +1994,7 @@ class Backend:
         if self._fips_enabled:
             return False
         return (
-            not self._lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111
+            not self._lib.CRYPTOGRAPHY_IS_LIBRESSL
             and not self._lib.CRYPTOGRAPHY_IS_BORINGSSL
         )
 
@@ -2190,11 +2204,8 @@ class Backend:
             res = self._lib.PKCS12_parse(
                 p12, password_buf, evp_pkey_ptr, x509_ptr, sk_x509_ptr
             )
-        # OpenSSL 3.0.6 leaves errors on the stack even in success, so
-        # we consume all errors unconditionally.
-        # https://github.com/openssl/openssl/issues/19389
-        self._consume_errors()
         if res == 0:
+            self._consume_errors()
             raise ValueError("Invalid password or PKCS12 data")
 
         cert = None
@@ -2203,7 +2214,11 @@ class Backend:
 
         if evp_pkey_ptr[0] != self._ffi.NULL:
             evp_pkey = self._ffi.gc(evp_pkey_ptr[0], self._lib.EVP_PKEY_free)
-            key = self._evp_pkey_to_private_key(evp_pkey)
+            # We don't support turning off RSA key validation when loading
+            # PKCS12 keys
+            key = self._evp_pkey_to_private_key(
+                evp_pkey, unsafe_skip_rsa_key_validation=False
+            )
 
         if x509_ptr[0] != self._ffi.NULL:
             x509 = self._ffi.gc(x509_ptr[0], self._lib.X509_free)
@@ -2461,62 +2476,13 @@ class Backend:
             x509 = self._lib.sk_X509_value(sk_x509, i)
             self.openssl_assert(x509 != self._ffi.NULL)
             res = self._lib.X509_up_ref(x509)
-            # When OpenSSL is less than 1.1.0 up_ref returns the current
-            # refcount. On 1.1.0+ it returns 1 for success.
-            self.openssl_assert(res >= 1)
+            self.openssl_assert(res == 1)
             x509 = self._ffi.gc(x509, self._lib.X509_free)
             cert = self._ossl2cert(x509)
             certs.append(cert)
 
         return certs
 
-    def pkcs7_serialize_certificates(
-        self,
-        certs: typing.List[x509.Certificate],
-        encoding: serialization.Encoding,
-    ):
-        certs = list(certs)
-        if not certs or not all(
-            isinstance(cert, x509.Certificate) for cert in certs
-        ):
-            raise TypeError("certs must be a list of certs with length >= 1")
-
-        if encoding not in (
-            serialization.Encoding.PEM,
-            serialization.Encoding.DER,
-        ):
-            raise TypeError("encoding must DER or PEM from the Encoding enum")
-
-        certs_sk = self._lib.sk_X509_new_null()
-        certs_sk = self._ffi.gc(certs_sk, self._lib.sk_X509_free)
-        # This list is to keep the x509 values alive until end of function
-        ossl_certs = []
-        for cert in certs:
-            ossl_cert = self._cert2ossl(cert)
-            ossl_certs.append(ossl_cert)
-            res = self._lib.sk_X509_push(certs_sk, ossl_cert)
-            self.openssl_assert(res >= 1)
-        # We use PKCS7_sign here because it creates the PKCS7 and PKCS7_SIGNED
-        # structures for us rather than requiring manual assignment.
-        p7 = self._lib.PKCS7_sign(
-            self._ffi.NULL,
-            self._ffi.NULL,
-            certs_sk,
-            self._ffi.NULL,
-            self._lib.PKCS7_PARTIAL,
-        )
-        bio_out = self._create_mem_bio_gc()
-        if encoding is serialization.Encoding.PEM:
-            res = self._lib.PEM_write_bio_PKCS7_stream(
-                bio_out, p7, self._ffi.NULL, 0
-            )
-        else:
-            assert encoding is serialization.Encoding.DER
-            res = self._lib.i2d_PKCS7_bio(bio_out, p7)
-
-        self.openssl_assert(res == 1)
-        return self._read_mem_bio(bio_out)
-
     def pkcs7_sign(
         self,
         builder: pkcs7.PKCS7SignatureBuilder,
diff --git a/src/cryptography/hazmat/backends/openssl/dh.py b/src/cryptography/hazmat/backends/openssl/dh.py
index 70364a3c6..33fed6a40 100644
--- a/src/cryptography/hazmat/backends/openssl/dh.py
+++ b/src/cryptography/hazmat/backends/openssl/dh.py
@@ -93,7 +93,7 @@ class _DHParameters(dh.DHParameters):
                 write_bio = self._backend._lib.PEM_write_bio_DHparams
         elif encoding is serialization.Encoding.DER:
             if q[0] != self._backend._ffi.NULL:
-                write_bio = self._backend._lib.Cryptography_i2d_DHxparams_bio
+                write_bio = self._backend._lib.i2d_DHxparams_bio
             else:
                 write_bio = self._backend._lib.i2d_DHparams_bio
         else:
diff --git a/src/cryptography/hazmat/backends/openssl/rsa.py b/src/cryptography/hazmat/backends/openssl/rsa.py
index 31cff1620..694829d2c 100644
--- a/src/cryptography/hazmat/backends/openssl/rsa.py
+++ b/src/cryptography/hazmat/backends/openssl/rsa.py
@@ -367,7 +367,12 @@ class _RSAPrivateKey(RSAPrivateKey):
     _key_size: int
 
     def __init__(
-        self, backend: "Backend", rsa_cdata, evp_pkey, _skip_check_key: bool
+        self,
+        backend: "Backend",
+        rsa_cdata,
+        evp_pkey,
+        *,
+        unsafe_skip_rsa_key_validation: bool,
     ):
         res: int
         # RSA_check_key is slower in OpenSSL 3.0.0 due to improved
@@ -375,7 +380,7 @@ class _RSAPrivateKey(RSAPrivateKey):
         # since users don't load new keys constantly, but for TESTING we've
         # added an init arg that allows skipping the checks. You should not
         # use this in production code unless you understand the consequences.
-        if not _skip_check_key:
+        if not unsafe_skip_rsa_key_validation:
             res = backend._lib.RSA_check_key(rsa_cdata)
             if res != 1:
                 errors = backend._consume_errors_with_text()
diff --git a/src/cryptography/hazmat/backends/openssl/x25519.py b/src/cryptography/hazmat/backends/openssl/x25519.py
index f68501a34..c09a50ac5 100644
--- a/src/cryptography/hazmat/backends/openssl/x25519.py
+++ b/src/cryptography/hazmat/backends/openssl/x25519.py
@@ -112,8 +112,8 @@ class _X25519PrivateKey(X25519PrivateKey):
         )
 
     def _raw_private_bytes(self) -> bytes:
-        # When we drop support for CRYPTOGRAPHY_OPENSSL_LESS_THAN_111 we can
-        # switch this to EVP_PKEY_new_raw_private_key
+        # If/when LibreSSL adds support for EVP_PKEY_get_raw_private_key we
+        # can switch to it (Cryptography_HAS_RAW_KEY)
         # The trick we use here is serializing to a PKCS8 key and just
         # using the last 32 bytes, which is the key itself.
         bio = self._backend._create_mem_bio_gc()
diff --git a/src/cryptography/hazmat/backends/openssl/x509.py b/src/cryptography/hazmat/backends/openssl/x509.py
deleted file mode 100644
index aa4ed106c..000000000
--- a/src/cryptography/hazmat/backends/openssl/x509.py
+++ /dev/null
@@ -1,45 +0,0 @@
-# This file is dual licensed under the terms of the Apache License, Version
-# 2.0, and the BSD License. See the LICENSE file in the root of this repository
-# for complete details.
-
-
-import warnings
-
-from cryptography import utils, x509
-
-
-# This exists for pyOpenSSL compatibility and SHOULD NOT BE USED
-# WE WILL REMOVE THIS VERY SOON.
-def _Certificate(backend, x509) -> x509.Certificate:  # noqa: N802
-    warnings.warn(
-        "This version of cryptography contains a temporary pyOpenSSL "
-        "fallback path. Upgrade pyOpenSSL now.",
-        utils.DeprecatedIn35,
-    )
-    return backend._ossl2cert(x509)
-
-
-# This exists for pyOpenSSL compatibility and SHOULD NOT BE USED
-# WE WILL REMOVE THIS VERY SOON.
-def _CertificateSigningRequest(  # noqa: N802
-    backend, x509_req
-) -> x509.CertificateSigningRequest:
-    warnings.warn(
-        "This version of cryptography contains a temporary pyOpenSSL "
-        "fallback path. Upgrade pyOpenSSL now.",
-        utils.DeprecatedIn35,
-    )
-    return backend._ossl2csr(x509_req)
-
-
-# This exists for pyOpenSSL compatibility and SHOULD NOT BE USED
-# WE WILL REMOVE THIS VERY SOON.
-def _CertificateRevocationList(  # noqa: N802
-    backend, x509_crl
-) -> x509.CertificateRevocationList:
-    warnings.warn(
-        "This version of cryptography contains a temporary pyOpenSSL "
-        "fallback path. Upgrade pyOpenSSL now.",
-        utils.DeprecatedIn35,
-    )
-    return backend._ossl2crl(x509_crl)
diff --git a/src/cryptography/hazmat/bindings/_rust/__init__.pyi b/src/cryptography/hazmat/bindings/_rust/__init__.pyi
index bab90a5ae..c33769054 100644
--- a/src/cryptography/hazmat/bindings/_rust/__init__.pyi
+++ b/src/cryptography/hazmat/bindings/_rust/__init__.pyi
@@ -20,7 +20,6 @@ class FixedPool(typing.Generic[T]):
     def __init__(
         self,
         create: typing.Callable[[], T],
-        destroy: typing.Callable[[T], None],
     ) -> None: ...
     def acquire(self) -> PoolAcquisition[T]: ...
 
diff --git a/src/cryptography/hazmat/bindings/_rust/pkcs7.pyi b/src/cryptography/hazmat/bindings/_rust/pkcs7.pyi
new file mode 100644
index 000000000..1a0b5cad5
--- /dev/null
+++ b/src/cryptography/hazmat/bindings/_rust/pkcs7.pyi
@@ -0,0 +1,9 @@
+import typing
+
+from cryptography.hazmat.primitives import serialization
+from cryptography import x509
+
+def serialize_certificates(
+    certs: typing.List[x509.Certificate],
+    encoding: serialization.Encoding,
+) -> bytes: ...
diff --git a/src/cryptography/hazmat/bindings/openssl/_conditional.py b/src/cryptography/hazmat/bindings/openssl/_conditional.py
index 10f307af7..7215d39f0 100644
--- a/src/cryptography/hazmat/bindings/openssl/_conditional.py
+++ b/src/cryptography/hazmat/bindings/openssl/_conditional.py
@@ -19,10 +19,6 @@ def cryptography_has_ssl3_method() -> typing.List[str]:
     ]
 
 
-def cryptography_has_110_verification_params() -> typing.List[str]:
-    return ["X509_CHECK_FLAG_NEVER_CHECK_SUBJECT"]
-
-
 def cryptography_has_set_cert_cb() -> typing.List[str]:
     return [
         "SSL_CTX_set_cert_cb",
@@ -55,6 +51,8 @@ def cryptography_has_scrypt() -> typing.List[str]:
 def cryptography_has_evp_pkey_dhx() -> typing.List[str]:
     return [
         "EVP_PKEY_DHX",
+        "d2i_DHxparams_bio",
+        "i2d_DHxparams_bio",
     ]
 
 
@@ -92,13 +90,6 @@ def cryptography_has_poly1305() -> typing.List[str]:
     ]
 
 
-def cryptography_has_oneshot_evp_digest_sign_verify() -> typing.List[str]:
-    return [
-        "EVP_DigestSign",
-        "EVP_DigestVerify",
-    ]
-
-
 def cryptography_has_evp_digestfinal_xof() -> typing.List[str]:
     return [
         "EVP_DigestFinalXOF",
@@ -159,13 +150,6 @@ def cryptography_has_openssl_cleanup() -> typing.List[str]:
     ]
 
 
-def cryptography_has_tlsv13() -> typing.List[str]:
-    return [
-        "TLS1_3_VERSION",
-        "SSL_OP_NO_TLSv1_3",
-    ]
-
-
 def cryptography_has_tlsv13_functions() -> typing.List[str]:
     return [
         "SSL_VERIFY_POST_HANDSHAKE",
@@ -180,13 +164,6 @@ def cryptography_has_tlsv13_functions() -> typing.List[str]:
     ]
 
 
-def cryptography_has_keylog() -> typing.List[str]:
-    return [
-        "SSL_CTX_set_keylog_callback",
-        "SSL_CTX_get_keylog_callback",
-    ]
-
-
 def cryptography_has_raw_key() -> typing.List[str]:
     return [
         "EVP_PKEY_new_raw_private_key",
@@ -230,15 +207,6 @@ def cryptography_has_srtp() -> typing.List[str]:
     ]
 
 
-def cryptography_has_get_proto_version() -> typing.List[str]:
-    return [
-        "SSL_CTX_get_min_proto_version",
-        "SSL_CTX_get_max_proto_version",
-        "SSL_get_min_proto_version",
-        "SSL_get_max_proto_version",
-    ]
-
-
 def cryptography_has_providers() -> typing.List[str]:
     return [
         "OSSL_PROVIDER_load",
@@ -321,6 +289,10 @@ def cryptography_has_ssl_op_ignore_unexpected_eof() -> typing.List[str]:
     ]
 
 
+def cryptography_has_get_extms_support() -> typing.List[str]:
+    return ["SSL_get_extms_support"]
+
+
 # This is a mapping of
 # {condition: function-returning-names-dependent-on-that-condition} so we can
 # loop over them and delete unsupported names at runtime. It will be removed
@@ -329,9 +301,6 @@ def cryptography_has_ssl_op_ignore_unexpected_eof() -> typing.List[str]:
 CONDITIONAL_NAMES = {
     "Cryptography_HAS_EC2M": cryptography_has_ec2m,
     "Cryptography_HAS_SSL3_METHOD": cryptography_has_ssl3_method,
-    "Cryptography_HAS_110_VERIFICATION_PARAMS": (
-        cryptography_has_110_verification_params
-    ),
     "Cryptography_HAS_SET_CERT_CB": cryptography_has_set_cert_cb,
     "Cryptography_HAS_SSL_ST": cryptography_has_ssl_st,
     "Cryptography_HAS_TLS_ST": cryptography_has_tls_st,
@@ -344,9 +313,6 @@ CONDITIONAL_NAMES = {
     "Cryptography_HAS_ED448": cryptography_has_ed448,
     "Cryptography_HAS_ED25519": cryptography_has_ed25519,
     "Cryptography_HAS_POLY1305": cryptography_has_poly1305,
-    "Cryptography_HAS_ONESHOT_EVP_DIGEST_SIGN_VERIFY": (
-        cryptography_has_oneshot_evp_digest_sign_verify
-    ),
     "Cryptography_HAS_EVP_PKEY_get_set_tls_encodedpoint": (
         cryptography_has_evp_pkey_get_set_tls_encodedpoint
     ),
@@ -356,9 +322,7 @@ CONDITIONAL_NAMES = {
     "Cryptography_HAS_PSK_TLSv1_3": cryptography_has_psk_tlsv13,
     "Cryptography_HAS_CUSTOM_EXT": cryptography_has_custom_ext,
     "Cryptography_HAS_OPENSSL_CLEANUP": cryptography_has_openssl_cleanup,
-    "Cryptography_HAS_TLSv1_3": cryptography_has_tlsv13,
     "Cryptography_HAS_TLSv1_3_FUNCTIONS": cryptography_has_tlsv13_functions,
-    "Cryptography_HAS_KEYLOG": cryptography_has_keylog,
     "Cryptography_HAS_RAW_KEY": cryptography_has_raw_key,
     "Cryptography_HAS_EVP_DIGESTFINAL_XOF": (
         cryptography_has_evp_digestfinal_xof
@@ -366,7 +330,6 @@ CONDITIONAL_NAMES = {
     "Cryptography_HAS_ENGINE": cryptography_has_engine,
     "Cryptography_HAS_VERIFIED_CHAIN": cryptography_has_verified_chain,
     "Cryptography_HAS_SRTP": cryptography_has_srtp,
-    "Cryptography_HAS_GET_PROTO_VERSION": cryptography_has_get_proto_version,
     "Cryptography_HAS_PROVIDERS": cryptography_has_providers,
     "Cryptography_HAS_OP_NO_RENEGOTIATION": (
         cryptography_has_op_no_renegotiation
@@ -385,4 +348,5 @@ CONDITIONAL_NAMES = {
     "Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF": (
         cryptography_has_ssl_op_ignore_unexpected_eof
     ),
+    "Cryptography_HAS_GET_EXTMS_SUPPORT": cryptography_has_get_extms_support,
 }
diff --git a/src/cryptography/hazmat/bindings/openssl/binding.py b/src/cryptography/hazmat/bindings/openssl/binding.py
index 2b4c574b4..a1602164d 100644
--- a/src/cryptography/hazmat/bindings/openssl/binding.py
+++ b/src/cryptography/hazmat/bindings/openssl/binding.py
@@ -2,14 +2,14 @@
 # 2.0, and the BSD License. See the LICENSE file in the root of this repository
 # for complete details.
 
-
+import os
+import sys
 import threading
 import types
 import typing
 import warnings
 
 import cryptography
-from cryptography import utils
 from cryptography.exceptions import InternalError
 from cryptography.hazmat.bindings._openssl import ffi, lib
 from cryptography.hazmat.bindings.openssl._conditional import CONDITIONAL_NAMES
@@ -99,7 +99,21 @@ def _openssl_assert(
         )
 
 
-def build_conditional_library(lib, conditional_names):
+def _legacy_provider_error(loaded: bool) -> None:
+    if not loaded:
+        raise RuntimeError(
+            "OpenSSL 3.0's legacy provider failed to load. This is a fatal "
+            "error by default, but cryptography supports running without "
+            "legacy algorithms by setting the environment variable "
+            "CRYPTOGRAPHY_OPENSSL_NO_LEGACY. If you did not expect this error,"
+            " you have likely made a mistake with your OpenSSL configuration."
+        )
+
+
+def build_conditional_library(
+    lib: typing.Any,
+    conditional_names: typing.Dict[str, typing.Callable[[], typing.List[str]]],
+) -> typing.Any:
     conditional_lib = types.ModuleType("lib")
     conditional_lib._original_lib = lib  # type: ignore[attr-defined]
     excluded_names = set()
@@ -123,10 +137,11 @@ class Binding:
     ffi = ffi
     _lib_loaded = False
     _init_lock = threading.Lock()
-    _legacy_provider: typing.Any = None
-    _default_provider: typing.Any = None
+    _legacy_provider: typing.Any = ffi.NULL
+    _legacy_provider_loaded = False
+    _default_provider: typing.Any = ffi.NULL
 
-    def __init__(self):
+    def __init__(self) -> None:
         self._ensure_ffi_initialized()
 
     def _enable_fips(self) -> None:
@@ -146,7 +161,7 @@ class Binding:
         _openssl_assert(self.lib, res == 1)
 
     @classmethod
-    def _register_osrandom_engine(cls):
+    def _register_osrandom_engine(cls) -> None:
         # Clear any errors extant in the queue before we start. In many
         # scenarios other things may be interacting with OpenSSL in the same
         # process space and it has proven untenable to assume that they will
@@ -158,7 +173,7 @@ class Binding:
             _openssl_assert(cls.lib, result in (1, 2))
 
     @classmethod
-    def _ensure_ffi_initialized(cls):
+    def _ensure_ffi_initialized(cls) -> None:
         with cls._init_lock:
             if not cls._lib_loaded:
                 cls.lib = build_conditional_library(lib, CONDITIONAL_NAMES)
@@ -170,12 +185,15 @@ class Binding:
                 # are ugly legacy, but we aren't going to get rid of them
                 # any time soon.
                 if cls.lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:
-                    cls._legacy_provider = cls.lib.OSSL_PROVIDER_load(
-                        cls.ffi.NULL, b"legacy"
-                    )
-                    _openssl_assert(
-                        cls.lib, cls._legacy_provider != cls.ffi.NULL
-                    )
+                    if not os.environ.get("CRYPTOGRAPHY_OPENSSL_NO_LEGACY"):
+                        cls._legacy_provider = cls.lib.OSSL_PROVIDER_load(
+                            cls.ffi.NULL, b"legacy"
+                        )
+                        cls._legacy_provider_loaded = (
+                            cls._legacy_provider != cls.ffi.NULL
+                        )
+                        _legacy_provider_error(cls._legacy_provider_loaded)
+
                     cls._default_provider = cls.lib.OSSL_PROVIDER_load(
                         cls.ffi.NULL, b"default"
                     )
@@ -184,25 +202,11 @@ class Binding:
                     )
 
     @classmethod
-    def init_static_locks(cls):
+    def init_static_locks(cls) -> None:
         cls._ensure_ffi_initialized()
 
 
-def _verify_openssl_version(lib):
-    if (
-        lib.CRYPTOGRAPHY_OPENSSL_LESS_THAN_111
-        and not lib.CRYPTOGRAPHY_IS_LIBRESSL
-        and not lib.CRYPTOGRAPHY_IS_BORINGSSL
-    ):
-        warnings.warn(
-            "OpenSSL version 1.1.0 is no longer supported by the OpenSSL "
-            "project, please upgrade. The next release of cryptography will "
-            "drop support for OpenSSL 1.1.0.",
-            utils.DeprecatedIn37,
-        )
-
-
-def _verify_package_version(version):
+def _verify_package_version(version: str) -> None:
     # Occasionally we run into situations where the version of the Python
     # package does not match the version of the shared object that is loaded.
     # This may occur in environments where multiple versions of cryptography
@@ -227,4 +231,14 @@ _verify_package_version(cryptography.__version__)
 
 Binding.init_static_locks()
 
-_verify_openssl_version(Binding.lib)
+if (
+    sys.platform == "win32"
+    and os.environ.get("PROCESSOR_ARCHITEW6432") is not None
+):
+    warnings.warn(
+        "You are using cryptography on a 32-bit Python on a 64-bit Windows "
+        "Operating System. Cryptography will be significantly faster if you "
+        "switch to using a 64-bit Python.",
+        UserWarning,
+        stacklevel=2,
+    )
diff --git a/src/cryptography/hazmat/primitives/asymmetric/ec.py b/src/cryptography/hazmat/primitives/asymmetric/ec.py
index 3aaa382a8..4d949da5e 100644
--- a/src/cryptography/hazmat/primitives/asymmetric/ec.py
+++ b/src/cryptography/hazmat/primitives/asymmetric/ec.py
@@ -5,7 +5,6 @@
 
 import abc
 import typing
-import warnings
 
 from cryptography import utils
 from cryptography.hazmat._oid import ObjectIdentifier
@@ -363,50 +362,6 @@ class EllipticCurvePublicNumbers:
 
         return ossl.load_elliptic_curve_public_numbers(self)
 
-    def encode_point(self) -> bytes:
-        warnings.warn(
-            "encode_point has been deprecated on EllipticCurvePublicNumbers"
-            " and will be removed in a future version. Please use "
-            "EllipticCurvePublicKey.public_bytes to obtain both "
-            "compressed and uncompressed point encoding.",
-            utils.PersistentlyDeprecated2019,
-            stacklevel=2,
-        )
-        # key_size is in bits. Convert to bytes and round up
-        byte_length = (self.curve.key_size + 7) // 8
-        return (
-            b"\x04"
-            + utils.int_to_bytes(self.x, byte_length)
-            + utils.int_to_bytes(self.y, byte_length)
-        )
-
-    @classmethod
-    def from_encoded_point(
-        cls, curve: EllipticCurve, data: bytes
-    ) -> "EllipticCurvePublicNumbers":
-        if not isinstance(curve, EllipticCurve):
-            raise TypeError("curve must be an EllipticCurve instance")
-
-        warnings.warn(
-            "Support for unsafe construction of public numbers from "
-            "encoded data will be removed in a future version. "
-            "Please use EllipticCurvePublicKey.from_encoded_point",
-            utils.PersistentlyDeprecated2019,
-            stacklevel=2,
-        )
-
-        if data.startswith(b"\x04"):
-            # key_size is in bits. Convert to bytes and round up
-            byte_length = (curve.key_size + 7) // 8
-            if len(data) == 2 * byte_length + 1:
-                x = int.from_bytes(data[1 : byte_length + 1], "big")
-                y = int.from_bytes(data[byte_length + 1 :], "big")
-                return cls(x, y, curve)
-            else:
-                raise ValueError("Invalid elliptic curve point data length")
-        else:
-            raise ValueError("Unsupported elliptic curve point type")
-
     @property
     def curve(self) -> EllipticCurve:
         return self._curve
diff --git a/src/cryptography/hazmat/primitives/asymmetric/rsa.py b/src/cryptography/hazmat/primitives/asymmetric/rsa.py
index 5ffe767cd..36d360f22 100644
--- a/src/cryptography/hazmat/primitives/asymmetric/rsa.py
+++ b/src/cryptography/hazmat/primitives/asymmetric/rsa.py
@@ -354,12 +354,19 @@ class RSAPrivateNumbers:
     def public_numbers(self) -> "RSAPublicNumbers":
         return self._public_numbers
 
-    def private_key(self, backend: typing.Any = None) -> RSAPrivateKey:
+    def private_key(
+        self,
+        backend: typing.Any = None,
+        *,
+        unsafe_skip_rsa_key_validation: bool = False,
+    ) -> RSAPrivateKey:
         from cryptography.hazmat.backends.openssl.backend import (
             backend as ossl,
         )
 
-        return ossl.load_rsa_private_numbers(self)
+        return ossl.load_rsa_private_numbers(
+            self, unsafe_skip_rsa_key_validation
+        )
 
     def __eq__(self, other: object) -> bool:
         if not isinstance(other, RSAPrivateNumbers):
diff --git a/src/cryptography/hazmat/primitives/ciphers/aead.py b/src/cryptography/hazmat/primitives/ciphers/aead.py
index 3cdb3ebe4..16c97a644 100644
--- a/src/cryptography/hazmat/primitives/ciphers/aead.py
+++ b/src/cryptography/hazmat/primitives/ciphers/aead.py
@@ -9,6 +9,7 @@ import typing
 from cryptography import exceptions, utils
 from cryptography.hazmat.backends.openssl import aead
 from cryptography.hazmat.backends.openssl.backend import backend
+from cryptography.hazmat.bindings._rust import FixedPool
 
 
 class ChaCha20Poly1305:
@@ -26,11 +27,15 @@ class ChaCha20Poly1305:
             raise ValueError("ChaCha20Poly1305 key must be 32 bytes.")
 
         self._key = key
+        self._pool = FixedPool(self._create_fn)
 
     @classmethod
     def generate_key(cls) -> bytes:
         return os.urandom(32)
 
+    def _create_fn(self):
+        return aead._aead_create_ctx(backend, self, self._key)
+
     def encrypt(
         self,
         nonce: bytes,
@@ -47,7 +52,10 @@ class ChaCha20Poly1305:
             )
 
         self._check_params(nonce, data, associated_data)
-        return aead._encrypt(backend, self, nonce, data, [associated_data], 16)
+        with self._pool.acquire() as ctx:
+            return aead._encrypt(
+                backend, self, nonce, data, [associated_data], 16, ctx
+            )
 
     def decrypt(
         self,
@@ -59,7 +67,10 @@ class ChaCha20Poly1305:
             associated_data = b""
 
         self._check_params(nonce, data, associated_data)
-        return aead._decrypt(backend, self, nonce, data, [associated_data], 16)
+        with self._pool.acquire() as ctx:
+            return aead._decrypt(
+                backend, self, nonce, data, [associated_data], 16, ctx
+            )
 
     def _check_params(
         self,
@@ -355,6 +366,8 @@ class AESSIV(object):
         associated_data: typing.List,
     ) -> None:
         utils._check_bytes("data", data)
+        if len(data) == 0:
+            raise ValueError("data must not be zero length")
         if not isinstance(associated_data, list) or not all(
             isinstance(x, bytes) for x in associated_data
         ):
diff --git a/src/cryptography/hazmat/primitives/serialization/base.py b/src/cryptography/hazmat/primitives/serialization/base.py
index 059b6e40f..8a8417664 100644
--- a/src/cryptography/hazmat/primitives/serialization/base.py
+++ b/src/cryptography/hazmat/primitives/serialization/base.py
@@ -16,10 +16,14 @@ def load_pem_private_key(
     data: bytes,
     password: typing.Optional[bytes],
     backend: typing.Any = None,
+    *,
+    unsafe_skip_rsa_key_validation: bool = False,
 ) -> PRIVATE_KEY_TYPES:
     from cryptography.hazmat.backends.openssl.backend import backend as ossl
 
-    return ossl.load_pem_private_key(data, password)
+    return ossl.load_pem_private_key(
+        data, password, unsafe_skip_rsa_key_validation
+    )
 
 
 def load_pem_public_key(
@@ -42,10 +46,14 @@ def load_der_private_key(
     data: bytes,
     password: typing.Optional[bytes],
     backend: typing.Any = None,
+    *,
+    unsafe_skip_rsa_key_validation: bool = False,
 ) -> PRIVATE_KEY_TYPES:
     from cryptography.hazmat.backends.openssl.backend import backend as ossl
 
-    return ossl.load_der_private_key(data, password)
+    return ossl.load_der_private_key(
+        data, password, unsafe_skip_rsa_key_validation
+    )
 
 
 def load_der_public_key(
diff --git a/src/cryptography/hazmat/primitives/serialization/pkcs7.py b/src/cryptography/hazmat/primitives/serialization/pkcs7.py
index 664141682..1d3c7b124 100644
--- a/src/cryptography/hazmat/primitives/serialization/pkcs7.py
+++ b/src/cryptography/hazmat/primitives/serialization/pkcs7.py
@@ -6,6 +6,7 @@ import typing
 
 from cryptography import utils
 from cryptography import x509
+from cryptography.hazmat.bindings._rust import pkcs7 as rust_pkcs7
 from cryptography.hazmat.primitives import hashes, serialization
 from cryptography.hazmat.primitives.asymmetric import ec, rsa
 from cryptography.utils import _check_byteslike
@@ -27,13 +28,10 @@ def serialize_certificates(
     certs: typing.List[x509.Certificate],
     encoding: serialization.Encoding,
 ) -> bytes:
-    from cryptography.hazmat.backends.openssl.backend import backend
-
-    return backend.pkcs7_serialize_certificates(certs, encoding)
+    return rust_pkcs7.serialize_certificates(certs, encoding)
 
 
 _ALLOWED_PKCS7_HASH_TYPES = typing.Union[
-    hashes.SHA1,
     hashes.SHA224,
     hashes.SHA256,
     hashes.SHA384,
diff --git a/src/cryptography/hazmat/primitives/serialization/ssh.py b/src/cryptography/hazmat/primitives/serialization/ssh.py
index e06b8230d..7125badb4 100644
--- a/src/cryptography/hazmat/primitives/serialization/ssh.py
+++ b/src/cryptography/hazmat/primitives/serialization/ssh.py
@@ -174,7 +174,9 @@ class _FragList:
 
     flist: typing.List[bytes]
 
-    def __init__(self, init: typing.List[bytes] = None) -> None:
+    def __init__(
+        self, init: typing.Optional[typing.List[bytes]] = None
+    ) -> None:
         self.flist = []
         if init:
             self.flist.extend(init)
diff --git a/src/cryptography/utils.py b/src/cryptography/utils.py
index 67d813bef..7f4a4799b 100644
--- a/src/cryptography/utils.py
+++ b/src/cryptography/utils.py
@@ -5,7 +5,6 @@
 
 import abc
 import enum
-import inspect
 import sys
 import types
 import typing
@@ -21,11 +20,9 @@ class CryptographyDeprecationWarning(UserWarning):
 # Several APIs were deprecated with no specific end-of-life date because of the
 # ubiquity of their use. They should not be removed until we agree on when that
 # cycle ends.
-PersistentlyDeprecated2019 = CryptographyDeprecationWarning
-DeprecatedIn35 = CryptographyDeprecationWarning
 DeprecatedIn36 = CryptographyDeprecationWarning
 DeprecatedIn37 = CryptographyDeprecationWarning
-DeprecatedIn38 = CryptographyDeprecationWarning
+DeprecatedIn39 = CryptographyDeprecationWarning
 
 
 def _check_bytes(name: str, value: bytes) -> None:
@@ -50,37 +47,14 @@ class InterfaceNotImplemented(Exception):
     pass
 
 
-def strip_annotation(signature: inspect.Signature) -> inspect.Signature:
-    return inspect.Signature(
-        [
-            param.replace(annotation=inspect.Parameter.empty)
-            for param in signature.parameters.values()
-        ]
-    )
-
-
+# DeprecatedIn39 -- Our only known consumer is aws-encryption-sdk, but we've
+# made this a no-op to avoid breaking old versions.
 def verify_interface(
     iface: abc.ABCMeta, klass: object, *, check_annotations: bool = False
 ):
-    for method in iface.__abstractmethods__:
-        if not hasattr(klass, method):
-            raise InterfaceNotImplemented(
-                "{} is missing a {!r} method".format(klass, method)
-            )
-        if isinstance(getattr(iface, method), abc.abstractproperty):
-            # Can't properly verify these yet.
-            continue
-        sig = inspect.signature(getattr(iface, method))
-        actual = inspect.signature(getattr(klass, method))
-        if check_annotations:
-            ok = sig == actual
-        else:
-            ok = strip_annotation(sig) == strip_annotation(actual)
-        if not ok:
-            raise InterfaceNotImplemented(
-                "{}.{}'s signature differs from the expected. Expected: "
-                "{!r}. Received: {!r}".format(klass, method, sig, actual)
-            )
+    # Exists exclusively for `aws-encryption-sdk` which relies on it existing,
+    # even though it was never a public API.
+    pass
 
 
 class _DeprecatedValue:
diff --git a/src/cryptography/x509/extensions.py b/src/cryptography/x509/extensions.py
index cc8f25ef4..36be6f253 100644
--- a/src/cryptography/x509/extensions.py
+++ b/src/cryptography/x509/extensions.py
@@ -589,6 +589,11 @@ class DistributionPoint:
                 "You cannot provide both full_name and relative_name, at "
                 "least one must be None."
             )
+        if not full_name and not relative_name and not crl_issuer:
+            raise ValueError(
+                "Either full_name, relative_name or crl_issuer must be "
+                "provided."
+            )
 
         if full_name is not None:
             full_name = list(full_name)
@@ -625,12 +630,6 @@ class DistributionPoint:
                 "DistributionPoint"
             )
 
-        if reasons and not crl_issuer and not (full_name or relative_name):
-            raise ValueError(
-                "You must supply crl_issuer, full_name, or relative_name when "
-                "reasons is not None"
-            )
-
         self._full_name = full_name
         self._relative_name = relative_name
         self._reasons = reasons
diff --git a/src/cryptography/x509/ocsp.py b/src/cryptography/x509/ocsp.py
index c01e77a83..0e59fa4bc 100644
--- a/src/cryptography/x509/ocsp.py
+++ b/src/cryptography/x509/ocsp.py
@@ -375,9 +375,13 @@ class OCSPRequestBuilder:
                 x509.Certificate, x509.Certificate, hashes.HashAlgorithm
             ]
         ] = None,
+        request_hash: typing.Optional[
+            typing.Tuple[bytes, bytes, int, hashes.HashAlgorithm]
+        ] = None,
         extensions: typing.List[x509.Extension[x509.ExtensionType]] = [],
     ) -> None:
         self._request = request
+        self._request_hash = request_hash
         self._extensions = extensions
 
     def add_certificate(
@@ -386,7 +390,7 @@ class OCSPRequestBuilder:
         issuer: x509.Certificate,
         algorithm: hashes.HashAlgorithm,
     ) -> "OCSPRequestBuilder":
-        if self._request is not None:
+        if self._request is not None or self._request_hash is not None:
             raise ValueError("Only one certificate can be added to a request")
 
         _verify_algorithm(algorithm)
@@ -395,7 +399,39 @@ class OCSPRequestBuilder:
         ):
             raise TypeError("cert and issuer must be a Certificate")
 
-        return OCSPRequestBuilder((cert, issuer, algorithm), self._extensions)
+        return OCSPRequestBuilder(
+            (cert, issuer, algorithm), self._request_hash, self._extensions
+        )
+
+    def add_certificate_by_hash(
+        self,
+        issuer_name_hash: bytes,
+        issuer_key_hash: bytes,
+        serial_number: int,
+        algorithm: hashes.HashAlgorithm,
+    ) -> "OCSPRequestBuilder":
+        if self._request is not None or self._request_hash is not None:
+            raise ValueError("Only one certificate can be added to a request")
+
+        if not isinstance(serial_number, int):
+            raise TypeError("serial_number must be an integer")
+
+        _verify_algorithm(algorithm)
+        utils._check_bytes("issuer_name_hash", issuer_name_hash)
+        utils._check_bytes("issuer_key_hash", issuer_key_hash)
+        if algorithm.digest_size != len(
+            issuer_name_hash
+        ) or algorithm.digest_size != len(issuer_key_hash):
+            raise ValueError(
+                "issuer_name_hash and issuer_key_hash must be the same length "
+                "as the digest size of the algorithm"
+            )
+
+        return OCSPRequestBuilder(
+            self._request,
+            (issuer_name_hash, issuer_key_hash, serial_number, algorithm),
+            self._extensions,
+        )
 
     def add_extension(
         self, extval: x509.ExtensionType, critical: bool
@@ -407,11 +443,11 @@ class OCSPRequestBuilder:
         _reject_duplicate_extension(extension, self._extensions)
 
         return OCSPRequestBuilder(
-            self._request, self._extensions + [extension]
+            self._request, self._request_hash, self._extensions + [extension]
         )
 
     def build(self) -> OCSPRequest:
-        if self._request is None:
+        if self._request is None and self._request_hash is None:
             raise ValueError("You must add a certificate before building")
 
         return ocsp.create_ocsp_request(self)
diff --git a/src/rust/Cargo.lock b/src/rust/Cargo.lock
index 4a0ecfd58..6d5802b42 100644
--- a/src/rust/Cargo.lock
+++ b/src/rust/Cargo.lock
@@ -25,9 +25,9 @@ dependencies = [
 
 [[package]]
 name = "asn1"
-version = "0.12.2"
+version = "0.12.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "22c27c85cd71c1bf4373c7c1aa752b73d2df799277c0930af16fffbf3444f210"
+checksum = "a53789014a5231ee21e6af6d89d42680d73db33ad2ec83ee6fad801249432bad"
 dependencies = [
  "asn1_derive",
  "chrono",
@@ -35,9 +35,9 @@ dependencies = [
 
 [[package]]
 name = "asn1_derive"
-version = "0.12.2"
+version = "0.12.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d48d1854a01241e8d22f8f5ae4e2dc332f66c5946e1772f5576886d83e18e1b7"
+checksum = "d9a08da126b90ce7a577f8e6986513dea0243c114d7d5d88abece6168b0823db"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -52,9 +52,9 @@ checksum = "d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa"
 
 [[package]]
 name = "base64"
-version = "0.13.0"
+version = "0.13.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "904dfeac50f3cdaba28fc6f57fdcddb75f49ed61346676a78c4ffe55877802fd"
+checksum = "9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8"
 
 [[package]]
 name = "bitflags"
@@ -68,6 +68,12 @@ version = "3.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "37ccbd214614c6783386c1af30caf03192f17891059cecc394b4fb119e363de3"
 
+[[package]]
+name = "cc"
+version = "1.0.76"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "76a284da2e6fe2092f2353e51713435363112dfd60030e22add80be333fb928f"
+
 [[package]]
 name = "cfg-if"
 version = "1.0.0"
@@ -76,9 +82,9 @@ checksum = "baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd"
 
 [[package]]
 name = "chrono"
-version = "0.4.22"
+version = "0.4.23"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bfd4d1b31faaa3a89d7934dbded3111da0d2ef28e3ebccdb4f0179f5929d1ef1"
+checksum = "16b0a3d9ed01224b22057780a37bb8c5dbfe1be8ba48678e7bf57ec4b385411f"
 dependencies = [
  "iana-time-zone",
  "num-integer",
@@ -86,6 +92,16 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "codespan-reporting"
+version = "0.11.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3538270d33cc669650c4b093848450d380def10c331d38c768e34cac80576e6e"
+dependencies = [
+ "termcolor",
+ "unicode-width",
+]
+
 [[package]]
 name = "core-foundation-sys"
 version = "0.8.3"
@@ -104,20 +120,74 @@ dependencies = [
  "pyo3",
 ]
 
+[[package]]
+name = "cxx"
+version = "1.0.81"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "97abf9f0eca9e52b7f81b945524e76710e6cb2366aead23b7d4fbf72e281f888"
+dependencies = [
+ "cc",
+ "cxxbridge-flags",
+ "cxxbridge-macro",
+ "link-cplusplus",
+]
+
+[[package]]
+name = "cxx-build"
+version = "1.0.81"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7cc32cc5fea1d894b77d269ddb9f192110069a8a9c1f1d441195fba90553dea3"
+dependencies = [
+ "cc",
+ "codespan-reporting",
+ "once_cell",
+ "proc-macro2",
+ "quote",
+ "scratch",
+ "syn",
+]
+
+[[package]]
+name = "cxxbridge-flags"
+version = "1.0.81"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8ca220e4794c934dc6b1207c3b42856ad4c302f2df1712e9f8d2eec5afaacf1f"
+
+[[package]]
+name = "cxxbridge-macro"
+version = "1.0.81"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b846f081361125bfc8dc9d3940c84e1fd83ba54bbca7b17cd29483c828be0704"
+dependencies = [
+ "proc-macro2",
+ "quote",
+ "syn",
+]
+
 [[package]]
 name = "iana-time-zone"
-version = "0.1.47"
+version = "0.1.53"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4c495f162af0bf17656d0014a0eded5f3cd2f365fdd204548c2869db89359dc7"
+checksum = "64c122667b287044802d6ce17ee2ddf13207ed924c712de9a66a5814d5b64765"
 dependencies = [
  "android_system_properties",
  "core-foundation-sys",
+ "iana-time-zone-haiku",
  "js-sys",
- "once_cell",
  "wasm-bindgen",
  "winapi",
 ]
 
+[[package]]
+name = "iana-time-zone-haiku"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0703ae284fc167426161c2e3f1da3ea71d94b21bedbcc9494e92b28e334e3dca"
+dependencies = [
+ "cxx",
+ "cxx-build",
+]
+
 [[package]]
 name = "indoc"
 version = "0.3.6"
@@ -152,24 +222,33 @@ dependencies = [
 
 [[package]]
 name = "js-sys"
-version = "0.3.59"
+version = "0.3.60"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "258451ab10b34f8af53416d1fdab72c22e805f0c92a1136d59470ec0b11138b2"
+checksum = "49409df3e3bf0856b916e2ceaca09ee28e6871cf7d9ce97a692cacfdb2a25a47"
 dependencies = [
  "wasm-bindgen",
 ]
 
 [[package]]
 name = "libc"
-version = "0.2.132"
+version = "0.2.137"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc7fcc620a3bff7cdd7a365be3376c97191aeaccc2a603e600951e452615bf89"
+
+[[package]]
+name = "link-cplusplus"
+version = "1.0.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5"
+checksum = "9272ab7b96c9046fbc5bc56c06c117cb639fe2d509df0c421cad82d2915cf369"
+dependencies = [
+ "cc",
+]
 
 [[package]]
 name = "lock_api"
-version = "0.4.8"
+version = "0.4.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9f80bf5aacaf25cbfc8210d1cfb718f2bf3b11c4c54e5afe36c236853a8ec390"
+checksum = "435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df"
 dependencies = [
  "autocfg",
  "scopeguard",
@@ -211,9 +290,9 @@ checksum = "2f7254b99e31cad77da24b08ebf628882739a608578bb1bcdfc1f9c21260d7c0"
 
 [[package]]
 name = "ouroboros"
-version = "0.15.4"
+version = "0.15.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7f56a2b0aa5fc88687aaf63e85a7974422790ce3419a2e1a15870f8a55227822"
+checksum = "dfbb50b356159620db6ac971c6d5c9ab788c9cc38a6f49619fca2a27acb062ca"
 dependencies = [
  "aliasable",
  "ouroboros_macro",
@@ -221,9 +300,9 @@ dependencies = [
 
 [[package]]
 name = "ouroboros_macro"
-version = "0.15.4"
+version = "0.15.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6c40641e27d0eb38cae3dee081d920104d2db47a8e853c1a592ef68d33f5ebf4"
+checksum = "4a0d9d1a6191c4f391f87219d1ea42b23f09ee84d64763cd05ee6ea88d9f384d"
 dependencies = [
  "Inflector",
  "proc-macro-error",
@@ -317,9 +396,9 @@ checksum = "dbf0c48bc1d91375ae5c3cd81e3722dff1abcf81a30960240640d223f59fe0e5"
 
 [[package]]
 name = "proc-macro2"
-version = "1.0.43"
+version = "1.0.47"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "0a2ca2c61bc9f3d74d2886294ab7b9853abd9c1ad903a3ac7815c58989bb7bab"
+checksum = "5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725"
 dependencies = [
  "unicode-ident",
 ]
@@ -396,28 +475,49 @@ version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd"
 
+[[package]]
+name = "scratch"
+version = "1.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c8132065adcfd6e02db789d9285a0deb2f3fcb04002865ab67d5fb103533898"
+
 [[package]]
 name = "smallvec"
-version = "1.9.0"
+version = "1.10.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1"
+checksum = "a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0"
 
 [[package]]
 name = "syn"
-version = "1.0.99"
+version = "1.0.103"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "58dbef6ec655055e20b86b15a8cc6d439cca19b667537ac6a1369572d151ab13"
+checksum = "a864042229133ada95abf3b54fdc62ef5ccabe9515b64717bcb9a1919e59445d"
 dependencies = [
  "proc-macro2",
  "quote",
  "unicode-ident",
 ]
 
+[[package]]
+name = "termcolor"
+version = "1.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bab24d30b911b2376f3a13cc2cd443142f0c81dda04c118693e35b3835757755"
+dependencies = [
+ "winapi-util",
+]
+
 [[package]]
 name = "unicode-ident"
-version = "1.0.3"
+version = "1.0.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3"
+
+[[package]]
+name = "unicode-width"
+version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4f5b37a154999a8f3f98cc23a628d850e154479cd94decf3414696e12e31aaf"
+checksum = "c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b"
 
 [[package]]
 name = "unindent"
@@ -433,9 +533,9 @@ checksum = "49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f"
 
 [[package]]
 name = "wasm-bindgen"
-version = "0.2.82"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fc7652e3f6c4706c8d9cd54832c4a4ccb9b5336e2c3bd154d5cccfbf1c1f5f7d"
+checksum = "eaf9f5aceeec8be17c128b2e93e031fb8a4d469bb9c4ae2d7dc1888b26887268"
 dependencies = [
  "cfg-if",
  "wasm-bindgen-macro",
@@ -443,9 +543,9 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-backend"
-version = "0.2.82"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "662cd44805586bd52971b9586b1df85cdbbd9112e4ef4d8f41559c334dc6ac3f"
+checksum = "4c8ffb332579b0557b52d268b91feab8df3615f265d5270fec2a8c95b17c1142"
 dependencies = [
  "bumpalo",
  "log",
@@ -458,9 +558,9 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro"
-version = "0.2.82"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b260f13d3012071dfb1512849c033b1925038373aea48ced3012c09df952c602"
+checksum = "052be0f94026e6cbc75cdefc9bae13fd6052cdcaf532fa6c45e7ae33a1e6c810"
 dependencies = [
  "quote",
  "wasm-bindgen-macro-support",
@@ -468,9 +568,9 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-macro-support"
-version = "0.2.82"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "5be8e654bdd9b79216c2929ab90721aa82faf65c48cdf08bdc4e7f51357b80da"
+checksum = "07bc0c051dc5f23e307b13285f9d75df86bfdf816c5721e573dec1f9b8aa193c"
 dependencies = [
  "proc-macro2",
  "quote",
@@ -481,9 +581,9 @@ dependencies = [
 
 [[package]]
 name = "wasm-bindgen-shared"
-version = "0.2.82"
+version = "0.2.83"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6598dd0bd3c7d51095ff6531a5b23e02acdc81804e30d8f07afb77b7215a140a"
+checksum = "1c38c045535d93ec4f0b4defec448e4291638ee608530863b1e2ba115d4fff7f"
 
 [[package]]
 name = "winapi"
@@ -501,6 +601,15 @@ version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
 
+[[package]]
+name = "winapi-util"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178"
+dependencies = [
+ "winapi",
+]
+
 [[package]]
 name = "winapi-x86_64-pc-windows-gnu"
 version = "0.4.0"
diff --git a/src/rust/Cargo.toml b/src/rust/Cargo.toml
index 49e70a30f..82573dd9f 100644
--- a/src/rust/Cargo.toml
+++ b/src/rust/Cargo.toml
@@ -8,7 +8,7 @@ publish = false
 [dependencies]
 once_cell = "1"
 pyo3 = { version = "0.15.2" }
-asn1 = { version = "0.12.2", default-features = false, features = ["derive"] }
+asn1 = { version = "0.12.3", default-features = false, features = ["derive"] }
 pem = "1.1"
 chrono = { version = "0.4.22", default-features = false, features = ["alloc", "clock"] }
 ouroboros = "0.15"
diff --git a/src/rust/src/asn1.rs b/src/rust/src/asn1.rs
index 1ca443d21..522e21ac6 100644
--- a/src/rust/src/asn1.rs
+++ b/src/rust/src/asn1.rs
@@ -159,6 +159,40 @@ pub(crate) fn py_uint_to_big_endian_bytes<'p>(
     v.call_method1("to_bytes", (n, "big"))?.extract()
 }
 
+pub(crate) fn encode_der_data<'p>(
+    py: pyo3::Python<'p>,
+    pem_tag: String,
+    data: Vec<u8>,
+    encoding: &'p pyo3::PyAny,
+) -> PyAsn1Result<&'p pyo3::types::PyBytes> {
+    let encoding_class = py
+        .import("cryptography.hazmat.primitives.serialization")?
+        .getattr(crate::intern!(py, "Encoding"))?;
+
+    if encoding == encoding_class.getattr(crate::intern!(py, "DER"))? {
+        Ok(pyo3::types::PyBytes::new(py, &data))
+    } else if encoding == encoding_class.getattr(crate::intern!(py, "PEM"))? {
+        Ok(pyo3::types::PyBytes::new(
+            py,
+            &pem::encode_config(
+                &pem::Pem {
+                    tag: pem_tag,
+                    contents: data,
+                },
+                pem::EncodeConfig {
+                    line_ending: pem::LineEnding::LF,
+                },
+            )
+            .into_bytes(),
+        ))
+    } else {
+        Err(
+            pyo3::exceptions::PyTypeError::new_err("encoding must be Encoding.DER or Encoding.PEM")
+                .into(),
+        )
+    }
+}
+
 #[pyo3::prelude::pyfunction]
 fn encode_dss_signature(
     py: pyo3::Python<'_>,
diff --git a/src/rust/src/lib.rs b/src/rust/src/lib.rs
index 067af4c94..614680268 100644
--- a/src/rust/src/lib.rs
+++ b/src/rust/src/lib.rs
@@ -5,12 +5,16 @@
 #![deny(rust_2018_idioms)]
 // Temporarily allow `clippy::borrow_deref_ref` until we can upgrade to the
 // latest pyo3: https://github.com/PyO3/pyo3/pull/2503
+//
+// `clippy::uninlined_format_args` is required until our MSRV is >=1.58.0
+//
 // `unknown_lints` is required until GHA upgrades their rustc.
-#![allow(unknown_lints, clippy::borrow_deref_ref)]
+#![allow(unknown_lints, clippy::borrow_deref_ref, clippy::uninlined_format_args)]
 
 mod asn1;
 mod intern;
 pub(crate) mod oid;
+mod pkcs7;
 mod pool;
 mod x509;
 
@@ -85,6 +89,7 @@ fn _rust(py: pyo3::Python<'_>, m: &pyo3::types::PyModule) -> pyo3::PyResult<()>
     m.add_class::<pool::FixedPool>()?;
 
     m.add_submodule(asn1::create_submodule(py)?)?;
+    m.add_submodule(pkcs7::create_submodule(py)?)?;
 
     let x509_mod = pyo3::prelude::PyModule::new(py, "x509")?;
     crate::x509::certificate::add_to_module(x509_mod)?;
diff --git a/src/rust/src/oid.rs b/src/rust/src/oid.rs
index bc65daf4e..724f78eaa 100644
--- a/src/rust/src/oid.rs
+++ b/src/rust/src/oid.rs
@@ -35,6 +35,10 @@ impl ObjectIdentifier {
             .getattr(crate::intern!(py, "_OID_NAMES"))?;
         oid_names.call_method1("get", (slf, "Unknown OID"))
     }
+
+    fn __deepcopy__(slf: pyo3::PyRef<'_, Self>, _memo: pyo3::PyObject) -> pyo3::PyRef<'_, Self> {
+        slf
+    }
 }
 
 #[pyo3::prelude::pyproto]
diff --git a/src/rust/src/pkcs7.rs b/src/rust/src/pkcs7.rs
new file mode 100644
index 000000000..079419c8f
--- /dev/null
+++ b/src/rust/src/pkcs7.rs
@@ -0,0 +1,90 @@
+// This file is dual licensed under the terms of the Apache License, Version
+// 2.0, and the BSD License. See the LICENSE file in the root of this repository
+// for complete details.
+
+use crate::asn1::{encode_der_data, PyAsn1Result};
+use crate::x509;
+
+use once_cell::sync::Lazy;
+
+const PKCS7_DATA_OID: asn1::ObjectIdentifier = asn1::oid!(1, 2, 840, 113549, 1, 7, 1);
+const PKCS7_SIGNED_DATA_OID: asn1::ObjectIdentifier = asn1::oid!(1, 2, 840, 113549, 1, 7, 2);
+
+static EMPTY_STRING_DER: Lazy<Vec<u8>> = Lazy::new(|| {
+    // TODO: kind of verbose way to say "\x04\x00".
+    asn1::write_single(&(&[] as &[u8])).unwrap()
+});
+pub(crate) static EMPTY_STRING_TLV: Lazy<asn1::Tlv<'static>> =
+    Lazy::new(|| asn1::parse_single(&EMPTY_STRING_DER).unwrap());
+
+#[derive(asn1::Asn1Write)]
+struct ContentInfo<'a> {
+    content_type: asn1::ObjectIdentifier,
+    #[explicit(0)]
+    content: Option<asn1::Tlv<'a>>,
+}
+
+#[derive(asn1::Asn1Write)]
+struct SignedData<'a> {
+    version: u8,
+    digest_algorithms: asn1::SetOfWriter<'a, x509::AlgorithmIdentifier<'a>>,
+    content_info: ContentInfo<'a>,
+    #[implicit(0)]
+    certificates: Option<asn1::SetOfWriter<'a, &'a x509::certificate::RawCertificate<'a>>>,
+
+    // We don't ever supply any of these, so for now, don't fill out the fields.
+    #[implicit(1)]
+    crls: Option<asn1::SetOfWriter<'a, asn1::Sequence<'a>>>,
+
+    // We don't ever supply any of these, so for now, don't fill out the fields.
+    signer_infos: asn1::SetOfWriter<'a, asn1::Sequence<'a>>,
+}
+
+#[pyo3::prelude::pyfunction]
+fn serialize_certificates<'p>(
+    py: pyo3::Python<'p>,
+    py_certs: Vec<pyo3::PyRef<'p, x509::Certificate>>,
+    encoding: &'p pyo3::PyAny,
+) -> PyAsn1Result<&'p pyo3::types::PyBytes> {
+    if py_certs.is_empty() {
+        return Err(pyo3::exceptions::PyTypeError::new_err(
+            "certs must be a list of certs with length >= 1",
+        )
+        .into());
+    }
+
+    let raw_certs = py_certs
+        .iter()
+        .map(|c| c.raw.borrow_value_public())
+        .collect::<Vec<_>>();
+
+    let signed_data = SignedData {
+        version: 1,
+        digest_algorithms: asn1::SetOfWriter::new(&[]),
+        content_info: ContentInfo {
+            content_type: PKCS7_DATA_OID,
+            content: Some(*EMPTY_STRING_TLV),
+        },
+        certificates: Some(asn1::SetOfWriter::new(&raw_certs)),
+        crls: None,
+        signer_infos: asn1::SetOfWriter::new(&[]),
+    };
+
+    let signed_data_bytes = asn1::write_single(&signed_data)?;
+
+    let content_info = ContentInfo {
+        content_type: PKCS7_SIGNED_DATA_OID,
+        content: Some(asn1::parse_single(&signed_data_bytes).unwrap()),
+    };
+    let content_info_bytes = asn1::write_single(&content_info)?;
+
+    encode_der_data(py, "PKCS7".to_string(), content_info_bytes, encoding)
+}
+
+pub(crate) fn create_submodule(py: pyo3::Python<'_>) -> pyo3::PyResult<&pyo3::prelude::PyModule> {
+    let submod = pyo3::prelude::PyModule::new(py, "pkcs7")?;
+
+    submod.add_wrapped(pyo3::wrap_pyfunction!(serialize_certificates))?;
+
+    Ok(submod)
+}
diff --git a/src/rust/src/pool.rs b/src/rust/src/pool.rs
index 9dacd7f76..384273a69 100644
--- a/src/rust/src/pool.rs
+++ b/src/rust/src/pool.rs
@@ -10,7 +10,6 @@ use std::cell::Cell;
 #[pyo3::prelude::pyclass]
 pub(crate) struct FixedPool {
     create_fn: pyo3::PyObject,
-    destroy_fn: pyo3::PyObject,
 
     value: Cell<Option<pyo3::PyObject>>,
 }
@@ -26,16 +25,11 @@ struct PoolAcquisition {
 #[pyo3::pymethods]
 impl FixedPool {
     #[new]
-    fn new(
-        py: pyo3::Python<'_>,
-        create: pyo3::PyObject,
-        destroy: pyo3::PyObject,
-    ) -> pyo3::PyResult<Self> {
+    fn new(py: pyo3::Python<'_>, create: pyo3::PyObject) -> pyo3::PyResult<Self> {
         let value = create.call0(py)?;
 
         Ok(FixedPool {
             create_fn: create,
-            destroy_fn: destroy,
 
             value: Cell::new(Some(value)),
         })
@@ -60,18 +54,6 @@ impl FixedPool {
     }
 }
 
-impl Drop for FixedPool {
-    fn drop(&mut self) {
-        if let Some(value) = self.value.replace(None) {
-            let gil = pyo3::Python::acquire_gil();
-            let py = gil.python();
-            self.destroy_fn
-                .call1(py, (value,))
-                .expect("FixedPool destroy function failed in destructor");
-        }
-    }
-}
-
 #[pyo3::pymethods]
 impl PoolAcquisition {
     fn __enter__(&self, py: pyo3::Python<'_>) -> pyo3::PyObject {
@@ -86,9 +68,7 @@ impl PoolAcquisition {
         _exc_tb: &pyo3::PyAny,
     ) -> pyo3::PyResult<()> {
         let pool = self.pool.as_ref(py).borrow();
-        if self.fresh {
-            pool.destroy_fn.call1(py, (self.value.clone_ref(py),))?;
-        } else {
+        if !self.fresh {
             pool.value.replace(Some(self.value.clone_ref(py)));
         }
         Ok(())
diff --git a/src/rust/src/x509/certificate.rs b/src/rust/src/x509/certificate.rs
index 59841d74a..e2879b947 100644
--- a/src/rust/src/x509/certificate.rs
+++ b/src/rust/src/x509/certificate.rs
@@ -3,7 +3,8 @@
 // for complete details.
 
 use crate::asn1::{
-    big_byte_slice_to_py_int, oid_to_py_oid, py_uint_to_big_endian_bytes, PyAsn1Error, PyAsn1Result,
+    big_byte_slice_to_py_int, encode_der_data, oid_to_py_oid, py_uint_to_big_endian_bytes,
+    PyAsn1Error, PyAsn1Result,
 };
 use crate::x509;
 use crate::x509::{crl, extensions, oid, sct, Asn1ReadableOrWritable};
@@ -151,33 +152,11 @@ impl Certificate {
     fn public_bytes<'p>(
         &self,
         py: pyo3::Python<'p>,
-        encoding: &pyo3::PyAny,
+        encoding: &'p pyo3::PyAny,
     ) -> PyAsn1Result<&'p pyo3::types::PyBytes> {
-        let encoding_class = py
-            .import("cryptography.hazmat.primitives.serialization")?
-            .getattr(crate::intern!(py, "Encoding"))?;
-
         let result = asn1::write_single(self.raw.borrow_value())?;
-        if encoding == encoding_class.getattr(crate::intern!(py, "DER"))? {
-            Ok(pyo3::types::PyBytes::new(py, &result))
-        } else if encoding == encoding_class.getattr(crate::intern!(py, "PEM"))? {
-            let pem = pem::encode_config(
-                &pem::Pem {
-                    tag: "CERTIFICATE".to_string(),
-                    contents: result,
-                },
-                pem::EncodeConfig {
-                    line_ending: pem::LineEnding::LF,
-                },
-            )
-            .into_bytes();
-            Ok(pyo3::types::PyBytes::new(py, &pem))
-        } else {
-            Err(pyo3::exceptions::PyTypeError::new_err(
-                "encoding must be Encoding.DER or Encoding.PEM",
-            )
-            .into())
-        }
+
+        encode_der_data(py, "CERTIFICATE".to_string(), result, encoding)
     }
 
     #[getter]
@@ -340,27 +319,6 @@ impl Certificate {
             },
         )
     }
-    // This getter exists for compatibility with pyOpenSSL and will be removed.
-    // DO NOT RELY ON IT. WE WILL BREAK YOU WHEN WE FEEL LIKE IT.
-    #[getter]
-    fn _x509<'p>(
-        slf: pyo3::PyRef<'_, Self>,
-        py: pyo3::Python<'p>,
-    ) -> Result<&'p pyo3::PyAny, PyAsn1Error> {
-        let cryptography_warning = py
-            .import("cryptography.utils")?
-            .getattr(crate::intern!(py, "DeprecatedIn35"))?;
-        pyo3::PyErr::warn(
-            py,
-            cryptography_warning,
-            "This version of cryptography contains a temporary pyOpenSSL fallback path. Upgrade pyOpenSSL now.",
-            1
-        )?;
-        let backend = py
-            .import("cryptography.hazmat.backends.openssl.backend")?
-            .getattr(crate::intern!(py, "backend"))?;
-        Ok(backend.call_method1("_cert2ossl", (slf,))?)
-    }
 }
 
 fn cert_version(py: pyo3::Python<'_>, version: u8) -> Result<&pyo3::PyAny, PyAsn1Error> {
@@ -978,6 +936,10 @@ pub fn parse_cert_ext<'p>(
 
 pub(crate) fn time_from_py(py: pyo3::Python<'_>, val: &pyo3::PyAny) -> PyAsn1Result<x509::Time> {
     let dt = x509::py_to_chrono(py, val)?;
+    time_from_chrono(dt)
+}
+
+pub(crate) fn time_from_chrono(dt: chrono::DateTime<chrono::Utc>) -> PyAsn1Result<x509::Time> {
     if dt.year() >= 2050 {
         Ok(x509::Time::GeneralizedTime(asn1::GeneralizedTime::new(dt)?))
     } else {
diff --git a/src/rust/src/x509/common.rs b/src/rust/src/x509/common.rs
index 5cc833830..fb61b7ae8 100644
--- a/src/rust/src/x509/common.rs
+++ b/src/rust/src/x509/common.rs
@@ -683,16 +683,15 @@ pub(crate) fn py_to_chrono(
     val: &pyo3::PyAny,
 ) -> pyo3::PyResult<chrono::DateTime<chrono::Utc>> {
     Ok(chrono::Utc
-        .ymd(
+        .with_ymd_and_hms(
             val.getattr(crate::intern!(py, "year"))?.extract()?,
             val.getattr(crate::intern!(py, "month"))?.extract()?,
             val.getattr(crate::intern!(py, "day"))?.extract()?,
-        )
-        .and_hms(
             val.getattr(crate::intern!(py, "hour"))?.extract()?,
             val.getattr(crate::intern!(py, "minute"))?.extract()?,
             val.getattr(crate::intern!(py, "second"))?.extract()?,
-        ))
+        )
+        .unwrap())
 }
 
 #[derive(Hash, PartialEq, Clone)]
diff --git a/src/rust/src/x509/crl.rs b/src/rust/src/x509/crl.rs
index b34de1072..44e3bfd70 100644
--- a/src/rust/src/x509/crl.rs
+++ b/src/rust/src/x509/crl.rs
@@ -3,7 +3,8 @@
 // for complete details.
 
 use crate::asn1::{
-    big_byte_slice_to_py_int, oid_to_py_oid, py_uint_to_big_endian_bytes, PyAsn1Error, PyAsn1Result,
+    big_byte_slice_to_py_int, encode_der_data, oid_to_py_oid, py_uint_to_big_endian_bytes,
+    PyAsn1Error, PyAsn1Result,
 };
 use crate::x509;
 use crate::x509::{certificate, extensions, oid};
@@ -215,33 +216,11 @@ impl CertificateRevocationList {
     fn public_bytes<'p>(
         &self,
         py: pyo3::Python<'p>,
-        encoding: &pyo3::PyAny,
+        encoding: &'p pyo3::PyAny,
     ) -> PyAsn1Result<&'p pyo3::types::PyBytes> {
-        let encoding_class = py
-            .import("cryptography.hazmat.primitives.serialization")?
-            .getattr(crate::intern!(py, "Encoding"))?;
-
         let result = asn1::write_single(self.raw.borrow_value())?;
-        if encoding == encoding_class.getattr(crate::intern!(py, "DER"))? {
-            Ok(pyo3::types::PyBytes::new(py, &result))
-        } else if encoding == encoding_class.getattr(crate::intern!(py, "PEM"))? {
-            let pem = pem::encode_config(
-                &pem::Pem {
-                    tag: "X509 CRL".to_string(),
-                    contents: result,
-                },
-                pem::EncodeConfig {
-                    line_ending: pem::LineEnding::LF,
-                },
-            )
-            .into_bytes();
-            Ok(pyo3::types::PyBytes::new(py, &pem))
-        } else {
-            Err(pyo3::exceptions::PyTypeError::new_err(
-                "encoding must be Encoding.DER or Encoding.PEM",
-            )
-            .into())
-        }
+
+        encode_der_data(py, "X509 CRL".to_string(), result, encoding)
     }
 
     #[getter]
@@ -400,28 +379,6 @@ impl CertificateRevocationList {
             .getattr(crate::intern!(py, "backend"))?;
         backend.call_method1("_crl_is_signature_valid", (slf, public_key))
     }
-
-    // This getter exists for compatibility with pyOpenSSL and will be removed.
-    // DO NOT RELY ON IT. WE WILL BREAK YOU WHEN WE FEEL LIKE IT.
-    #[getter]
-    fn _x509_crl<'p>(
-        slf: pyo3::PyRef<'_, Self>,
-        py: pyo3::Python<'p>,
-    ) -> Result<&'p pyo3::PyAny, PyAsn1Error> {
-        let cryptography_warning = py
-            .import("cryptography.utils")?
-            .getattr(crate::intern!(py, "DeprecatedIn35"))?;
-        pyo3::PyErr::warn(
-            py,
-            cryptography_warning,
-            "This version of cryptography contains a temporary pyOpenSSL fallback path. Upgrade pyOpenSSL now.",
-            1
-        )?;
-        let backend = py
-            .import("cryptography.hazmat.backends.openssl.backend")?
-            .getattr(crate::intern!(py, "backend"))?;
-        Ok(backend.call_method1("_crl2ossl", (slf,))?)
-    }
 }
 
 #[pyo3::prelude::pyproto]
diff --git a/src/rust/src/x509/csr.rs b/src/rust/src/x509/csr.rs
index 7579bccb9..7bc3dc98a 100644
--- a/src/rust/src/x509/csr.rs
+++ b/src/rust/src/x509/csr.rs
@@ -2,7 +2,7 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
-use crate::asn1::{oid_to_py_oid, py_oid_to_oid, PyAsn1Error, PyAsn1Result};
+use crate::asn1::{encode_der_data, oid_to_py_oid, py_oid_to_oid, PyAsn1Error, PyAsn1Result};
 use crate::x509;
 use crate::x509::{certificate, oid};
 use asn1::SimpleAsn1Readable;
@@ -22,17 +22,19 @@ struct CertificationRequestInfo<'a> {
     subject: x509::Name<'a>,
     spki: certificate::SubjectPublicKeyInfo<'a>,
     #[implicit(0, required)]
-    attributes: x509::Asn1ReadableOrWritable<
-        'a,
-        asn1::SetOf<'a, Attribute<'a>>,
-        asn1::SetOfWriter<'a, Attribute<'a>, Vec<Attribute<'a>>>,
-    >,
+    attributes: Attributes<'a>,
 }
 
+pub(crate) type Attributes<'a> = x509::Asn1ReadableOrWritable<
+    'a,
+    asn1::SetOf<'a, Attribute<'a>>,
+    asn1::SetOfWriter<'a, Attribute<'a>, Vec<Attribute<'a>>>,
+>;
+
 #[derive(asn1::Asn1Read, asn1::Asn1Write)]
-struct Attribute<'a> {
-    type_id: asn1::ObjectIdentifier,
-    values: x509::Asn1ReadableOrWritable<
+pub(crate) struct Attribute<'a> {
+    pub(crate) type_id: asn1::ObjectIdentifier,
+    pub(crate) values: x509::Asn1ReadableOrWritable<
         'a,
         asn1::SetOf<'a, asn1::Tlv<'a>>,
         asn1::SetOfWriter<'a, x509::common::RawTlv<'a>, [x509::common::RawTlv<'a>; 1]>,
@@ -169,33 +171,11 @@ impl CertificateSigningRequest {
     fn public_bytes<'p>(
         &self,
         py: pyo3::Python<'p>,
-        encoding: &pyo3::PyAny,
+        encoding: &'p pyo3::PyAny,
     ) -> PyAsn1Result<&'p pyo3::types::PyBytes> {
-        let encoding_class = py
-            .import("cryptography.hazmat.primitives.serialization")?
-            .getattr(crate::intern!(py, "Encoding"))?;
-
         let result = asn1::write_single(self.raw.borrow_value())?;
-        if encoding == encoding_class.getattr(crate::intern!(py, "DER"))? {
-            Ok(pyo3::types::PyBytes::new(py, &result))
-        } else if encoding == encoding_class.getattr(crate::intern!(py, "PEM"))? {
-            let pem = pem::encode_config(
-                &pem::Pem {
-                    tag: "CERTIFICATE REQUEST".to_string(),
-                    contents: result,
-                },
-                pem::EncodeConfig {
-                    line_ending: pem::LineEnding::LF,
-                },
-            )
-            .into_bytes();
-            Ok(pyo3::types::PyBytes::new(py, &pem))
-        } else {
-            Err(pyo3::exceptions::PyTypeError::new_err(
-                "encoding must be Encoding.DER or Encoding.PEM",
-            )
-            .into())
-        }
+
+        encode_der_data(py, "CERTIFICATE REQUEST".to_string(), result, encoding)
     }
 
     fn get_attribute_for_oid<'p>(
@@ -295,28 +275,6 @@ impl CertificateSigningRequest {
             .getattr(crate::intern!(py, "backend"))?;
         backend.call_method1("_csr_is_signature_valid", (slf,))
     }
-
-    // This getter exists for compatibility with pyOpenSSL and will be removed.
-    // DO NOT RELY ON IT. WE WILL BREAK YOU WHEN WE FEEL LIKE IT.
-    #[getter]
-    fn _x509_req<'p>(
-        slf: pyo3::PyRef<'_, Self>,
-        py: pyo3::Python<'p>,
-    ) -> Result<&'p pyo3::PyAny, PyAsn1Error> {
-        let cryptography_warning = py
-            .import("cryptography.utils")?
-            .getattr(crate::intern!(py, "DeprecatedIn35"))?;
-        pyo3::PyErr::warn(
-            py,
-            cryptography_warning,
-            "This version of cryptography contains a temporary pyOpenSSL fallback path. Upgrade pyOpenSSL now.",
-            1,
-        )?;
-        let backend = py
-            .import("cryptography.hazmat.backends.openssl.backend")?
-            .getattr(crate::intern!(py, "backend"))?;
-        Ok(backend.call_method1("_csr2ossl", (slf,))?)
-    }
 }
 
 #[pyo3::prelude::pyfunction]
diff --git a/src/rust/src/x509/mod.rs b/src/rust/src/x509/mod.rs
index ee6c8d74c..8c7b39f4b 100644
--- a/src/rust/src/x509/mod.rs
+++ b/src/rust/src/x509/mod.rs
@@ -7,10 +7,10 @@ pub(crate) mod common;
 pub(crate) mod crl;
 pub(crate) mod csr;
 pub(crate) mod extensions;
-mod ocsp;
+pub(crate) mod ocsp;
 pub(crate) mod ocsp_req;
 pub(crate) mod ocsp_resp;
-mod oid;
+pub(crate) mod oid;
 pub(crate) mod sct;
 pub(crate) mod sign;
 
diff --git a/src/rust/src/x509/ocsp.rs b/src/rust/src/x509/ocsp.rs
index 67bdca0f4..de5ace7d0 100644
--- a/src/rust/src/x509/ocsp.rs
+++ b/src/rust/src/x509/ocsp.rs
@@ -70,6 +70,27 @@ impl CertID<'_> {
             serial_number: cert.raw.borrow_value_public().tbs_cert.serial,
         })
     }
+
+    pub(crate) fn new_from_hash<'p>(
+        py: pyo3::Python<'p>,
+        issuer_name_hash: &'p [u8],
+        issuer_key_hash: &'p [u8],
+        serial_number: asn1::BigInt<'p>,
+        hash_algorithm: &'p pyo3::PyAny,
+    ) -> PyAsn1Result<CertID<'p>> {
+        Ok(CertID {
+            hash_algorithm: x509::AlgorithmIdentifier {
+                oid: HASH_NAME_TO_OIDS[hash_algorithm
+                    .getattr(crate::intern!(py, "name"))?
+                    .extract::<&str>()?]
+                .clone(),
+                params: Some(*x509::sign::NULL_TLV),
+            },
+            issuer_name_hash,
+            issuer_key_hash,
+            serial_number,
+        })
+    }
 }
 
 pub(crate) fn hash_data<'p>(
diff --git a/src/rust/src/x509/ocsp_req.rs b/src/rust/src/x509/ocsp_req.rs
index 92fe96fa0..0f7e8f869 100644
--- a/src/rust/src/x509/ocsp_req.rs
+++ b/src/rust/src/x509/ocsp_req.rs
@@ -2,7 +2,9 @@
 // 2.0, and the BSD License. See the LICENSE file in the root of this repository
 // for complete details.
 
-use crate::asn1::{big_byte_slice_to_py_int, PyAsn1Error, PyAsn1Result};
+use crate::asn1::{
+    big_byte_slice_to_py_int, py_uint_to_big_endian_bytes, PyAsn1Error, PyAsn1Result,
+};
 use crate::x509;
 use crate::x509::{extensions, ocsp, oid};
 use std::sync::Arc;
@@ -180,11 +182,42 @@ struct Request<'a> {
 
 #[pyo3::prelude::pyfunction]
 fn create_ocsp_request(py: pyo3::Python<'_>, builder: &pyo3::PyAny) -> PyAsn1Result<OCSPRequest> {
+    let builder_request = builder.getattr(crate::intern!(py, "_request"))?;
+
+    // Declare outside the if-block so the lifetimes are right.
     let (py_cert, py_issuer, py_hash): (
         pyo3::PyRef<'_, x509::Certificate>,
         pyo3::PyRef<'_, x509::Certificate>,
         &pyo3::PyAny,
-    ) = builder.getattr(crate::intern!(py, "_request"))?.extract()?;
+    );
+    let req_cert = if !builder_request.is_none() {
+        let tuple = builder_request.extract::<(
+            pyo3::PyRef<'_, x509::Certificate>,
+            pyo3::PyRef<'_, x509::Certificate>,
+            &pyo3::PyAny,
+        )>()?;
+        py_cert = tuple.0;
+        py_issuer = tuple.1;
+        py_hash = tuple.2;
+        ocsp::CertID::new(py, &py_cert, &py_issuer, py_hash)?
+    } else {
+        let (issuer_name_hash, issuer_key_hash, py_serial, py_hash): (
+            &[u8],
+            &[u8],
+            &pyo3::types::PyLong,
+            &pyo3::PyAny,
+        ) = builder
+            .getattr(crate::intern!(py, "_request_hash"))?
+            .extract()?;
+        let serial_number = asn1::BigInt::new(py_uint_to_big_endian_bytes(py, py_serial)?).unwrap();
+        ocsp::CertID::new_from_hash(
+            py,
+            issuer_name_hash,
+            issuer_key_hash,
+            serial_number,
+            py_hash,
+        )?
+    };
 
     let extensions = x509::common::encode_extensions(
         py,
@@ -192,7 +225,7 @@ fn create_ocsp_request(py: pyo3::Python<'_>, builder: &pyo3::PyAny) -> PyAsn1Res
         extensions::encode_extension,
     )?;
     let reqs = [Request {
-        req_cert: ocsp::CertID::new(py, &py_cert, &py_issuer, py_hash)?,
+        req_cert,
         single_request_extensions: None,
     }];
     let ocsp_req = RawOCSPRequest {
diff --git a/src/rust/src/x509/ocsp_resp.rs b/src/rust/src/x509/ocsp_resp.rs
index 22d294065..ae2488ae7 100644
--- a/src/rust/src/x509/ocsp_resp.rs
+++ b/src/rust/src/x509/ocsp_resp.rs
@@ -12,35 +12,35 @@ const BASIC_RESPONSE_OID: asn1::ObjectIdentifier = asn1::oid!(1, 3, 6, 1, 5, 5,
 
 #[pyo3::prelude::pyfunction]
 fn load_der_ocsp_response(_py: pyo3::Python<'_>, data: &[u8]) -> Result<OCSPResponse, PyAsn1Error> {
-    let raw = OwnedRawOCSPResponse::try_new(
-        Arc::from(data),
-        |data| Ok(asn1::parse_single(data)?),
-        |_data, response| match response.response_status.value() {
-            SUCCESSFUL_RESPONSE => match response.response_bytes {
-                Some(ref bytes) => {
-                    if bytes.response_type == BASIC_RESPONSE_OID {
-                        Ok(asn1::parse_single(bytes.response)?)
-                    } else {
-                        Err(PyAsn1Error::from(pyo3::exceptions::PyValueError::new_err(
-                            "Successful OCSP response does not contain a BasicResponse",
-                        )))
-                    }
+    let raw = OwnedRawOCSPResponse::try_new(Arc::from(data), |data| asn1::parse_single(data))?;
+
+    let response = raw.borrow_value();
+    match response.response_status.value() {
+        SUCCESSFUL_RESPONSE => match response.response_bytes {
+            Some(ref bytes) => {
+                if bytes.response_type != BASIC_RESPONSE_OID {
+                    return Err(PyAsn1Error::from(pyo3::exceptions::PyValueError::new_err(
+                        "Successful OCSP response does not contain a BasicResponse",
+                    )));
                 }
-                None => Err(PyAsn1Error::from(pyo3::exceptions::PyValueError::new_err(
+            }
+            None => {
+                return Err(PyAsn1Error::from(pyo3::exceptions::PyValueError::new_err(
                     "Successful OCSP response does not contain a BasicResponse",
-                ))),
-            },
-            MALFORMED_REQUEST_RESPOSNE
-            | INTERNAL_ERROR_RESPONSE
-            | TRY_LATER_RESPONSE
-            | SIG_REQUIRED_RESPONSE
-            | UNAUTHORIZED_RESPONSE => Ok(None),
-            _ => Err(PyAsn1Error::from(pyo3::exceptions::PyValueError::new_err(
-                "OCSP response has an unknown status code",
-            ))),
+                )))
+            }
         },
-    )?;
-
+        MALFORMED_REQUEST_RESPOSNE
+        | INTERNAL_ERROR_RESPONSE
+        | TRY_LATER_RESPONSE
+        | SIG_REQUIRED_RESPONSE
+        | UNAUTHORIZED_RESPONSE => {}
+        _ => {
+            return Err(PyAsn1Error::from(pyo3::exceptions::PyValueError::new_err(
+                "OCSP response has an unknown status code",
+            )))
+        }
+    };
     Ok(OCSPResponse {
         raw: Arc::new(raw),
         cached_extensions: None,
@@ -54,10 +54,6 @@ struct OwnedRawOCSPResponse {
     #[borrows(data)]
     #[covariant]
     value: RawOCSPResponse<'this>,
-
-    #[borrows(data, value)]
-    #[covariant]
-    basic_response: Option<BasicOCSPResponse<'this>>,
 }
 
 #[pyo3::prelude::pyclass]
@@ -70,8 +66,8 @@ struct OCSPResponse {
 
 impl OCSPResponse {
     fn requires_successful_response(&self) -> pyo3::PyResult<&BasicOCSPResponse<'_>> {
-        match self.raw.borrow_basic_response() {
-            Some(b) => Ok(b),
+        match self.raw.borrow_value().response_bytes.as_ref() {
+            Some(b) => Ok(b.response.get()),
             None => Err(pyo3::exceptions::PyValueError::new_err(
                 "OCSP response status is not successful so the property has no value",
             )),
@@ -95,9 +91,12 @@ impl OCSPResponse {
         Ok(OCSPResponseIterator {
             contents: OwnedOCSPResponseIteratorData::try_new(Arc::clone(&self.raw), |v| {
                 Ok::<_, ()>(
-                    v.borrow_basic_response()
+                    v.borrow_value()
+                        .response_bytes
                         .as_ref()
                         .unwrap()
+                        .response
+                        .get()
                         .tbs_response_data
                         .responses
                         .unwrap_read()
@@ -210,10 +209,12 @@ impl OCSPResponse {
         };
         for i in 0..certs.len() {
             // TODO: O(n^2), don't have too many certificates!
-            let raw_cert = map_arc_data_ocsp_response(&self.raw, |_data, _resp, basic_response| {
-                basic_response
+            let raw_cert = map_arc_data_ocsp_response(&self.raw, |_data, resp| {
+                resp.response_bytes
                     .as_ref()
                     .unwrap()
+                    .response
+                    .get()
                     .certs
                     .as_ref()
                     .unwrap()
@@ -304,9 +305,12 @@ impl OCSPResponse {
             &mut self.cached_extensions,
             &self
                 .raw
-                .borrow_basic_response()
+                .borrow_value()
+                .response_bytes
                 .as_ref()
                 .unwrap()
+                .response
+                .get()
                 .tbs_response_data
                 .response_extensions,
             |oid, ext_data| {
@@ -332,9 +336,12 @@ impl OCSPResponse {
         self.requires_successful_response()?;
         let single_resp = self
             .raw
-            .borrow_basic_response()
+            .borrow_value()
+            .response_bytes
             .as_ref()
             .unwrap()
+            .response
+            .get()
             .single_response()?;
         let x509_module = py.import("cryptography.x509")?;
         x509::parse_and_cache_extensions(
@@ -383,17 +390,10 @@ fn map_arc_data_ocsp_response(
     f: impl for<'this> FnOnce(
         &'this [u8],
         &RawOCSPResponse<'this>,
-        &Option<BasicOCSPResponse<'this>>,
     ) -> certificate::RawCertificate<'this>,
 ) -> certificate::OwnedRawCertificate {
     certificate::OwnedRawCertificate::new_public(Arc::clone(it.borrow_data()), |inner_it| {
-        it.with(|value| {
-            f(
-                inner_it,
-                unsafe { std::mem::transmute(value.value) },
-                unsafe { std::mem::transmute(value.basic_response) },
-            )
-        })
+        it.with(|value| f(inner_it, unsafe { std::mem::transmute(value.value) }))
     })
 }
 fn try_map_arc_data_mut_ocsp_response_iterator<E>(
@@ -418,7 +418,7 @@ struct RawOCSPResponse<'a> {
 #[derive(asn1::Asn1Read, asn1::Asn1Write)]
 struct ResponseBytes<'a> {
     response_type: asn1::ObjectIdentifier,
-    response: &'a [u8],
+    response: asn1::OctetStringEncoded<BasicOCSPResponse<'a>>,
 }
 
 type OCSPCerts<'a> = Option<
@@ -577,166 +577,9 @@ struct RevokedInfo {
     revocation_reason: Option<crl::CRLReason>,
 }
 
-fn create_ocsp_basic_response<'p>(
-    py: pyo3::Python<'p>,
-    builder: &'p pyo3::PyAny,
-    private_key: &'p pyo3::PyAny,
-    hash_algorithm: &'p pyo3::PyAny,
-) -> PyAsn1Result<Vec<u8>> {
-    let ocsp_mod = py.import("cryptography.x509.ocsp")?;
-
-    let py_single_resp = builder.getattr(crate::intern!(py, "_response"))?;
-    let py_cert: pyo3::PyRef<'_, x509::Certificate> = py_single_resp
-        .getattr(crate::intern!(py, "_cert"))?
-        .extract()?;
-    let py_issuer: pyo3::PyRef<'_, x509::Certificate> = py_single_resp
-        .getattr(crate::intern!(py, "_issuer"))?
-        .extract()?;
-    let py_cert_hash_algorithm = py_single_resp.getattr(crate::intern!(py, "_algorithm"))?;
-    let (responder_cert, responder_encoding): (&pyo3::PyCell<x509::Certificate>, &pyo3::PyAny) =
-        builder
-            .getattr(crate::intern!(py, "_responder_id"))?
-            .extract()?;
-
-    let py_cert_status = py_single_resp.getattr(crate::intern!(py, "_cert_status"))?;
-    let cert_status = if py_cert_status
-        == ocsp_mod
-            .getattr(crate::intern!(py, "OCSPCertStatus"))?
-            .getattr(crate::intern!(py, "GOOD"))?
-    {
-        CertStatus::Good(())
-    } else if py_cert_status
-        == ocsp_mod
-            .getattr(crate::intern!(py, "OCSPCertStatus"))?
-            .getattr(crate::intern!(py, "UNKNOWN"))?
-    {
-        CertStatus::Unknown(())
-    } else {
-        let revocation_reason = if !py_single_resp
-            .getattr(crate::intern!(py, "_revocation_reason"))?
-            .is_none()
-        {
-            let value = py
-                .import("cryptography.hazmat.backends.openssl.decode_asn1")?
-                .getattr(crate::intern!(py, "_CRL_ENTRY_REASON_ENUM_TO_CODE"))?
-                .get_item(py_single_resp.getattr(crate::intern!(py, "_revocation_reason"))?)?
-                .extract::<u32>()?;
-            Some(asn1::Enumerated::new(value))
-        } else {
-            None
-        };
-        // REVOKED
-        let py_revocation_time = py_single_resp.getattr(crate::intern!(py, "_revocation_time"))?;
-        let revocation_time = asn1::GeneralizedTime::new(py_to_chrono(py, py_revocation_time)?)?;
-        CertStatus::Revoked(RevokedInfo {
-            revocation_time,
-            revocation_reason,
-        })
-    };
-    let next_update = if !py_single_resp
-        .getattr(crate::intern!(py, "_next_update"))?
-        .is_none()
-    {
-        let py_next_update = py_single_resp.getattr(crate::intern!(py, "_next_update"))?;
-        Some(asn1::GeneralizedTime::new(py_to_chrono(
-            py,
-            py_next_update,
-        )?)?)
-    } else {
-        None
-    };
-    let py_this_update = py_single_resp.getattr(crate::intern!(py, "_this_update"))?;
-    let this_update = asn1::GeneralizedTime::new(py_to_chrono(py, py_this_update)?)?;
-
-    let responses = vec![SingleResponse {
-        cert_id: ocsp::CertID::new(py, &py_cert, &py_issuer, py_cert_hash_algorithm)?,
-        cert_status,
-        next_update,
-        this_update,
-        single_extensions: None,
-    }];
-
-    let borrowed_cert = responder_cert.borrow();
-    let responder_id = if responder_encoding
-        == ocsp_mod
-            .getattr(crate::intern!(py, "OCSPResponderEncoding"))?
-            .getattr(crate::intern!(py, "HASH"))?
-    {
-        let sha1 = py
-            .import("cryptography.hazmat.primitives.hashes")?
-            .getattr(crate::intern!(py, "SHA1"))?
-            .call0()?;
-        ResponderId::ByKey(ocsp::hash_data(
-            py,
-            sha1,
-            borrowed_cert
-                .raw
-                .borrow_value_public()
-                .tbs_cert
-                .spki
-                .subject_public_key
-                .as_bytes(),
-        )?)
-    } else {
-        ResponderId::ByName(
-            borrowed_cert
-                .raw
-                .borrow_value_public()
-                .tbs_cert
-                .subject
-                .clone(),
-        )
-    };
-
-    let tbs_response_data = ResponseData {
-        version: 0,
-        produced_at: asn1::GeneralizedTime::new(chrono::Utc::now().with_nanosecond(0).unwrap())?,
-        responder_id,
-        responses: x509::Asn1ReadableOrWritable::new_write(asn1::SequenceOfWriter::new(responses)),
-        response_extensions: x509::common::encode_extensions(
-            py,
-            builder.getattr(crate::intern!(py, "_extensions"))?,
-            extensions::encode_extension,
-        )?,
-    };
-
-    let sigalg = x509::sign::compute_signature_algorithm(py, private_key, hash_algorithm)?;
-    let tbs_bytes = asn1::write_single(&tbs_response_data)?;
-    let signature = x509::sign::sign_data(py, private_key, hash_algorithm, &tbs_bytes)?;
-
-    py.import("cryptography.hazmat.backends.openssl.backend")?
-        .getattr(crate::intern!(py, "backend"))?
-        .call_method1(
-            "_check_keys_correspond",
-            (
-                responder_cert.call_method0("public_key")?,
-                private_key.call_method0("public_key")?,
-            ),
-        )?;
-
-    let py_certs: Option<Vec<pyo3::PyRef<'_, x509::Certificate>>> =
-        builder.getattr(crate::intern!(py, "_certs"))?.extract()?;
-    let certs = py_certs.as_ref().map(|py_certs| {
-        x509::Asn1ReadableOrWritable::new_write(asn1::SequenceOfWriter::new(
-            py_certs
-                .iter()
-                .map(|c| c.raw.borrow_value_public().clone())
-                .collect(),
-        ))
-    });
-
-    let basic_resp = BasicOCSPResponse {
-        tbs_response_data,
-        signature: asn1::BitString::new(signature, 0).unwrap(),
-        signature_algorithm: sigalg,
-        certs,
-    };
-    Ok(asn1::write_single(&basic_resp)?)
-}
-
 #[pyo3::prelude::pyfunction]
-fn create_ocsp_response(
-    py: pyo3::Python<'_>,
+fn create_ocsp_response<'p>(
+    py: pyo3::Python<'p>,
     status: &pyo3::PyAny,
     builder: &pyo3::PyAny,
     private_key: &pyo3::PyAny,
@@ -745,12 +588,168 @@ fn create_ocsp_response(
     let response_status = status
         .getattr(crate::intern!(py, "value"))?
         .extract::<u32>()?;
-    let basic_resp_bytes;
+
+    let py_cert: pyo3::PyRef<'_, x509::Certificate>;
+    let py_issuer: pyo3::PyRef<'_, x509::Certificate>;
+    let borrowed_cert;
+    let py_certs: Option<Vec<pyo3::PyRef<'_, x509::Certificate>>>;
     let response_bytes = if response_status == SUCCESSFUL_RESPONSE {
-        basic_resp_bytes = create_ocsp_basic_response(py, builder, private_key, hash_algorithm)?;
+        let ocsp_mod = py.import("cryptography.x509.ocsp")?;
+
+        let py_single_resp = builder.getattr(crate::intern!(py, "_response"))?;
+        py_cert = py_single_resp
+            .getattr(crate::intern!(py, "_cert"))?
+            .extract()?;
+        py_issuer = py_single_resp
+            .getattr(crate::intern!(py, "_issuer"))?
+            .extract()?;
+        let py_cert_hash_algorithm = py_single_resp.getattr(crate::intern!(py, "_algorithm"))?;
+        let (responder_cert, responder_encoding): (&pyo3::PyCell<x509::Certificate>, &pyo3::PyAny) =
+            builder
+                .getattr(crate::intern!(py, "_responder_id"))?
+                .extract()?;
+
+        let py_cert_status = py_single_resp.getattr(crate::intern!(py, "_cert_status"))?;
+        let cert_status = if py_cert_status
+            == ocsp_mod
+                .getattr(crate::intern!(py, "OCSPCertStatus"))?
+                .getattr(crate::intern!(py, "GOOD"))?
+        {
+            CertStatus::Good(())
+        } else if py_cert_status
+            == ocsp_mod
+                .getattr(crate::intern!(py, "OCSPCertStatus"))?
+                .getattr(crate::intern!(py, "UNKNOWN"))?
+        {
+            CertStatus::Unknown(())
+        } else {
+            let revocation_reason = if !py_single_resp
+                .getattr(crate::intern!(py, "_revocation_reason"))?
+                .is_none()
+            {
+                let value = py
+                    .import("cryptography.hazmat.backends.openssl.decode_asn1")?
+                    .getattr(crate::intern!(py, "_CRL_ENTRY_REASON_ENUM_TO_CODE"))?
+                    .get_item(py_single_resp.getattr(crate::intern!(py, "_revocation_reason"))?)?
+                    .extract::<u32>()?;
+                Some(asn1::Enumerated::new(value))
+            } else {
+                None
+            };
+            // REVOKED
+            let py_revocation_time =
+                py_single_resp.getattr(crate::intern!(py, "_revocation_time"))?;
+            let revocation_time =
+                asn1::GeneralizedTime::new(py_to_chrono(py, py_revocation_time)?)?;
+            CertStatus::Revoked(RevokedInfo {
+                revocation_time,
+                revocation_reason,
+            })
+        };
+        let next_update = if !py_single_resp
+            .getattr(crate::intern!(py, "_next_update"))?
+            .is_none()
+        {
+            let py_next_update = py_single_resp.getattr(crate::intern!(py, "_next_update"))?;
+            Some(asn1::GeneralizedTime::new(py_to_chrono(
+                py,
+                py_next_update,
+            )?)?)
+        } else {
+            None
+        };
+        let py_this_update = py_single_resp.getattr(crate::intern!(py, "_this_update"))?;
+        let this_update = asn1::GeneralizedTime::new(py_to_chrono(py, py_this_update)?)?;
+
+        let responses = vec![SingleResponse {
+            cert_id: ocsp::CertID::new(py, &py_cert, &py_issuer, py_cert_hash_algorithm)?,
+            cert_status,
+            next_update,
+            this_update,
+            single_extensions: None,
+        }];
+
+        borrowed_cert = responder_cert.borrow();
+        let responder_id = if responder_encoding
+            == ocsp_mod
+                .getattr(crate::intern!(py, "OCSPResponderEncoding"))?
+                .getattr(crate::intern!(py, "HASH"))?
+        {
+            let sha1 = py
+                .import("cryptography.hazmat.primitives.hashes")?
+                .getattr(crate::intern!(py, "SHA1"))?
+                .call0()?;
+            ResponderId::ByKey(ocsp::hash_data(
+                py,
+                sha1,
+                borrowed_cert
+                    .raw
+                    .borrow_value_public()
+                    .tbs_cert
+                    .spki
+                    .subject_public_key
+                    .as_bytes(),
+            )?)
+        } else {
+            ResponderId::ByName(
+                borrowed_cert
+                    .raw
+                    .borrow_value_public()
+                    .tbs_cert
+                    .subject
+                    .clone(),
+            )
+        };
+
+        let tbs_response_data = ResponseData {
+            version: 0,
+            produced_at: asn1::GeneralizedTime::new(
+                chrono::Utc::now().with_nanosecond(0).unwrap(),
+            )?,
+            responder_id,
+            responses: x509::Asn1ReadableOrWritable::new_write(asn1::SequenceOfWriter::new(
+                responses,
+            )),
+            response_extensions: x509::common::encode_extensions(
+                py,
+                builder.getattr(crate::intern!(py, "_extensions"))?,
+                extensions::encode_extension,
+            )?,
+        };
+
+        let sigalg = x509::sign::compute_signature_algorithm(py, private_key, hash_algorithm)?;
+        let tbs_bytes = asn1::write_single(&tbs_response_data)?;
+        let signature = x509::sign::sign_data(py, private_key, hash_algorithm, &tbs_bytes)?;
+
+        py.import("cryptography.hazmat.backends.openssl.backend")?
+            .getattr(crate::intern!(py, "backend"))?
+            .call_method1(
+                "_check_keys_correspond",
+                (
+                    responder_cert.call_method0("public_key")?,
+                    private_key.call_method0("public_key")?,
+                ),
+            )?;
+
+        py_certs = builder.getattr(crate::intern!(py, "_certs"))?.extract()?;
+        let certs = py_certs.as_ref().map(|py_certs| {
+            x509::Asn1ReadableOrWritable::new_write(asn1::SequenceOfWriter::new(
+                py_certs
+                    .iter()
+                    .map(|c| c.raw.borrow_value_public().clone())
+                    .collect(),
+            ))
+        });
+
+        let basic_resp = BasicOCSPResponse {
+            tbs_response_data,
+            signature: asn1::BitString::new(signature, 0).unwrap(),
+            signature_algorithm: sigalg,
+            certs,
+        };
         Some(ResponseBytes {
             response_type: (BASIC_RESPONSE_OID).clone(),
-            response: &basic_resp_bytes,
+            response: asn1::OctetStringEncoded::new(basic_resp),
         })
     } else {
         None
diff --git a/src/rust/src/x509/oid.rs b/src/rust/src/x509/oid.rs
index 45cfc15db..55477c608 100644
--- a/src/rust/src/x509/oid.rs
+++ b/src/rust/src/x509/oid.rs
@@ -43,7 +43,6 @@ pub(crate) const FRESHEST_CRL_OID: asn1::ObjectIdentifier = asn1::oid!(2, 5, 29,
 pub(crate) const INHIBIT_ANY_POLICY_OID: asn1::ObjectIdentifier = asn1::oid!(2, 5, 29, 54);
 
 // Signing methods
-pub(crate) const ECDSA_WITH_SHA1_OID: asn1::ObjectIdentifier = asn1::oid!(1, 2, 840, 10045, 4, 1);
 pub(crate) const ECDSA_WITH_SHA224_OID: asn1::ObjectIdentifier =
     asn1::oid!(1, 2, 840, 10045, 4, 3, 1);
 pub(crate) const ECDSA_WITH_SHA256_OID: asn1::ObjectIdentifier =
@@ -61,8 +60,6 @@ pub(crate) const ECDSA_WITH_SHA3_384_OID: asn1::ObjectIdentifier =
 pub(crate) const ECDSA_WITH_SHA3_512_OID: asn1::ObjectIdentifier =
     asn1::oid!(2, 16, 840, 1, 101, 3, 4, 3, 12);
 
-pub(crate) const RSA_WITH_MD5_OID: asn1::ObjectIdentifier = asn1::oid!(1, 2, 840, 113549, 1, 1, 4);
-pub(crate) const RSA_WITH_SHA1_OID: asn1::ObjectIdentifier = asn1::oid!(1, 2, 840, 113549, 1, 1, 5);
 pub(crate) const RSA_WITH_SHA224_OID: asn1::ObjectIdentifier =
     asn1::oid!(1, 2, 840, 113549, 1, 1, 14);
 pub(crate) const RSA_WITH_SHA256_OID: asn1::ObjectIdentifier =
@@ -80,7 +77,6 @@ pub(crate) const RSA_WITH_SHA3_384_OID: asn1::ObjectIdentifier =
 pub(crate) const RSA_WITH_SHA3_512_OID: asn1::ObjectIdentifier =
     asn1::oid!(2, 16, 840, 1, 101, 3, 4, 3, 16);
 
-pub(crate) const DSA_WITH_SHA1_OID: asn1::ObjectIdentifier = asn1::oid!(1, 2, 840, 10040, 4, 3);
 pub(crate) const DSA_WITH_SHA224_OID: asn1::ObjectIdentifier =
     asn1::oid!(2, 16, 840, 1, 101, 3, 4, 3, 1);
 pub(crate) const DSA_WITH_SHA256_OID: asn1::ObjectIdentifier =
diff --git a/src/rust/src/x509/sign.rs b/src/rust/src/x509/sign.rs
index 4d9157505..37860c3a5 100644
--- a/src/rust/src/x509/sign.rs
+++ b/src/rust/src/x509/sign.rs
@@ -24,8 +24,6 @@ enum KeyType {
 
 enum HashType {
     None,
-    Md5,
-    Sha1,
     Sha224,
     Sha256,
     Sha384,
@@ -97,32 +95,6 @@ fn identify_hash_type(
         .getattr(crate::intern!(py, "name"))?
         .extract()?
     {
-        "md5" => {
-            let cryptography_warning = py
-                .import("cryptography.utils")?
-                .getattr(crate::intern!(py, "DeprecatedIn38"))?;
-            pyo3::PyErr::warn(
-                py,
-                cryptography_warning,
-                "MD5 signatures are deprecated and support for them will be removed in the next version.",
-                1
-            )?;
-
-            Ok(HashType::Md5)
-        }
-        "sha1" => {
-            let cryptography_warning = py
-                .import("cryptography.utils")?
-                .getattr(crate::intern!(py, "DeprecatedIn38"))?;
-            pyo3::PyErr::warn(
-                py,
-                cryptography_warning,
-                "SHA1 signatures are deprecated and support for them will be removed in the next version.",
-                1
-            )?;
-
-            Ok(HashType::Sha1)
-        }
         "sha224" => Ok(HashType::Sha224),
         "sha256" => Ok(HashType::Sha256),
         "sha384" => Ok(HashType::Sha384),
@@ -161,10 +133,6 @@ pub(crate) fn compute_signature_algorithm<'p>(
             ))
         }
 
-        (KeyType::Ec, HashType::Sha1) => Ok(x509::AlgorithmIdentifier {
-            oid: (oid::ECDSA_WITH_SHA1_OID).clone(),
-            params: None,
-        }),
         (KeyType::Ec, HashType::Sha224) => Ok(x509::AlgorithmIdentifier {
             oid: (oid::ECDSA_WITH_SHA224_OID).clone(),
             params: None,
@@ -198,14 +166,6 @@ pub(crate) fn compute_signature_algorithm<'p>(
             params: None,
         }),
 
-        (KeyType::Rsa, HashType::Md5) => Ok(x509::AlgorithmIdentifier {
-            oid: (oid::RSA_WITH_MD5_OID).clone(),
-            params: Some(*NULL_TLV),
-        }),
-        (KeyType::Rsa, HashType::Sha1) => Ok(x509::AlgorithmIdentifier {
-            oid: (oid::RSA_WITH_SHA1_OID).clone(),
-            params: Some(*NULL_TLV),
-        }),
         (KeyType::Rsa, HashType::Sha224) => Ok(x509::AlgorithmIdentifier {
             oid: (oid::RSA_WITH_SHA224_OID).clone(),
             params: Some(*NULL_TLV),
@@ -239,10 +199,6 @@ pub(crate) fn compute_signature_algorithm<'p>(
             params: Some(*NULL_TLV),
         }),
 
-        (KeyType::Dsa, HashType::Sha1) => Ok(x509::AlgorithmIdentifier {
-            oid: (oid::DSA_WITH_SHA1_OID).clone(),
-            params: None,
-        }),
         (KeyType::Dsa, HashType::Sha224) => Ok(x509::AlgorithmIdentifier {
             oid: (oid::DSA_WITH_SHA224_OID).clone(),
             params: None,
@@ -269,9 +225,6 @@ pub(crate) fn compute_signature_algorithm<'p>(
         (_, HashType::None) => Err(pyo3::exceptions::PyTypeError::new_err(
             "Algorithm must be a registered hash algorithm, not None.",
         )),
-        (_, HashType::Md5) => Err(pyo3::exceptions::PyValueError::new_err(
-            "MD5 hash algorithm is only supported with RSA keys",
-        )),
     }
 }
 
diff --git a/tests/bench/test_aead.py b/tests/bench/test_aead.py
index 9eb3fc12f..f93c4e889 100644
--- a/tests/bench/test_aead.py
+++ b/tests/bench/test_aead.py
@@ -4,7 +4,13 @@
 
 import pytest
 
-from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305
+from cryptography.hazmat.primitives.ciphers.aead import (
+    AESCCM,
+    AESGCM,
+    AESOCB3,
+    AESSIV,
+    ChaCha20Poly1305,
+)
 
 from ..hazmat.primitives.test_aead import _aead_supported
 
@@ -13,6 +19,84 @@ from ..hazmat.primitives.test_aead import _aead_supported
     not _aead_supported(ChaCha20Poly1305),
     reason="Requires OpenSSL with ChaCha20Poly1305 support",
 )
-def test_chacha20poly1305(benchmark):
+def test_chacha20poly1305_encrypt(benchmark):
     chacha = ChaCha20Poly1305(b"\x00" * 32)
     benchmark(chacha.encrypt, b"\x00" * 12, b"hello world plaintext", b"")
+
+
+@pytest.mark.skipif(
+    not _aead_supported(ChaCha20Poly1305),
+    reason="Requires OpenSSL with ChaCha20Poly1305 support",
+)
+def test_chacha20poly1305_decrypt(benchmark):
+    chacha = ChaCha20Poly1305(b"\x00" * 32)
+    ct = chacha.encrypt(b"\x00" * 12, b"hello world plaintext", b"")
+    benchmark(chacha.decrypt, b"\x00" * 12, ct, b"")
+
+
+def test_aesgcm_encrypt(benchmark):
+    aes = AESGCM(b"\x00" * 32)
+    benchmark(aes.encrypt, b"\x00" * 12, b"hello world plaintext", None)
+
+
+def test_aesgcm_decrypt(benchmark):
+    aes = AESGCM(b"\x00" * 32)
+    ct = aes.encrypt(b"\x00" * 12, b"hello world plaintext", None)
+    benchmark(aes.decrypt, b"\x00" * 12, ct, None)
+
+
+@pytest.mark.skipif(
+    not _aead_supported(AESSIV),
+    reason="Requires OpenSSL with AES-SIV support",
+)
+def test_aessiv_encrypt(benchmark):
+    aes = AESSIV(b"\x00" * 32)
+    benchmark(aes.encrypt, b"hello world plaintext", None)
+
+
+@pytest.mark.skipif(
+    not _aead_supported(AESSIV),
+    reason="Requires OpenSSL with AES-SIV support",
+)
+def test_aessiv_decrypt(benchmark):
+    aes = AESSIV(b"\x00" * 32)
+    ct = aes.encrypt(b"hello world plaintext", None)
+    benchmark(aes.decrypt, ct, None)
+
+
+@pytest.mark.skipif(
+    not _aead_supported(AESOCB3),
+    reason="Requires OpenSSL with AES-OCB3 support",
+)
+def test_aesocb3_encrypt(benchmark):
+    aes = AESOCB3(b"\x00" * 32)
+    benchmark(aes.encrypt, b"\x00" * 12, b"hello world plaintext", None)
+
+
+@pytest.mark.skipif(
+    not _aead_supported(AESOCB3),
+    reason="Requires OpenSSL with AES-OCB3 support",
+)
+def test_aesocb3_decrypt(benchmark):
+    aes = AESOCB3(b"\x00" * 32)
+    ct = aes.encrypt(b"\x00" * 12, b"hello world plaintext", None)
+    benchmark(aes.decrypt, b"\x00" * 12, ct, None)
+
+
+@pytest.mark.skipif(
+    not _aead_supported(AESCCM),
+    reason="Requires OpenSSL with AES-CCM support",
+)
+def test_aesccm_encrypt(benchmark):
+    aes = AESCCM(b"\x00" * 32)
+    benchmark(aes.encrypt, b"\x00" * 12, b"hello world plaintext", None)
+
+
+@pytest.mark.skipif(
+    not _aead_supported(AESCCM),
+    reason="Requires OpenSSL with AES-CCM support",
+)
+def test_aesccm_decrypt(benchmark):
+    aes = AESCCM(b"\x00" * 32)
+    ct = aes.encrypt(b"\x00" * 12, b"hello world plaintext", None)
+    benchmark(aes.decrypt, b"\x00" * 12, ct, None)
diff --git a/tests/conftest.py b/tests/conftest.py
index 9049922ba..a85b41ff9 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -46,12 +46,3 @@ def backend(request):
     # Ensure the error stack is clear after the test
     errors = openssl_backend._consume_errors_with_text()
     assert not errors
-
-
-@pytest.fixture
-def disable_rsa_checks(backend):
-    # Use this fixture to skip RSA key checks in tests that need the
-    # performance.
-    backend._rsa_skip_check_key = True
-    yield
-    backend._rsa_skip_check_key = False
diff --git a/tests/hazmat/backends/test_openssl.py b/tests/hazmat/backends/test_openssl.py
index 6cc4499a9..a747f4d03 100644
--- a/tests/hazmat/backends/test_openssl.py
+++ b/tests/hazmat/backends/test_openssl.py
@@ -11,7 +11,6 @@ import textwrap
 
 import pytest
 
-from cryptography import utils, x509
 from cryptography.exceptions import InternalError, _Reasons
 from cryptography.hazmat.backends import default_backend
 from cryptography.hazmat.backends.openssl.backend import backend
@@ -35,7 +34,6 @@ from ...utils import (
     load_vectors_from_file,
     raises_unsupported_algorithm,
 )
-from ...x509.test_x509 import _load_cert
 
 
 def skip_if_libre_ssl(openssl_version):
@@ -289,7 +287,7 @@ class TestOpenSSLRandomEngine:
         if sys.platform.startswith("linux"):
             assert name in ["getrandom", "/dev/urandom"]
         if sys.platform == "darwin":
-            assert name in ["getentropy", "/dev/urandom"]
+            assert name in ["getentropy"]
         if sys.platform == "win32":
             assert name == "CryptGenRandom"
 
@@ -479,7 +477,9 @@ class TestOpenSSLSerializationWithOpenSSL:
     def test_unsupported_evp_pkey_type(self):
         key = backend._create_evp_pkey_gc()
         with raises_unsupported_algorithm(None):
-            backend._evp_pkey_to_private_key(key)
+            backend._evp_pkey_to_private_key(
+                key, unsafe_skip_rsa_key_validation=False
+            )
         with raises_unsupported_algorithm(None):
             backend._evp_pkey_to_public_key(key)
 
@@ -495,7 +495,9 @@ class TestOpenSSLSerializationWithOpenSSL:
                 ),
                 lambda pemfile: (
                     backend.load_pem_private_key(
-                        pemfile.read().encode(), password
+                        pemfile.read().encode(),
+                        password,
+                        unsafe_skip_rsa_key_validation=False,
                     )
                 ),
             )
@@ -599,55 +601,3 @@ class TestOpenSSLDHSerialization:
         )
         with pytest.raises(ValueError):
             loader_func(key_bytes, backend)
-
-
-def test_pyopenssl_cert_fallback():
-    cert = _load_cert(
-        os.path.join("x509", "cryptography.io.pem"),
-        x509.load_pem_x509_certificate,
-    )
-    x509_ossl = None
-    with pytest.warns(utils.CryptographyDeprecationWarning):
-        x509_ossl = cert._x509  # type:ignore[attr-defined]
-    assert x509_ossl is not None
-
-    from cryptography.hazmat.backends.openssl.x509 import _Certificate
-
-    with pytest.warns(utils.CryptographyDeprecationWarning):
-        _Certificate(backend, x509_ossl)
-
-
-def test_pyopenssl_csr_fallback():
-    cert = _load_cert(
-        os.path.join("x509", "requests", "rsa_sha256.pem"),
-        x509.load_pem_x509_csr,
-    )
-    req_ossl = None
-    with pytest.warns(utils.CryptographyDeprecationWarning):
-        req_ossl = cert._x509_req  # type:ignore[attr-defined]
-    assert req_ossl is not None
-
-    from cryptography.hazmat.backends.openssl.x509 import (
-        _CertificateSigningRequest,
-    )
-
-    with pytest.warns(utils.CryptographyDeprecationWarning):
-        _CertificateSigningRequest(backend, req_ossl)
-
-
-def test_pyopenssl_crl_fallback():
-    cert = _load_cert(
-        os.path.join("x509", "PKITS_data", "crls", "GoodCACRL.crl"),
-        x509.load_der_x509_crl,
-    )
-    req_crl = None
-    with pytest.warns(utils.CryptographyDeprecationWarning):
-        req_crl = cert._x509_crl  # type:ignore[attr-defined]
-    assert req_crl is not None
-
-    from cryptography.hazmat.backends.openssl.x509 import (
-        _CertificateRevocationList,
-    )
-
-    with pytest.warns(utils.CryptographyDeprecationWarning):
-        _CertificateRevocationList(backend, req_crl)
diff --git a/tests/hazmat/backends/test_openssl_memleak.py b/tests/hazmat/backends/test_openssl_memleak.py
index 2605566bd..e23054a6e 100644
--- a/tests/hazmat/backends/test_openssl_memleak.py
+++ b/tests/hazmat/backends/test_openssl_memleak.py
@@ -27,6 +27,8 @@ def main(argv):
     from cryptography.hazmat.bindings._openssl import ffi, lib
 
     heap = {}
+    start_heap = {}
+    start_heap_realloc_delta = [0]  # 1-item list so callbacks can mutate it
 
     BACKTRACE_ENABLED = False
     if BACKTRACE_ENABLED:
@@ -70,6 +72,20 @@ def main(argv):
             del heap[ptr]
         new_ptr = lib.Cryptography_realloc_wrapper(ptr, size, path, line)
         heap[new_ptr] = (size, path, line, backtrace())
+
+        # It is possible that something during the test will cause a
+        # realloc of memory allocated during the startup phase. (This
+        # was observed in conda-forge Windows builds of this package with
+        # provider operation_bits pointers in crypto/provider_core.c.) If
+        # we don't pay attention to that, the realloc'ed pointer will show
+        # up as a leak; but we also don't want to allow this kind of realloc
+        # to consume large amounts of additional memory. So we track the
+        # realloc and the change in memory consumption.
+        startup_info = start_heap.pop(ptr, None)
+        if startup_info is not None:
+            start_heap[new_ptr] = heap[new_ptr]
+            start_heap_realloc_delta[0] += size - startup_info[0]
+
         return new_ptr
 
     @ffi.callback("void(void *, const char *, int)")
@@ -87,7 +103,7 @@ def main(argv):
 
     hashlib.sha256()
 
-    start_heap = set(heap)
+    start_heap.update(heap)
 
     try:
         func(*argv[1:])
@@ -113,10 +129,12 @@ def main(argv):
         )
         assert result == 1
 
-    remaining = set(heap) - start_heap
+    remaining = set(heap) - set(start_heap)
 
-    if remaining:
-        sys.stdout.write(json.dumps(dict(
+    # The constant here is the number of additional bytes of memory
+    # consumption that are allowed in reallocs of start_heap memory.
+    if remaining or start_heap_realloc_delta[0] > 3072:
+        info = dict(
             (int(ffi.cast("size_t", ptr)), {
                 "size": heap[ptr][0],
                 "path": ffi.string(heap[ptr][1]).decode(),
@@ -124,7 +142,9 @@ def main(argv):
                 "backtrace": symbolize_backtrace(heap[ptr][3]),
             })
             for ptr in remaining
-        )))
+        )
+        info["start_heap_realloc_delta"] = start_heap_realloc_delta[0]
+        sys.stdout.write(json.dumps(info))
         sys.stdout.flush()
         sys.exit(255)
 
@@ -249,52 +269,6 @@ class TestAssertNoMemoryLeaks:
 @pytest.mark.skip_fips(reason="FIPS self-test sets allow_customize = 0")
 @skip_if_memtesting_not_supported()
 class TestOpenSSLMemoryLeaks:
-    @pytest.mark.parametrize(
-        "path", ["x509/PKITS_data/certs/ValidcRLIssuerTest28EE.crt"]
-    )
-    def test_der_x509_certificate_extensions(self, path):
-        assert_no_memory_leaks(
-            textwrap.dedent(
-                """
-        def func(path):
-            from cryptography import x509
-            from cryptography.hazmat.backends.openssl import backend
-
-            import cryptography_vectors
-
-            with cryptography_vectors.open_vector_file(path, "rb") as f:
-                cert = x509.load_der_x509_certificate(
-                    f.read(), backend
-                )
-
-            cert.extensions
-        """
-            ),
-            [path],
-        )
-
-    @pytest.mark.parametrize("path", ["x509/cryptography.io.pem"])
-    def test_pem_x509_certificate_extensions(self, path):
-        assert_no_memory_leaks(
-            textwrap.dedent(
-                """
-        def func(path):
-            from cryptography import x509
-            from cryptography.hazmat.backends.openssl import backend
-
-            import cryptography_vectors
-
-            with cryptography_vectors.open_vector_file(path, "rb") as f:
-                cert = x509.load_pem_x509_certificate(
-                    f.read(), backend
-                )
-
-            cert.extensions
-        """
-            ),
-            [path],
-        )
-
     def test_x509_csr_extensions(self):
         assert_no_memory_leaks(
             textwrap.dedent(
diff --git a/tests/hazmat/bindings/test_openssl.py b/tests/hazmat/bindings/test_openssl.py
index abc0e1528..620426272 100644
--- a/tests/hazmat/bindings/test_openssl.py
+++ b/tests/hazmat/bindings/test_openssl.py
@@ -2,13 +2,13 @@
 # 2.0, and the BSD License. See the LICENSE file in the root of this repository
 # for complete details.
 
-
 import pytest
 
 from cryptography.exceptions import InternalError
 from cryptography.hazmat.bindings.openssl.binding import (
     Binding,
     _consume_errors,
+    _legacy_provider_error,
     _openssl_assert,
     _verify_package_version,
 )
@@ -117,3 +117,9 @@ class TestOpenSSL:
     def test_version_mismatch(self):
         with pytest.raises(ImportError):
             _verify_package_version("nottherightversion")
+
+    def test_legacy_provider_error(self):
+        with pytest.raises(RuntimeError):
+            _legacy_provider_error(False)
+
+        _legacy_provider_error(True)
diff --git a/tests/hazmat/primitives/test_aead.py b/tests/hazmat/primitives/test_aead.py
index dcbf76bd5..b7a4aedf3 100644
--- a/tests/hazmat/primitives/test_aead.py
+++ b/tests/hazmat/primitives/test_aead.py
@@ -625,7 +625,17 @@ class TestAESSIV(object):
             aessiv.encrypt(FakeData(), None)
 
         with pytest.raises(OverflowError):
-            aessiv.encrypt(b"", [FakeData()])
+            aessiv.encrypt(b"irrelevant", [FakeData()])
+
+    def test_no_empty_encryption(self):
+        key = AESSIV.generate_key(256)
+        aessiv = AESSIV(key)
+
+        with pytest.raises(ValueError):
+            aessiv.encrypt(b"", None)
+
+        with pytest.raises(ValueError):
+            aessiv.decrypt(b"", None)
 
     def test_vectors(self, backend, subtests):
         vectors = load_vectors_from_file(
diff --git a/tests/hazmat/primitives/test_dh.py b/tests/hazmat/primitives/test_dh.py
index b8216a9a7..6e708676b 100644
--- a/tests/hazmat/primitives/test_dh.py
+++ b/tests/hazmat/primitives/test_dh.py
@@ -148,6 +148,10 @@ class TestDH:
         with pytest.raises(ValueError):
             dh.generate_parameters(7, 512, backend)
 
+    def test_large_key_generate_dh(self):
+        with pytest.raises(ValueError):
+            dh.generate_parameters(2, 1 << 30)
+
     @pytest.mark.skip_fips(reason="non-FIPS parameters")
     def test_dh_parameters_supported(self, backend):
         valid_p = int(
diff --git a/tests/hazmat/primitives/test_ec.py b/tests/hazmat/primitives/test_ec.py
index 707d23360..6022b9502 100644
--- a/tests/hazmat/primitives/test_ec.py
+++ b/tests/hazmat/primitives/test_ec.py
@@ -12,14 +12,13 @@ from binascii import hexlify
 
 import pytest
 
-from cryptography import exceptions, utils, x509
+from cryptography import exceptions, x509
 from cryptography.hazmat.primitives import hashes, serialization
 from cryptography.hazmat.primitives.asymmetric import ec
 from cryptography.hazmat.primitives.asymmetric.utils import (
     Prehashed,
     encode_dss_signature,
 )
-from cryptography.utils import CryptographyDeprecationWarning
 
 from .fixtures_ec import EC_KEY_SECP384R1
 from .utils import skip_fips_traditional_openssl
@@ -171,73 +170,6 @@ def test_invalid_private_numbers_public_numbers():
         ec.EllipticCurvePrivateNumbers(1, None)  # type: ignore[arg-type]
 
 
-def test_encode_point():
-    # secp256r1 point
-    x = int(
-        "233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22aec", 16
-    )
-    y = int(
-        "3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e", 16
-    )
-    pn = ec.EllipticCurvePublicNumbers(x, y, ec.SECP256R1())
-    with pytest.warns(utils.PersistentlyDeprecated2019):
-        data = pn.encode_point()
-    assert data == binascii.unhexlify(
-        "04233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22ae"
-        "c3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e"
-    )
-
-
-def test_from_encoded_point():
-    # secp256r1 point
-    data = binascii.unhexlify(
-        "04233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22ae"
-        "c3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e"
-    )
-    with pytest.warns(CryptographyDeprecationWarning):
-        pn = ec.EllipticCurvePublicNumbers.from_encoded_point(
-            ec.SECP256R1(), data
-        )
-    assert pn.x == int(
-        "233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22aec", 16
-    )
-    assert pn.y == int(
-        "3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460b35f442e", 16
-    )
-
-
-def test_from_encoded_point_invalid_length():
-    bad_data = binascii.unhexlify(
-        "04233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22ae"
-        "c3ea2c10a84153862be4ec82940f0543f9ba866af9751a6ee79d38460"
-    )
-    with pytest.raises(ValueError):
-        with pytest.warns(CryptographyDeprecationWarning):
-            ec.EllipticCurvePublicNumbers.from_encoded_point(
-                ec.SECP384R1(), bad_data
-            )
-
-
-def test_from_encoded_point_unsupported_point_no_backend():
-    # set to point type 2.
-    unsupported_type = binascii.unhexlify(
-        "02233ea3b0027127084cd2cd336a13aeef69c598d8af61369a36454a17c6c22a"
-    )
-    with pytest.raises(ValueError):
-        with pytest.warns(CryptographyDeprecationWarning):
-            ec.EllipticCurvePublicNumbers.from_encoded_point(
-                ec.SECP256R1(), unsupported_type
-            )
-
-
-def test_from_encoded_point_not_a_curve():
-    with pytest.raises(TypeError):
-        with pytest.warns(CryptographyDeprecationWarning):
-            ec.EllipticCurvePublicNumbers.from_encoded_point(
-                "notacurve", b"\x04data"  # type: ignore[arg-type]
-            )
-
-
 def test_ec_public_numbers_repr():
     pn = ec.EllipticCurvePublicNumbers(2, 3, ec.SECP256R1())
     assert repr(pn) == "<EllipticCurvePublicNumbers(curve=secp256r1, x=2, y=3>"
diff --git a/tests/hazmat/primitives/test_pkcs7.py b/tests/hazmat/primitives/test_pkcs7.py
index 138bc0f3b..8c5c1e3cf 100644
--- a/tests/hazmat/primitives/test_pkcs7.py
+++ b/tests/hazmat/primitives/test_pkcs7.py
@@ -14,7 +14,6 @@ from cryptography.hazmat.primitives import hashes, serialization
 from cryptography.hazmat.primitives.asymmetric import ed25519, rsa
 from cryptography.hazmat.primitives.serialization import pkcs7
 
-from .utils import skip_signature_hash
 from ...utils import load_vectors_from_file, raises_unsupported_algorithm
 
 
@@ -345,7 +344,6 @@ class TestPKCS7Builder:
     @pytest.mark.parametrize(
         ("hash_alg", "expected_value"),
         [
-            (hashes.SHA1(), b"\x06\x05+\x0e\x03\x02\x1a"),
             (hashes.SHA256(), b"\x06\t`\x86H\x01e\x03\x04\x02\x01"),
             (hashes.SHA384(), b"\x06\t`\x86H\x01e\x03\x04\x02\x02"),
             (hashes.SHA512(), b"\x06\t`\x86H\x01e\x03\x04\x02\x03"),
@@ -354,8 +352,6 @@ class TestPKCS7Builder:
     def test_sign_alternate_digests_der(
         self, hash_alg, expected_value, backend
     ):
-        skip_signature_hash(backend, hash_alg)
-
         data = b"hello world"
         cert, key = _load_cert_key()
         builder = (
@@ -373,7 +369,6 @@ class TestPKCS7Builder:
     @pytest.mark.parametrize(
         ("hash_alg", "expected_value"),
         [
-            (hashes.SHA1(), b"sha1"),
             (hashes.SHA256(), b"sha-256"),
             (hashes.SHA384(), b"sha-384"),
             (hashes.SHA512(), b"sha-512"),
@@ -382,8 +377,6 @@ class TestPKCS7Builder:
     def test_sign_alternate_digests_detached(
         self, hash_alg, expected_value, backend
     ):
-        skip_signature_hash(backend, hash_alg)
-
         data = b"hello world"
         cert, key = _load_cert_key()
         builder = (
@@ -741,7 +734,7 @@ class TestPKCS7SerializeCerts:
             list(reversed(certs)), serialization.Encoding.DER
         )
         certs2 = pkcs7.load_der_pkcs7_certificates(p7)
-        assert certs != certs2
+        assert certs == certs2
 
     def test_pem_matches_vector(self, backend):
         p7_pem = load_vectors_from_file(
diff --git a/tests/hazmat/primitives/test_rsa.py b/tests/hazmat/primitives/test_rsa.py
index 6f083cbcb..5a9fa19f3 100644
--- a/tests/hazmat/primitives/test_rsa.py
+++ b/tests/hazmat/primitives/test_rsa.py
@@ -487,7 +487,7 @@ class TestRSASignature:
         ),
         skip_message="Does not support SHA1 signature.",
     )
-    def test_pkcs1v15_signing(self, backend, disable_rsa_checks, subtests):
+    def test_pkcs1v15_signing(self, backend, subtests):
         vectors = _flatten_pkcs1_examples(
             load_vectors_from_file(
                 os.path.join("asymmetric", "RSA", "pkcs1v15sign-vectors.txt"),
@@ -506,7 +506,7 @@ class TestRSASignature:
                     public_numbers=rsa.RSAPublicNumbers(
                         e=private["public_exponent"], n=private["modulus"]
                     ),
-                ).private_key(backend)
+                ).private_key(backend, unsafe_skip_rsa_key_validation=True)
                 signature = private_key.sign(
                     binascii.unhexlify(example["message"]),
                     padding.PKCS1v15(),
@@ -1682,9 +1682,7 @@ class TestRSADecryption:
         ),
         skip_message="Does not support PKCS1v1.5.",
     )
-    def test_decrypt_pkcs1v15_vectors(
-        self, backend, disable_rsa_checks, subtests
-    ):
+    def test_decrypt_pkcs1v15_vectors(self, backend, subtests):
         vectors = _flatten_pkcs1_examples(
             load_vectors_from_file(
                 os.path.join("asymmetric", "RSA", "pkcs1v15crypt-vectors.txt"),
@@ -1703,7 +1701,7 @@ class TestRSADecryption:
                     public_numbers=rsa.RSAPublicNumbers(
                         e=private["public_exponent"], n=private["modulus"]
                     ),
-                ).private_key(backend)
+                ).private_key(backend, unsafe_skip_rsa_key_validation=True)
                 ciphertext = binascii.unhexlify(example["encryption"])
                 assert len(ciphertext) == (skey.key_size + 7) // 8
                 message = skey.decrypt(ciphertext, padding.PKCS1v15())
@@ -1804,9 +1802,7 @@ class TestRSADecryption:
             "Does not support OAEP using SHA224 MGF1 and SHA224 hash."
         ),
     )
-    def test_decrypt_oaep_sha2_vectors(
-        self, backend, disable_rsa_checks, subtests
-    ):
+    def test_decrypt_oaep_sha2_vectors(self, backend, subtests):
         vectors = _build_oaep_sha2_vectors()
         for private, public, example, mgf1_alg, hash_alg in vectors:
             with subtests.test():
@@ -1820,7 +1816,7 @@ class TestRSADecryption:
                     public_numbers=rsa.RSAPublicNumbers(
                         e=private["public_exponent"], n=private["modulus"]
                     ),
-                ).private_key(backend)
+                ).private_key(backend, unsafe_skip_rsa_key_validation=True)
                 message = skey.decrypt(
                     binascii.unhexlify(example["encryption"]),
                     padding.OAEP(
diff --git a/tests/hazmat/primitives/utils.py b/tests/hazmat/primitives/utils.py
index 3684c38c3..c8021cc2f 100644
--- a/tests/hazmat/primitives/utils.py
+++ b/tests/hazmat/primitives/utils.py
@@ -572,8 +572,3 @@ def skip_fips_traditional_openssl(backend, fmt):
         pytest.skip(
             "Traditional OpenSSL key format is not supported in FIPS mode."
         )
-
-
-def skip_signature_hash(backend, hash_alg: hashes.HashAlgorithm):
-    if not backend.signature_hash_supported(hash_alg):
-        pytest.skip(f"{hash_alg} is not a supported signature hash algorithm.")
diff --git a/tests/hazmat/test_oid.py b/tests/hazmat/test_oid.py
index 8fa7d2b06..f537abcd5 100644
--- a/tests/hazmat/test_oid.py
+++ b/tests/hazmat/test_oid.py
@@ -2,6 +2,7 @@
 # 2.0, and the BSD License. See the LICENSE file in the root of this repository
 # for complete details.
 
+import copy
 
 import pytest
 
@@ -12,6 +13,15 @@ def test_basic_oid():
     assert ObjectIdentifier("1.2.3.4").dotted_string == "1.2.3.4"
 
 
+def test_oid_equal():
+    assert ObjectIdentifier("1.2.3.4") == ObjectIdentifier("1.2.3.4")
+
+
+def test_oid_deepcopy():
+    oid = ObjectIdentifier("1.2.3.4")
+    assert oid == copy.deepcopy(oid)
+
+
 def test_oid_constraint():
     # Too short
     with pytest.raises(ValueError):
diff --git a/tests/test_cryptography_utils.py b/tests/test_cryptography_utils.py
index 065da7b2d..98fd6165a 100644
--- a/tests/test_cryptography_utils.py
+++ b/tests/test_cryptography_utils.py
@@ -56,9 +56,9 @@ class TestCachedProperty:
 
 def test_enum():
     class TestEnum(utils.Enum):
-        value = "something"
+        something = "something"
 
     assert issubclass(TestEnum, enum.Enum)
-    assert isinstance(TestEnum.value, enum.Enum)
-    assert repr(TestEnum.value) == "<TestEnum.value: 'something'>"
-    assert str(TestEnum.value) == "TestEnum.value"
+    assert isinstance(TestEnum.something, enum.Enum)
+    assert repr(TestEnum.something) == "<TestEnum.something: 'something'>"
+    assert str(TestEnum.something) == "TestEnum.something"
diff --git a/tests/test_interfaces.py b/tests/test_interfaces.py
index 302edb93e..06c09f327 100644
--- a/tests/test_interfaces.py
+++ b/tests/test_interfaces.py
@@ -4,16 +4,11 @@
 
 import abc
 
-import pytest
-
-from cryptography.utils import (
-    InterfaceNotImplemented,
-    verify_interface,
-)
+from cryptography.utils import verify_interface
 
 
 class TestVerifyInterface:
-    def test_verify_missing_method(self):
+    def test_noop(self):
         class SimpleInterface(metaclass=abc.ABCMeta):
             @abc.abstractmethod
             def method(self):
@@ -22,59 +17,4 @@ class TestVerifyInterface:
         class NonImplementer:
             pass
 
-        with pytest.raises(InterfaceNotImplemented):
-            verify_interface(SimpleInterface, NonImplementer)
-
-    def test_different_arguments(self):
-        class SimpleInterface(metaclass=abc.ABCMeta):
-            @abc.abstractmethod
-            def method(self, a):
-                """Method with one argument"""
-
-        class NonImplementer:
-            def method(self):
-                """Method with no arguments"""
-
-        # Invoke this to ensure the line is covered
-        NonImplementer().method()
-        with pytest.raises(InterfaceNotImplemented):
-            verify_interface(SimpleInterface, NonImplementer)
-
-    def test_handles_abstract_property(self):
-        class SimpleInterface(metaclass=abc.ABCMeta):
-            @abc.abstractproperty
-            def property(self):
-                """An abstract property"""
-
-        class NonImplementer:
-            @property
-            def property(self):
-                """A concrete property"""
-
-        # Invoke this to ensure the line is covered
-        NonImplementer().property
         verify_interface(SimpleInterface, NonImplementer)
-
-    def test_signature_mismatch(self):
-        class SimpleInterface(metaclass=abc.ABCMeta):
-            @abc.abstractmethod
-            def method(self, other: object) -> int:
-                """Method with signature"""
-
-        class ClassWithoutSignature:
-            def method(self, other):
-                """Method without signature"""
-
-        class ClassWithSignature:
-            def method(self, other: object) -> int:
-                """Method with signature"""
-
-        verify_interface(SimpleInterface, ClassWithoutSignature)
-        verify_interface(SimpleInterface, ClassWithSignature)
-        with pytest.raises(InterfaceNotImplemented):
-            verify_interface(
-                SimpleInterface, ClassWithoutSignature, check_annotations=True
-            )
-        verify_interface(
-            SimpleInterface, ClassWithSignature, check_annotations=True
-        )
diff --git a/tests/test_rust_utils.py b/tests/test_rust_utils.py
index 99ddfb01a..1ee68541e 100644
--- a/tests/test_rust_utils.py
+++ b/tests/test_rust_utils.py
@@ -19,10 +19,7 @@ class TestFixedPool:
             events.append(("create", c))
             return c
 
-        def destroy(c):
-            events.append(("destroy", c))
-
-        pool = FixedPool(create, destroy)
+        pool = FixedPool(create)
         assert events == [("create", 1)]
         with pool.acquire() as c:
             assert c == 1
@@ -32,9 +29,9 @@ class TestFixedPool:
                 assert c == 2
                 assert events == [("create", 1), ("create", 2)]
 
-            assert events == [("create", 1), ("create", 2), ("destroy", 2)]
+            assert events == [("create", 1), ("create", 2)]
 
-        assert events == [("create", 1), ("create", 2), ("destroy", 2)]
+        assert events == [("create", 1), ("create", 2)]
 
         del pool
         gc.collect()
@@ -44,18 +41,13 @@ class TestFixedPool:
         assert events == [
             ("create", 1),
             ("create", 2),
-            ("destroy", 2),
-            ("destroy", 1),
         ]
 
     def test_thread_stress(self):
         def create():
             return None
 
-        def destroy(c):
-            pass
-
-        pool = FixedPool(create, destroy)
+        pool = FixedPool(create)
 
         def thread_fn():
             with pool.acquire():
diff --git a/tests/wycheproof/test_rsa.py b/tests/wycheproof/test_rsa.py
index 7925a5bf9..0670e1c47 100644
--- a/tests/wycheproof/test_rsa.py
+++ b/tests/wycheproof/test_rsa.py
@@ -98,6 +98,7 @@ def test_rsa_pkcs1v15_signature_generation(backend, wycheproof):
         wycheproof.testgroup["privateKeyPem"].encode(),
         password=None,
         backend=backend,
+        unsafe_skip_rsa_key_validation=True,
     )
     assert isinstance(key, rsa.RSAPrivateKey)
     digest = _DIGESTS[wycheproof.testgroup["sha"]]
@@ -193,6 +194,7 @@ def test_rsa_oaep_encryption(backend, wycheproof):
         wycheproof.testgroup["privateKeyPem"].encode("ascii"),
         password=None,
         backend=backend,
+        unsafe_skip_rsa_key_validation=True,
     )
     assert isinstance(key, rsa.RSAPrivateKey)
     digest = _DIGESTS[wycheproof.testgroup["sha"]]
@@ -228,6 +230,7 @@ def test_rsa_pkcs1_encryption(backend, wycheproof):
         wycheproof.testgroup["privateKeyPem"].encode("ascii"),
         password=None,
         backend=backend,
+        unsafe_skip_rsa_key_validation=True,
     )
     assert isinstance(key, rsa.RSAPrivateKey)
 
diff --git a/tests/wycheproof/utils.py b/tests/wycheproof/utils.py
index 3c18e62af..eebbe7ce3 100644
--- a/tests/wycheproof/utils.py
+++ b/tests/wycheproof/utils.py
@@ -3,9 +3,7 @@ from ..utils import load_wycheproof_tests
 
 def wycheproof_tests(*paths):
     def wrapper(func):
-        def run_wycheproof(
-            backend, disable_rsa_checks, subtests, pytestconfig
-        ):
+        def run_wycheproof(backend, subtests, pytestconfig):
             wycheproof_root = pytestconfig.getoption(
                 "--wycheproof-root", skip=True
             )
diff --git a/tests/x509/test_ocsp.py b/tests/x509/test_ocsp.py
index 9b276783a..9090e5205 100644
--- a/tests/x509/test_ocsp.py
+++ b/tests/x509/test_ocsp.py
@@ -162,12 +162,55 @@ class TestOCSPRequest:
 
 
 class TestOCSPRequestBuilder:
-    def test_add_two_certs(self):
+    def test_add_cert_twice(self):
         cert, issuer = _cert_and_issuer()
         builder = ocsp.OCSPRequestBuilder()
         builder = builder.add_certificate(cert, issuer, hashes.SHA1())
+        # Fails calling a second time
         with pytest.raises(ValueError):
             builder.add_certificate(cert, issuer, hashes.SHA1())
+        # Fails calling a second time with add_certificate_by_hash
+        with pytest.raises(ValueError):
+            builder.add_certificate_by_hash(
+                b"0" * 20, b"0" * 20, 1, hashes.SHA1()
+            )
+
+    def test_add_cert_by_hash_twice(self):
+        cert, issuer = _cert_and_issuer()
+        builder = ocsp.OCSPRequestBuilder()
+        builder = builder.add_certificate_by_hash(
+            b"0" * 20, b"0" * 20, 1, hashes.SHA1()
+        )
+        # Fails calling a second time
+        with pytest.raises(ValueError):
+            builder.add_certificate_by_hash(
+                b"0" * 20, b"0" * 20, 1, hashes.SHA1()
+            )
+        # Fails calling a second time with add_certificate
+        with pytest.raises(ValueError):
+            builder.add_certificate(cert, issuer, hashes.SHA1())
+
+    def test_add_cert_by_hash_bad_hash(self):
+        builder = ocsp.OCSPRequestBuilder()
+        with pytest.raises(ValueError):
+            builder.add_certificate_by_hash(
+                b"0" * 20, b"0" * 20, 1, "notahash"  # type:ignore[arg-type]
+            )
+        with pytest.raises(ValueError):
+            builder.add_certificate_by_hash(
+                b"0" * 19, b"0" * 20, 1, hashes.SHA1()
+            )
+        with pytest.raises(ValueError):
+            builder.add_certificate_by_hash(
+                b"0" * 20, b"0" * 21, 1, hashes.SHA1()
+            )
+        with pytest.raises(TypeError):
+            builder.add_certificate_by_hash(
+                b"0" * 20,
+                b"0" * 20,
+                "notanint",  # type:ignore[arg-type]
+                hashes.SHA1(),
+            )
 
     def test_create_ocsp_request_no_req(self):
         builder = ocsp.OCSPRequestBuilder()
@@ -251,6 +294,28 @@ class TestOCSPRequestBuilder:
         assert req.extensions[0].oid == ext.oid
         assert req.extensions[0].critical is critical
 
+    def test_add_cert_by_hash(self):
+        cert, issuer = _cert_and_issuer()
+        builder = ocsp.OCSPRequestBuilder()
+        h = hashes.Hash(hashes.SHA1())
+        h.update(cert.issuer.public_bytes())
+        issuer_name_hash = h.finalize()
+        # issuer_key_hash is a hash of the public key BitString DER,
+        # not the subjectPublicKeyInfo
+        issuer_key_hash = base64.b64decode(b"w5zz/NNGCDS7zkZ/oHxb8+IIy1k=")
+        builder = builder.add_certificate_by_hash(
+            issuer_name_hash,
+            issuer_key_hash,
+            cert.serial_number,
+            hashes.SHA1(),
+        )
+        req = builder.build()
+        serialized = req.public_bytes(serialization.Encoding.DER)
+        assert serialized == base64.b64decode(
+            b"MEMwQTA/MD0wOzAJBgUrDgMCGgUABBRAC0Z68eay0wmDug1gfn5ZN0gkxAQUw5zz"
+            b"/NNGCDS7zkZ/oHxb8+IIy1kCAj8g"
+        )
+
 
 class TestOCSPResponseBuilder:
     def test_add_response_twice(self):
diff --git a/tests/x509/test_x509.py b/tests/x509/test_x509.py
index aecf6f8bb..19047c87c 100644
--- a/tests/x509/test_x509.py
+++ b/tests/x509/test_x509.py
@@ -1864,7 +1864,6 @@ class TestRSACertificateRequest:
     @pytest.mark.parametrize(
         ("hashalg", "hashalg_oid"),
         [
-            (hashes.SHA1, x509.SignatureAlgorithmOID.RSA_WITH_SHA1),
             (hashes.SHA224, x509.SignatureAlgorithmOID.RSA_WITH_SHA224),
             (hashes.SHA256, x509.SignatureAlgorithmOID.RSA_WITH_SHA256),
             (hashes.SHA384, x509.SignatureAlgorithmOID.RSA_WITH_SHA384),
@@ -2075,7 +2074,7 @@ class TestCertificateBuilder:
         )
 
         with pytest.raises(NotImplementedError):
-            builder.sign(private_key, hashes.SHA1(), backend)
+            builder.sign(private_key, hashes.SHA256(), backend)
 
     def test_encode_nonstandard_aia(self, backend):
         private_key = RSA_KEY_2048.private_key(backend)
@@ -2648,28 +2647,6 @@ class TestCertificateBuilder:
         with pytest.raises(ValueError):
             builder.sign(private_key, hashes.SHA256(), backend)
 
-    @pytest.mark.supported(
-        only_if=lambda backend: backend.hash_supported(hashes.MD5()),
-        skip_message="Requires OpenSSL with MD5 support",
-    )
-    def test_sign_rsa_with_md5(self, backend):
-        private_key = RSA_KEY_2048.private_key(backend)
-        builder = x509.CertificateBuilder()
-        builder = (
-            builder.subject_name(
-                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, "US")])
-            )
-            .issuer_name(
-                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, "US")])
-            )
-            .serial_number(1)
-            .public_key(private_key.public_key())
-            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))
-            .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))
-        )
-        cert = builder.sign(private_key, hashes.MD5(), backend)
-        assert isinstance(cert.signature_hash_algorithm, hashes.MD5)
-
     @pytest.mark.supported(
         only_if=lambda backend: backend.hash_supported(hashes.MD5()),
         skip_message="Requires OpenSSL with MD5 support",
@@ -2736,7 +2713,6 @@ class TestCertificateBuilder:
     @pytest.mark.parametrize(
         ("hashalg", "hashalg_oid"),
         [
-            (hashes.SHA1, x509.SignatureAlgorithmOID.DSA_WITH_SHA1),
             (hashes.SHA224, x509.SignatureAlgorithmOID.DSA_WITH_SHA224),
             (hashes.SHA256, x509.SignatureAlgorithmOID.DSA_WITH_SHA256),
             (hashes.SHA384, x509.SignatureAlgorithmOID.DSA_WITH_SHA384),
@@ -2799,7 +2775,6 @@ class TestCertificateBuilder:
     @pytest.mark.parametrize(
         ("hashalg", "hashalg_oid"),
         [
-            (hashes.SHA1, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA1),
             (hashes.SHA224, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA224),
             (hashes.SHA256, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA256),
             (hashes.SHA384, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA384),
@@ -3761,48 +3736,6 @@ class TestCertificateSigningRequestBuilder:
         with pytest.raises(ValueError):
             builder.sign(private_key, hashes.SHA256(), backend)
 
-    @pytest.mark.supported(
-        only_if=lambda backend: backend.hash_supported(hashes.MD5()),
-        skip_message="Requires OpenSSL with MD5 support",
-    )
-    def test_sign_rsa_with_md5(self, backend):
-        private_key = RSA_KEY_2048.private_key(backend)
-
-        builder = x509.CertificateSigningRequestBuilder().subject_name(
-            x509.Name([x509.NameAttribute(NameOID.ORGANIZATION_NAME, "PyCA")])
-        )
-        request = builder.sign(private_key, hashes.MD5(), backend)
-        assert isinstance(request.signature_hash_algorithm, hashes.MD5)
-
-    @pytest.mark.supported(
-        only_if=lambda backend: backend.hash_supported(hashes.MD5()),
-        skip_message="Requires OpenSSL with MD5 support",
-    )
-    @pytest.mark.supported(
-        only_if=lambda backend: backend.dsa_supported(),
-        skip_message="Does not support DSA.",
-    )
-    def test_sign_dsa_with_md5(self, backend):
-        private_key = DSA_KEY_2048.private_key(backend)
-        builder = x509.CertificateSigningRequestBuilder().subject_name(
-            x509.Name([x509.NameAttribute(NameOID.ORGANIZATION_NAME, "PyCA")])
-        )
-        with pytest.raises(ValueError):
-            builder.sign(private_key, hashes.MD5(), backend)
-
-    @pytest.mark.supported(
-        only_if=lambda backend: backend.hash_supported(hashes.MD5()),
-        skip_message="Requires OpenSSL with MD5 support",
-    )
-    def test_sign_ec_with_md5(self, backend):
-        _skip_curve_unsupported(backend, ec.SECP256R1())
-        private_key = EC_KEY_SECP256R1.private_key(backend)
-        builder = x509.CertificateSigningRequestBuilder().subject_name(
-            x509.Name([x509.NameAttribute(NameOID.ORGANIZATION_NAME, "PyCA")])
-        )
-        with pytest.raises(ValueError):
-            builder.sign(private_key, hashes.MD5(), backend)
-
     def test_no_subject_name(self, backend):
         private_key = RSA_KEY_2048.private_key(backend)
 
diff --git a/tests/x509/test_x509_ext.py b/tests/x509/test_x509_ext.py
index fd09b091d..7284a73be 100644
--- a/tests/x509/test_x509_ext.py
+++ b/tests/x509/test_x509_ext.py
@@ -3968,6 +3968,10 @@ class TestDistributionPoint:
                 "data", "notname", None, None  # type:ignore[arg-type]
             )
 
+    def test_no_full_name_relative_name_or_crl_issuer(self):
+        with pytest.raises(ValueError):
+            x509.DistributionPoint(None, None, None, None)
+
     def test_crl_issuer_not_general_names(self):
         with pytest.raises(TypeError):
             x509.DistributionPoint(
